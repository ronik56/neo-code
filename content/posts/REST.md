---
title: "REST"
date: 2020-09-17T08:13:16+03:00
draft: false
categories: ["כללי"]
tags: ["כללי"]
featured_image: /REST.png
---

קצת אחרי בועת הדוט קום, החלה מלחמת אופל בין SOAP ל- REST, שמטרתן הייתה לקבוע סטנדרט לבנייה ותקשורת בין "Web Services", כלומר לקבוע איך בונים מערכות המתקשרות ביניהן דרך האינטרנט הגדול. בקרב הזה REST ניצח, לפחות לעת עתה.

את המושג REST, שנקרא Representational State Transfer, טבע לראשונה רוי פילדינג, כמה שנים אחרי שמייקרוסופט שיחררה את הפרוטוקול שלה: SOAP. עם השנים REST הפכה לגישה הדומיננטית ביותר לבניית Web Services, בעיקר בגלל שרסט הייתה פשוטה יותר, נוחה, והרבה יותר גמישה וסלחנית. למשל, לפי REST אפשר להעביר מידע בתצורות שונות כמו ג'ייסון, XML וכד'. ב SOAP, אפשר להעביר מידע רק בתצורת XML.

קשה להשוואת בין SOAP ל REST, מכיוון שאי אפשר. REST היא ארכיטקטורה עם סט חוקים שצריך לישם, ו-SOAP הוא פרוטוקול. אך עדיין סרביסים התפלגו לכאלה שנבנים תוך שימוש ב SOAP כפרוטוקול תקשורת, וכאלה שעומדים בתנאים של REST.

הגישה של REST מכריחה כל מערכת שרוצה להיחשב כ 'RESTful' לעמוד בתנאים הבאים:

א) לחלק את המבנה לקליינט ושרת. הקליינט מציג את המידע, והשרת מעבד ושומר את המידע. שניהם צריכים להיות מופרדים ולא קשורים אחד לשני (או לדעת על קיום וזהותם אחד של השני).

ב) Stateless - המערכת לא צריכה לנהל שום סטייט של אף קליינט. זה אומר שהקליינט צריך לספק לשרת מספיק מידע בקריאה בשביל שהשרת יוכל לזהות את המידע ולבצע את הפעולות שהקליינט דורש ממנו.

ג) Caching- השרת יכול להחזיר לקליינט בקשה ולהצהיר לקליינט שהוא יכול לשמור את המידע שקיבלת, ולהשתמש בו עד לפרק הזמן שהשרת נותן. כך הקליינט יכול לחסוך קריאה לשרת כשיש בידו את המידע העדכני.

ד) האפשרות להרכיב שכבות בין התקשורת- הקליינט ו\או השרת אינם חייבים לתקשר ביניהם ישירות. למשל אפשר להכניס middle man כמו פרוקסי שייתן עוד שכבת אבטחה או לוגיקה ביניהם. כל זה מבלי לשנות משהוא אצל השרת או הקליינט.

ה) ממשק אחיד (Uniform Interface) לתקשורת בין סרביסים ולקליינט-שרת. הבקשה מהקליינט צריכה לציין את צורת המידע שהוא מעוניין להעביר ולקבל, ועליו להעביר מספיק מידע בשביל שהשרת יוכל לעבד את הבקשה ולשנות את המידע בדטאבייס (לדוגמה, הקליינט ישלח בקשת POST, והשרת יידע שהמטרה היא לשמור את המידע). בנוסף, כל מידע מקבל ייחוס בדמות של לינק  (resource), כך שאפשר לנווט אליו או לשנות את המידע. לדוגמה, אם יש לנו משתמשים והודעות משתמשים, אז הלינק למשתמש יכול להיות /user ולהודעות user/id/messages.

הפאזל האחרון לממשק האחיד מכיל את המושג HATEOS - Hyper As The Engine Of Application Sate. הכוונה היא שהתצורת ניווט באתר\סרביס הוא דרך לינקים. השרת מחזיר בתשובתו טקסט (שכיום יהיה אובייקט ג'ייסון) שמכיל בתוכו לינקים, והלינקים הללו הם ההוראות אל הקליינט (או סרביס אחר) לאיך לנווט באתר\סרביס.
השימוש בזה כיום הוא פחות נפוץ, כשרוב הקליינטים כיום מרנדרים לעצמם מראש את הלינקים בתוך הUI, ולא בדיוק מחכים להוראות מהשרת.
אם נחבר את כל הממשק, GET /users היא שפה אחידה ל"הבאנה לי את המשתמש". כיום בדר"כ מציינים את תצורת המידע כג'ייסון. בתוך התשובה מהשרת, נקבל גם לינקים המיוחסים למשתמש כמו שמירה (user/) או עריכה (user/1).

נכון ש-REST היא הפופולארית ביותר, אבל האם אפשר לקרוא לכל סרביס שמגדיר את העצמו כ-RESTful, זה מעט שנוי במחלוקת. הרבה מאוד APIs לא באמת יכולים לסמן וי על *כל* החוקים (למשל, הרבה לא עובדים במדויק לפי HATEOS), אבל עדיין יכולים לתקשר אחד עם השני תחת הסטנדרט של פרוטוקול ה-HTTP. בנוסף, פרוטוקולים חדשים כמו GRPC מתחילים להתעורר ולהתחיל לתפוס תאוצה, כך שאולי נראה גישות חדשות ומודרניות יותר לבנות מערכות שמתקשרות דרך האינטרנט.
