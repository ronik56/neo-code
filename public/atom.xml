<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="he"><title type="text">NeoCode</title><subtitle type="html">קהילה חדשה ומודרנית המנסה לעשות סדר בעולם הפיתוח, ובמיוחד איך לכתוב קוד.</subtitle><updated>2020-11-02T12:23:59+02:00</updated><id>https://neocode.blog/</id><link rel="alternate" type="text/html" href="https://neocode.blog/"/><link rel="self" type="application/atom+xml" href="https://neocode.blog/atom.xml"/><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><generator uri="https://gohugo.io/" version="0.74.3">Hugo</generator><entry><title type="text">למה משתמשים בהקסדצימל?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/hex/"/><id>https://neocode.blog/posts/hex/</id><updated>2020-11-02T12:10:40+02:00</updated><published>2020-10-24T12:43:26+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">השפה שהמכונה אליה אנחנו מדברים מדברת בבינארי כמובן, כלומר אם למכונה היה ילדון שהיא רצתה ללמד לספור עד עשר, היא לא תוכל להשתמש ב10 ספרות (אצבעות) כמונו. היא תיאלץ להשתמש בשתי ספרות: 0 ו-1. אנחנו בני האדם סופרים בבסיס של 10 ספרות, ואילו מחשבים בבסיס של 2 ספרות.</summary><content type="html">&lt;p>השפה שהמכונה אליה אנחנו מדברים מדברת בבינארי כמובן, כלומר אם למכונה היה ילדון שהיא רצתה ללמד לספור עד עשר, היא לא תוכל להשתמש ב10 ספרות (אצבעות) כמונו. היא תיאלץ להשתמש בשתי ספרות: 0 ו-1. אנחנו בני האדם סופרים בבסיס של 10 ספרות, ואילו מחשבים בבסיס של 2 ספרות. הקסדצימל אומר אחרת: נספור ב16 ספרות! ומאיפה נביא את האקסטרה 6 ספרות? מהאותיות בשפה האנגלית A-F.&lt;/p>
&lt;p>הסיבה למה נבחרו האותיות F-A מרגיש אינטואיטיבי- כי הוא אכן אינטואיטיבי. אנחנו מכירים את הסדר של האותיות מה-&amp;lsquo;קטן&amp;rsquo; ל&amp;rsquo;גדול&amp;rsquo;, וזאת בדיוק הסיבה שאינטואיטיבי לבחור באותיות. וזאת גם אחת הסיבות לכך שאנחנו אינטואיטיבית נהיה מוגבלים בכמות הספרות שאיתן נוכל לספור- לאחר ה Z-A האנגלית, נוכל להמשיך להוסיף רק ספרות כמו $,%,# וכל&amp;rsquo;. מי יודע מי הספרה הכי קטנה?&lt;/p>
&lt;p>הסיבה למה לבחור בבסיס 16 באה מתוך הרצון לכווץ את האורך של רפרזנטציה של מידע כלשהוא בתצורה של בינארי. רפרזנטציה של טקסט בבינארי הופך לגוש ענק של 0 ו-1ים, כשייצוג בסיסי של אות (כמו אותיות) יהיה בארוך של 8 ספרות של 0 ו-1. N אותיות יתורגמו ל-N בחזקת 8 תווים של 0 ו-1ים.&lt;/p>
&lt;p>מכיוון שייצוג טריוויאלי של אות הינה byte אחד או 8 ביטים, אנחנו יכולים לייצג אות בעזרת 2 ספרות בלבד בהקס ע&amp;quot;י כך שכל ספרה בהקס מיוצגת ע&amp;quot;י 4 תאים עם שתי אפשרויות, 0 או 1. מכיוון שלכל תא יש שתי אפשרויות, אז סכום האפשרויות הוא 4^2, שזה בדיוק 16 הספרות שיש לנו בהקס. 0000 יהיה 0, 1111 יהיה F.&lt;/p>
&lt;p>התרגום מבינארי להקס וההפך הוא מאוד נוח. מחלקים רפרזנטציה בבינארי לקבוצות של 4. (הקונבנציה היא להתחיל מימין לשמאל. אם יש מספר אי זוגי קטן מ-4, משלימים אפסים לימין) ומתרגמים כל קבוצה של 4 לרפרזנטציה שלה ב-hex. בשביל לתרגם ההפך, פשוט לוקחים ספרה ספרה בהקס, וממירים למקבץ של 4 הספרות בבינארי. למשל: 0001-0001 מתורגם ל-11. החלוקה ל-4 דומה לחלוקה שאנחנו עושים עם ספירה רגילה, כשאנחנו מחלקים מספרים ל-3 (100,000,000).
באופן כללי כל בסיס שמתחלק ב-2 יהיה לנו נוח לספירה בגלל שבינארי הוא מטבעו 2 אפשרויות. 16 נלקח כבסיס הפופולארי בעיקר מתאמי נוחות והקלילות שלו לייחס מידע מביטים\בייטים.&lt;/p>
&lt;p>אחרי שכיווצנו את המידע שמועבר (בין מכונות למשל) להקסדצימל- אפשר לשאול את עצמינו, איך נבדיל אם המכונה שלחה לנו מידע בתצורה של הקס? המספר &amp;lsquo;11&amp;rsquo; אומר שני דברים שונים בבינארי והקס. הפתרון לכך הוא להצמיד בהתחלה סימן שמצהיר שמה שנשלח הוא מידע בתצורה של הקס. דוגמאות לכך הן &amp;lsquo;0x&amp;rsquo; שמופיעה הרבה במערכות מבוססות unix, וכמובן בצבעים- כאשר מתחילים עם האשטאג &amp;lsquo;#&amp;rsquo; ואחריו 3 זוגות של תווים כשל כל זוג מסמל 0-255 אפשרויות לאדום, כחול וירוק.
בתמונה: איך להעביר &amp;lsquo;מספר רגיל&amp;rsquo; מהקסדצימל לדצימל.&lt;/p></content></entry><entry><title type="text">מה הן פונקציות אנונימיות ואיך הן השתלטו לנו על החיים?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/annonymous-functions/"/><id>https://neocode.blog/posts/annonymous-functions/</id><updated>2020-11-02T12:10:40+02:00</updated><published>2020-10-18T04:43:26+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">פונקציה אנונימית טיפוסית נראית בסגנון של x+1 &amp;lt;= (x) ומציינת פונקציה שמקבלת ערך כלשהוא, מוסיפה לו 1, ומחזירה אותו. בסינטקס הזה אין לה שם, ואנחנו מוותרים על המילים return, function וברוב השפות גם על הטייפים של המשתנים. אנחנו בעצם מפשיטים פונקציה עד שמגיעים אל לוגיקה זריזה וקטנה, שאפשר לכתוב מהר עם מינימום חזרה על קוד וסינטקס ככל הניתן (מי יודע, אולי נוותר בעתיד גם על הסוגריים).</summary><content type="html">&lt;p>פונקציה אנונימית טיפוסית נראית בסגנון של x+1 &amp;lt;= (x) ומציינת פונקציה שמקבלת ערך כלשהוא, מוסיפה לו 1, ומחזירה אותו. בסינטקס הזה אין לה שם, ואנחנו מוותרים על המילים return, function וברוב השפות גם על הטייפים של המשתנים. אנחנו בעצם מפשיטים פונקציה עד שמגיעים אל לוגיקה זריזה וקטנה, שאפשר לכתוב מהר עם מינימום חזרה על קוד וסינטקס ככל הניתן (מי יודע, אולי נוותר בעתיד גם על הסוגריים).&lt;/p>
&lt;p>פונקציות אנונימיות צריכות לקבל הרבה יותר קרדיט על השינוי שהן &amp;ldquo;אפשרו&amp;rdquo; בעולם התכנות הפרגמטי. הרבה שפות החלו להביע תמיכה בפונקציות first class citizen, שמשמעותן: לקבל את אותן זכויות של תכונות ואובייקטים אחרים. הכוונה היא שפונקציות יכולות להישלח כפרמטרים, לשמור אותן במבני נתונים, ולשמור אותם כמשתנים- ממש כמו כל תכונה של אובייקט. ופונקציות אנונימיות הפכו את זה לכל כך הרבה יותר קל.&lt;/p>
&lt;p>הרעיון של פונקציות כאזרח לכל דבר היה הרבה פחות נפוץ, לפחות גישתי, אצל רוב המפתחים בשפות הסטטיות. בד&amp;quot;כ פונקציות היו נתפסות כpublic void doThis() , ואפשר לשחק עם לקרוא להן עם כל מיני encapsulation מגניבים ולרווח בין השורות כשקוראים להן.&lt;/p>
&lt;p>במקרה הזה, החתימות של הפונקציות (השם שלהן, מה הן מחזירות וכל&amp;rsquo;) הן גם בדר&amp;quot;כ ארוכות וחוזרות על עצמן. קוד של פונקציה פופולארית למציאה או סינון איבר, יכולה להגיע ל-2-5 שורות בכיף רב ולחזור על הפעולה חלילה עשרות ומאות פעמים.&lt;/p>
&lt;p>היום הגישה קצת שונה: פונקציות הן לא אזרח סוג ב&amp;rsquo;, אלא מרכיב הכרחי ושווה ערך (first citizen) בחופש שלנו להנדס קוד מדויק ויעיל. הן החלק הכי קריטי בקוד, וצריך את היכולת לנוע איתן בחופשיות כמו אובייקטים. כל העסק התחיל לתפוס תאוצה, כשפונקציות אנונימיות החלו להתפשט בקוד.&lt;/p>
&lt;p>בשפות תכנות שתומכות בfirst citizen function, אנחנו יכולים לשחק עם פונקציות כמו עם לגו. אנחנו יכולים לשמור אותם בדיוק כמו שאנחנו שומרים אובייקטים- כמשתנה, או ברשימה או מילון. עם פונקציות אנונימיות קל ונוח להעביר אותם כפרמטרים בפונקציות, בדיוק כמו הפונקציות הפופולאריות כיום, map &amp;amp; filterהמקבלות פונקציה ורשימה כפרמטרים, ומפעילות את הפונקציה על כל אחד מהאיברים ברשימה (ובסוף מחזירים את הרשימה החדשה). כך, אנחנו יכולים לכתוב שרשור של פונקציות בשורה או שתיים, ולחסוך 10 שורות. הפונקציות הנ&amp;quot;ל נקראות גם high order functions, כלומר פונקציות המקבלות פונקציה כפרמטר או מחזירות פונקציה. במקרה שלנו, הן מקבלות פונקציה המופעלת על כל איבר ברשימה.&lt;/p>
&lt;p>הגישה שהתכנות, לפחות כרגע, מנסה לסחוף אחריה היא להעדיף לשחק עם פונקציות מאשר לערוך ולהעביר אובייקטים. להעדיף להשתמש במקבצי לוגיקה קטנים, על פני ניסוח של פונקציות. ככה הרבה פחות שורות נכתבות, והרבה פחות חזרה על סינטקס מוכר. אפשר לומר שפשוט הרבה יותר קל ומהר לכתוב קוד ולתכנן לוגיקה.&lt;/p></content></entry><entry><title type="text">דרכים לנהל שגיאות ואקספשנס</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/exceptions/"/><id>https://neocode.blog/posts/exceptions/</id><updated>2020-11-02T12:10:40+02:00</updated><published>2020-10-12T05:43:26+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">בעולם אוטופי, כל פונקציה שנקרא לה תניב לנו את המידע שאנחנו צריכים, ולא תעצור את הflow של הקוד. אבל אנחנו לא בעולם אוטופי, וכל פונקציה שנקרא לה טומנת בתוכה את הפוטנציאל להשתבש ולחשב לנו את המסלול מחדש. והאמת היא, שלהקריס תוכנה זה כנראה יותר קל מלקחת סוכריה מתינוק, אז מן הראוי שerror &amp;amp; exception handling תהיה המומחיות הכי קריטית בלשמור על התוכנה&amp;hellip;עובדת.</summary><content type="html">&lt;p>בעולם אוטופי, כל פונקציה שנקרא לה תניב לנו את המידע שאנחנו צריכים, ולא תעצור את הflow של הקוד. אבל אנחנו לא בעולם אוטופי, וכל פונקציה שנקרא לה טומנת בתוכה את הפוטנציאל להשתבש ולחשב לנו את המסלול מחדש. והאמת היא, שלהקריס תוכנה זה כנראה יותר קל מלקחת סוכריה מתינוק, אז מן הראוי שerror &amp;amp; exception handling תהיה המומחיות הכי קריטית בלשמור על התוכנה&amp;hellip;עובדת. או במילים אחרות: רובוסטית, אנטי-שבירה, כזאת שבנויה להתמודד עם הלא רצוי ולא מצופה.
איך כדאי לנו להתמודד עם תקלות בלתי צפויות בקוד? הדמיון הוא כמובן אינסופי, אבל יש מספר טכניקות פופולאריות שמשתמשים בהן: לזרוק שגיאה, להחזיר null, להחזיר אובייקט ריק או monad.&lt;/p>
&lt;p>לזרוק שגיאה ירגיש מאוד טבעי עם פונקציות IO שיכולות להתפוצץ, כמו שגיאה בחיבור למסד נתונים או באי מציאת קובץ. אנחנו נוכל גם לזרוק שגיאות תפורות אישית לבעיות מסוימות, וככה נוכל לאבחן את התקלות בקלות רבה ולהכין backup plans לכל שגיאה (כלומר, לרשת מה- Exception, לממש ולהחזיר שגיאות משלנו). לזרוק שגיאה מתאים למקרים בהם אנחנו רוצים ללכת בגישה של easier to ask forgiveness than permission, כלומר אנחנו נקרא לפעולה ונתפלל שהיא תעבוד. אם לא, אוקיי סליחה, ננסה משהוא אחר. שוב, פעולה של IO היא הדוגמה הכי אלגנטית למקרה כזה כי היא יכולה להיות בקלות פצצה מתקתקת.
בג&amp;rsquo;אווה יש לנו checked exception שמכריח אותנו להתמודד עם כל פונקציה שעלולה לזרוק שגיאה. בזמן שזה נחמד בתיאוריה, הכפייה להתמודד תמיד עם שגיאה היא לא בהכרח הכרחית או רצויה, שכן יש מקרים בהם פשוט לא נרצה להתמודד עם השגיאה.&lt;/p>
&lt;p>בנוסף ללזרוק שגיאה, אנחנו יכולים להחזיר null, שמתאים לגישה של look before you leap, דהיינו תמיד לבדוק את מה שאנחנו מקבלים. הגישה מתאימה למקרים בהם null הוא פלט לגיטימי, כמו למשל כשאובייקט (שורה) לא נמצא בדטאבייס. אין הכרח לפוצץ את הפעולה, מכיוון שהפעולה הסתיימה בהצלחה ולא כשלה בגלל עצמה, אלא מכוח חיצוני לה (למרות שכן ניתן להטיל ספק במקרים בהם אי מציאה של אובייקט נחשב לכשל לוגי).
להחזיר null עוזר לנו לצמצם קוד שמכיל הרבה trycatch, אבל בתמורה נצטרך לתחזק קוד עמוס ב != null, והכלל מספר אחד בקוד הוא: כל תחזוקה שוטפת עלולה להוביל לטעויות. מתכנת עלול לשכוח, או כמובן לא לדעת- שהפונקציה עלולה להחזיר null, ומלאך המוות יקפוץ לביקור.&lt;/p>
&lt;p>מקרים בהם לא מתאים לזרוק null, הם מקרים בהם אנחנו נרצה להחזיר אובייקט ריק. הדוגמה המושלמת לכך היא בהחזרת רשימה. רשימה ריקה היא ערך לגיטימי לחלוטין, ובמקרים נדירים בלבד נרצה להתמודד או לבדוק אם הרשימה היא null. יכול להיות שזה המקרה היחידי שמצדיק להחזיר אובייקט ריק, מכיוון שלהחזיר אובייקט ריק עלול להוביל לבאגים מסתוריים של מחסור בערכים באובייקטים מסוימים (זה יכול להתחיל שרשרת), ואנחנו נצטרך לחפש בדיוק איזו פונקציה מסתורית גרמה לכל הבלגן הזה.&lt;/p>
&lt;p>אופציה פופולארית נוספת, היא שימוש ברעיון של monad&lt;T>, שברמה הבסיסית שלו הוא מעטפת אבסטרקטית וגנרית המכילה בתוכה את האובייקט שאנחנו רוצים להחזיר, ויחד עם זה עוד מידע כמו השגיאה עצמה, הודעת שגיאה וכדומה. היתרון מספר אחד של מונאד הינו שהוא מגדיר סינטקס אחיד וברור, והוא שכל פונקציה מחזירה את המונאד, ובתוכה את האובייקט הרצוי כמו חבילה מאלי אקספרס. וכמובן, הוא עוזר למנוע nullpointexceptions לא מתוכננים כי המונאד אף פעם לא צריך להיות null. דוגמאות לכך הן ה-Maybe שקיים בתכנות פונקציונאלי וכמובן ב-reactive programming, וה- IO Monad שבהאסקל, שהם מתפקדים כ-קצת יותר ממעטפת אבסטרקטית.&lt;/p>
&lt;p>אנלוגיה נחמדה למתי נרצה להשתמש במונאד על פני לזרוק שגיאה, היא אם נרצה לחפש פריט בתוך קופסא מסוימת. אם לא נמצא את הפריט בקופסא- נרצה להשתמש במונאד (או נחזיר null). אם לא נמצא בכלל את הקופסא- נרצה לזרוק שגיאה. במקרה הראשון אנו &amp;lsquo;מצפים&amp;rsquo; במידה מסוימת שיהיה פריט או לא, אבל במקרה השני אנחנו לא מצפים שלא נמצא את הקופסא.&lt;/p>
&lt;p>יכול להיות שכל הדרכים לגיטימיות בדרכים שלהן, עם קצת יתרונות אחד על פני השני. אפשר לטעון שאין צורך להחזיר null כל עוד משתמשים במונאד, אבל גם אפשר להשתמש תמיד ב-trycatch בלבד. בסופו של יום אנחנו רואים שלכל אחד אכן יש חוזקות משלו בהתאם לסיטואציה. לא כדאי להגדיר חוק אחיד של איך להתמודד עם שגיאות שקורות, אלא לתפור לכל בעיה את הדרך שלה להתמודד עם שגיאות. ככה נוכל להנות (כמעט) מכל העולמות ולהתמודד עם מינימום השלכות וחסרונות. but exceptions… exceptions never changes.&lt;/p></content></entry><entry><title type="text">איך דיסקים קשיחים עובדים?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/hdd/"/><id>https://neocode.blog/posts/hdd/</id><updated>2020-10-08T09:53:09+03:00</updated><published>2020-10-08T06:28:09+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">מהדיסק הקשיח הראשון שפותח אי שם ב-1956 על ידי IBM והחזיק בשטח אחסון של 5MB ועד הקשיחים המודרניים שמחזיקים עשרות טרהבייטים (Terabytes) של מידע עברנו דרך ארוכה. אבל איך בדיוק אנחנו מאחסנים כל כך הרבה מידע על חתיכת מתכת בגודל של 3.5 אינץ&amp;rsquo; (קצת פחות מ-9 ס&amp;quot;מ)?</summary><content type="html">&lt;p>מהדיסק הקשיח הראשון שפותח אי שם ב-1956 על ידי IBM והחזיק בשטח אחסון של 5MB ועד הקשיחים המודרניים שמחזיקים עשרות טרהבייטים (Terabytes) של מידע עברנו דרך ארוכה. אבל איך בדיוק אנחנו מאחסנים כל כך הרבה מידע על חתיכת מתכת בגודל של 3.5 אינץ&amp;rsquo; (קצת פחות מ-9 ס&amp;quot;מ)?&lt;/p>
&lt;p>כולנו יודעים מה זה מגנט, ובערך איך הוא עובד. קובץ קטן מאיתנו אולי גם גילה שאם נשפשף קצת את המגנט על מתכת כלשהי, כמו מסמר, אנחנו &amp;ldquo;הופכים&amp;rdquo; את המסמר למגנט, מה שנקרא מגנוט (Magnetization). באותה המידה שאפשר למגנט את המסמר, אפשר גם לבטל את התכונות המגנטיות שלו, כלומר להחזיר אותו למצב בו הוא לא מגנט (Demagnetization). מגנטיות זו תכונה שאפשר לתת למסמר, תכונה בעלת שני ערכים בלבד- ממוגנט, לא ממוגנט. כן, לא- 1, 0.&lt;/p>
&lt;p>באותה הצורה בדיוק עובד דיסק קשיח, על ידי מגנוט (או ביטול שדה מגנטי) של מתכת. בדיסק הקשיח שלנו אין מסמרים כמובן, במקום זה יש לדיסק קשיח דיסקה שטוחה (platter), לרוב מאלומיניום או זכוכית או חומר קרמי דומה מצופה שכבה מתכתית משני הצדדים. הדיסקה מחולקת כיום למיליארדי איזורים קטנטנים שאפשר למגנט או לבטל את המגנוט שלהם. התכונה המגנטית נשמרת עד שמשנים אותה ידנית ולכן הקשיח שומר את המידע גם כאשר המחשב מכובה. דיסקים קשיחים יכולים לכלול בין 1 ל-5 דיסקות. מספר הדיסקות תלוי במחיר (קשיחים זולים יותר יחסכו עלויות עם דיסקה אחת) ובנפח הדרוש.&lt;/p>
&lt;p>לכל דיסקה יש 2 ראשי קריאה/כתיבה שמחוברים לבקר אלקטרוני והם זזים פנימה והחוצה (כלומר לכיוון מרכז הדיסקה או לכיוון הקצה שלה) בזמן שהדיסקה מסתובבת. רוב הקשיחים מסתובבים בקצב של 5400 או 7200 סל&amp;quot;ד. כדי למנוע שחיקה יש שכבה של אוויר או נוזל כך שהראשים לא נוגעים בדיסקה.&lt;/p>
&lt;p>כמו שאמרנו, הקשיח שומר מידע ביחידות של 0 ו-1, כלומר ביטים (bit), בהתאם למגנטיות של הנקודה. בקשיח סטנדרטי של 1TB זה אומר שיהיו לנו 8,000,000,000,000 נקודות (8x10^12) עם הערך 0 ו-1 שיוצרות המון קבצים שונים. אם לשנות אפילו ביט אחד אנחנו יכול להרוס קובץ ולהפוך אותו לבלתי שמיש. אז איך המחשב יכול למצוא ביט אקראי אחד מתוך מיליארדים?&lt;/p>
&lt;p>הקשיח שומר את המידע באופן נורא מסודר. כל המידע מסודר במסלולים מעגליים (tracks). כל מסלול מחולק למקטעים (sectors) שכל אחד מהם מכיל מספר בייטים (bytes) שנע בין 512 ל-4096 . איזור יעודי בקשיח שומר מעיין מפה של איזה סקטורים תפוסים ואיזה לא וככה מערכת ההפעלה יודעת לאן להפנות את ראש הקריאה/כתיבה כדי לכתוב את הקובץ. קריאת מידע עובדת באותו האופן בכיוון ההפוך. המחשב שולט על הראש באמצעות בקר (controller) שנמצא על הקשיח.&lt;/p>
&lt;p>היתרונות הכי בולטים של דיסקים קשיחים הם אמינות- הם מחזיקים המון זמן ויכולים לעמוד בכמויות עצומות של קריאה וכתיבה, מחיר זול ויכולת לאחסן כמויות גדולות של מידע.&lt;/p>
&lt;p>החסרונות שלהם הם מהירות, רעש וצריכת חשמל. בזמן שקשיחים מגיעים למקסימום של 150-200MB/s בקריאה וכתיבה לדגמים היוקרתיים (ולרוב בין 100 ל-150), דגמי ה-SSD (האלטרנטיבה לקשיחים, פוסט עליהם יגיע בקרוב) הכי פשוטים נמצאים באיזור ה-300-400MB/s ומגיעים עד מהירויות של 3000-3500MB/s (ואפילו 5000MB/s עם ההשקה של כונני PCIe 4.0) לצרכן הביתי. ההבדל בשימוש השוטף הוא משמעותי- המחשב עולה תוך מספר שניות במקום 3-4 דקות ואפשר להשתמש בו באופן מיידי ולא לחכות כמה דקות עד שאפשר יהיה להפעיל את הדפדפן בלי שהכל יהיה תקוע ואיטי. מעבר לזה קשיחים רועשים יותר מאחר ויש פעולות מכניות של סיבוב, צורכים יותר חשמל (5-6 וואט לעומת 2-3 וואט, מתבטא בכמה שקלים בשנה לכל היותר) וגם כבדים בהרבה בגלל הדיסקות.&lt;/p></content><category scheme="https://neocode.blog/categories/%D7%97%D7%95%D7%9E%D7%A8%D7%94/" term="חומרה" label="חומרה"/><category scheme="https://neocode.blog/tags/%D7%93%D7%99%D7%A1%D7%A7-%D7%A7%D7%A9%D7%99%D7%97/" term="דיסק קשיח" label="דיסק קשיח"/><category scheme="https://neocode.blog/tags/%D7%97%D7%95%D7%9E%D7%A8%D7%94/" term="חומרה" label="חומרה"/><category scheme="https://neocode.blog/tags/hdd/" term="HDD" label="HDD"/></entry><entry><title type="text">איך טורנטים עובדים?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/torrents/"/><id>https://neocode.blog/posts/torrents/</id><updated>2020-10-08T09:30:15+03:00</updated><published>2020-09-29T04:30:41+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">פרוטקול ה-BitTorrent הוא אחד הפרוטוקולים הכי מוצלחים ונפוצים בכל מה שקשור לשיתוף קבצים. הוא מאפשר הורדות מהירות באופן מבוזר (decenteralized) וגם נוטל חלק בלא מעט סקנדלים סביב זכויות יוצרים. אבל איך הוא עובד?
החלק הכי משמעותי ב-BitTorrent הוא שמדובר ברשת מחשבים מבוזרת, כלומר בלי שרת מרכזי.</summary><content type="html">&lt;p>פרוטקול ה-BitTorrent הוא אחד הפרוטוקולים הכי מוצלחים ונפוצים בכל מה שקשור לשיתוף קבצים. הוא מאפשר הורדות מהירות באופן מבוזר (decenteralized) וגם נוטל חלק בלא מעט סקנדלים סביב זכויות יוצרים. אבל איך הוא עובד?&lt;/p>
&lt;p>החלק הכי משמעותי ב-BitTorrent הוא שמדובר ברשת מחשבים מבוזרת, כלומר בלי שרת מרכזי. בהורדה &amp;ldquo;רגילה&amp;rdquo; מהאינטרנט אנחנו ניגשים לשרת מרכזי כשלהו ששומר את הקובץ אליו והוא שולח לנו אותו בשלמותו. לנו, ולכל אדם אחר שרוצה להוריד אותו. מעבר לצורך בתחזוקת שרת, דבר לא זול, עומס פתאומי יכול להוביל לקריסה והרבה יותר קשה להתמודד איתו. טורנטים לעומת זאת מבוססים על P2P- Peer-to-Peer. רשת של מחשבים שמתקשרים ישירות אחד עם השני בלי שרת מרכזי. כל מחשב ברשת נקרא עמית (peer).&lt;/p>
&lt;p>תחילה מישהו יוצר את הטורנט, לדוגמה עבור קובץ וידיאו. כל הפרטים הנחוצים נכנסים לקובץ torrent, קובץ קטן, לרוב באיזור כמה עשרות קילובייטים. הקובץ אותו הוא משתף (הוידיאו) מתחלק למספר חלקים שווים שנעים בין 32KB ל-16MB. לכל חלק ניתן hash שנוצר עם אלגוריתם SHA-1, מעיין קוד אימות, שנועד לוודא שהקובץ תקין ואין מידע פגום. המידע הזה נשמר במקור בקובץ ה-torrent. לכן ככל שהחלקים גדולים יותר כך גודל קובץ הטורנט קטן יותר, מאחר ויהיו פחות hash. כאשר מישהו מוריד חלק, ה-hash שלן מושווה ל-hash שנמצא בקובץ הטורנט לוודא שהוא אכן תקין. כאשר מישהו סיים את ההורדה במלואה ועכשיו רק משתף, הוא נקרא סידר – Seeder.&lt;/p>
&lt;p>כל מחשב שמעוניין להוריד את הקובץ מתקשר עם כל שאר המחשבים שרוצים להוריד את הקובץ וכולם מורידים אחד מהשני את הקובץ. בהתחלה, כאשר יש רק בן אדם אחד עם הקובץ שמעלה אותו, כולם יאלצו להתחבר אליו. כשהם הורידו את הקובץ במלואו, הם יהפכו לסידרים ויתחילו לשתף (לרוב עמיתים ברשת משתפים חלקים שהם כבר הורידו ברגע שהם הורידו אותם ולא מחכים לסיום ההורדה). ככל שיותר אנשים יורידו את הקובץ, יהיו יותר אנשים שמעלים את הקובץ והרשת תגדל. למעשה, ככל שיותר אנשים מורידים את הקובץ ככה הוא יותר עמיד בפני עומסים כבדים. כל אחד מוריד חלקים שונים מסידרים שונים וכך מאפשר לשפר את מהירות ההורדה.&lt;/p>
&lt;p>כשכל החלקים סיימו לרדת הקליינט (התוכנה שאנו משתמשים בה) מחבר אותם לקובץ אחד וסיימנו את ההורדה.&lt;/p>
&lt;p>למעשה כאשר הטורנט &amp;ldquo;תופס תאוצה&amp;rdquo; ויש מספיק משתמשים נוצרת רשת סבוכה עם המון קשרים שנקראת swarm (נחיל). כל עמית מוריד מהמון עמיתים אחרים, במקביל. עמית אחד יכול להוריד מאות חלקים שונים של אותו הקובץ ממאות עמיתים, שכל אחד מהם גם מוריד מאות חלקים שונים ממאות עמיתים שונים.&lt;/p>
&lt;p>בתחילת הפרוטוקול לא היה מנוס מלהשתמש בקובץ ה-torrent. הקובץ כלל, מעבר ל-hash של החתיכות, רשימת טראקרים. טראקר היה שרת שכלל בתוכו טבלה של כל החברים ברשת ה-P2P, כלומר כל מי שמוריד/מעלה את הטורנט. את הרשימה הזו העביר לקליינט שלנו וכך הקליינט ידע למי אפשר להתחבר בכדי להוריד את הטורנט. הבעיה היא שעדיין מדובר ברשת שהיא תלויה בשרת מרכזי כלשהו ולא מבוזרת לחלוטין, גם אם מדובר רק בהורדה של רשימת טקסט.&lt;/p>
&lt;p>לכן פותח פרוטוקול ה-DHT (או Distributed Hash Table) שמאפשר לנו להוריד טורנטים בלי טראקרים והופך את הרשת למבוזרת כמעט לחלוטין. DHT הופך למעשה כל קליינט לטראקר בפני עצמו. באמצעות הפרוטוקול אפשר לפתוח לינקים מיוחדים, שנקראים magnet וכך אנחנו הופכים לצומת DHT (או DHT node)*. אנחנו מחפשים את הצמתים הקרובות ומהן משיגים מידע נוסף- צמתים נוספות. ככה אנחנו עוברים על רשת ענקית של צמתים שמספקות לנו כתובות hash נחוצות לפרוטקול, בנוסף לרשימת כתובות להורדה בלי צורך בטראקר, דהיינו שרת מרכזי.
*אם המונח צומת לא מובן לכם, אז אפשר להסתכל על ה-magnet כקישור שנותן לנו מספר כתובות שמהן אפשר להוריד עוד כתובות וכן הלאה, כשכל כתובת היא שותף שאפשר להוריד ממנו את הקובץ.&lt;/p>
&lt;p>את הטורנטים מוצאים לרוב באתרים שנקראים אינדקסים שכוללים רשימה של טורנטים ואת הקובץ או ה-magnet המתאים.&lt;/p>
&lt;p>בגלל המבנה של הטורנטים יש להם יתרונות יחודיים ועוצמתיים. קודם כל, מאחר וכל קובץ נשמר בכמות עצומה של עותקים, יש לנו redundancy עצום. בשפה פשוטה יש המון גיבויים והסיכוי של הקובץ להיאבד עקב תקלה בשרת (לדוגמה דיסק קשיח תקול) נמחק. מעבר לזה, מאחר וההורדה כוללת המון חלקים קטנים שלא תלויים באחרים, אפשר לעצור בכל שלב את ההורדה ולהמשיך אחר כך, בלי לאבד מידע, משהו שלא כל כך אפשרי בהורדה רגילה.&lt;/p>
&lt;p>לטורנטים יש גם חסרונות. הראשון הוא הפרטיות/אנונימיות. למרות שמדובר בכלי מאוד שימושי ופופולרי בהורדות פיראטיות (בין היתר בגלל כמות העותקים העצומה של הטורנטים שמפוזרת על פני יבשות), כל כתובות ה-IP חשופות לכולם. בכל קליינט אפשר לראות את רשימת השותפים שלנו עם כתובות IP מדויקות. זה גם מאפשר לגופי זכויות יוצרים לאסוף רשימה של כתובות IP ולשלוח אותן לספקיות בדרישה להורדת התוכן. במקומות מסוימים הם גם יכולים לתבוע את המשתמשים (אל תדאגו, זה בעיקר בארה&amp;quot;ב, לא בישראל). הפתרונות יכולים להיות קליינטים דוגמת Tribler שמספק רשת דמוית Tor ואנונימיות או פרטוקול I2P. גם VPN (שדיברנו עליו בפוסט הזה: &lt;a href="https://neocode.blog/posts/vpn/">https://neocode.blog/posts/vpn/&lt;/a>) מאפשר לספק אנונימיות בהורדת טורנטים. פתרון נוסף יהיה טראקרים פרטיים, אבל בהם ניגע עוד רגע.&lt;/p>
&lt;p>החסרון השני של טורנטים הוא מה שנקרא leechers, או עלוקות. משתמשים שמורידים את הקובץ וברגע שהם סיימו להוריד הם מכבים את הטורנט במקום להיות סידרים ולמעשה לא תורמים בחזרה לרשת, מה שפוגע במהירות ההורדה של כולם וגם מעלה את הסיכוי שהטורנט ימות כי אין מספיק אנשים שמעלים אותו.&lt;/p>
&lt;p>את הבעיה הזו וגם את הבעיה של האנונימיות פותרים טראקרים פרטיים. טראקר פרטי הוא טראקר וגם אינדקס שדורש הזמנה ו/או הרשמה. הם לא פתוחים לציבור ושולטים ברשימת המשתמשים שלהם ובכך נוצרת קהילה מבוקרת יותר ונשלטת. היתרון של רשימה כזו הוא מן הסתם היכולת להרחיק רשויות חוק, אבל מעבר לכך הוא מאפשר לעשות בקרת איכות למשתמשים. בטראקרים פרטיים משתמשים מחויבים לשמור על ratio, יחס העלאה הורדה מסוים כדי לוודא שאין leechers ושכולם תורמים ומחזירים. משתמשים רבים גם רוכשים seedbox, שרת יעודי עם רוחב פס גבוה (לרוב 1 גיגהביט העלאה) ושטח אחסון גבוה שיוכל לעשות סידינג לטורנטים 24/7 במהירויות גבוהות ולאפשר להם לבנות ratio טוב שיאפשר להם להוריד קבצים נוספים בלי להיחסם, ובכך הם מאפשרים להוריד כל טורנט מהטראקרים הפרטיים במהירות שיא, גם שנים אחרי שהועלה.&lt;/p>
&lt;p>לקבל הזמנה לטראקר פרטי זה לא הכי קל וצריכים למצוא מישהו שיכול לתת (רוב המשתמשים מקבלים מספר מסוימת של הזמנות, בעיקר כצ’ופר על סידינג ורטיו טוב) או להירשם בחלונות שבהם ההרשמה נפתחת לציבור הרחב.&lt;/p></content><category scheme="https://neocode.blog/categories/%D7%9B%D7%9C%D7%9C%D7%99/" term="כללי" label="כללי"/><category scheme="https://neocode.blog/tags/%D7%9B%D7%9C%D7%9C%D7%99/" term="כללי" label="כללי"/></entry><entry><title type="text">מה זה pure function, ומה ה’חסרון’ הכי גדול של זה?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/pure-function/"/><id>https://neocode.blog/posts/pure-function/</id><updated>2020-09-22T08:51:59+03:00</updated><published>2020-09-22T08:49:57+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">מי שחובב תכנות פונקציונאלי (Functional Programming), מכיר את המושג pure function, שמשמעותו פונקציה המספקת את התנאים הבאים: א) תמיד להחזיר את אותו הפלט ביחס לקלטת שהיא מקבלת, ו- ב) לא להכיל שום side effect בתוך הפונקציה עצמה, כמו: שינוי משתנה מחוץ לסקופ שלה, Input/Output, או כל דבר אחר שלא קשור לפלט של הפונקציה.</summary><content type="html">&lt;p>מי שחובב תכנות פונקציונאלי (Functional Programming), מכיר את המושג pure function, שמשמעותו פונקציה המספקת את התנאים הבאים: א) תמיד להחזיר את אותו הפלט ביחס לקלטת שהיא מקבלת, ו- ב) לא להכיל שום side effect בתוך הפונקציה עצמה, כמו: שינוי משתנה מחוץ לסקופ שלה, Input/Output, או כל דבר אחר שלא קשור לפלט של הפונקציה.&lt;/p>
&lt;p>כלומר, הפונקציה צריכה להיות תלויה בקלט שהיא מקבלת בלבד, ולא להתערב בשום דבר שאינו בתוך הסקופ שלה, או שאינו חלק מה&amp;quot;עולם&amp;rdquo; שלה. זה אומר שאפילו לשנות אובייקט בתוך הסקופ שלה גורע ממנה את התואר.&lt;/p>
&lt;p>פונקציה PF היא אבן יסוד בפרדיגמה של תכנות פונקציונאלי, אשר שם דגש על כמה שפחות לשנות ולהשפיע על הערכים של אובייקטים קיימים (טכנית, הוא קשוח ומעודד שלא יהיה אפשר לשנות ערכים של אובייקטים לאחר שהם נוצרים, כלומר immutable). הדוגמאות הכי קלאסיות לתיאור פונקציות PF הן פונקציות מתמטיות, המסמנות וי בקלילות על שתי הדרישות. הן תלויות בקלט שהן מקבלות, וביחס אליו מחזירות את הפלט. לא קורה שום דבר אחר בין לבין.&lt;/p>
&lt;p>לפונקציה PF יש מספר יתרונות מאוד נעימים, וחסרון אחד מתסכל במיוחד. היתרון הראשון הוא שקל לבדוק פונקציה שכזאת. מכיוון שהפונקציה תמיד מחזירה את אותו הפלט ביחס לקלט, וגם היא אינה תלויה במידע שנמצא בערוצים אחרים כמו דטאבייס, יהיה קל יותר לבדוק אותה ולוודא שהיא מחזירה את התוצאה הנכונה.&lt;/p>
&lt;p>יתרון נוסף, הוא האפשרות לשרשר pure functions אחת עם השנייה. מכיוון שהלוגיקה והערכים שהן מחזירות הם &amp;lsquo;צפויים&amp;rsquo; (predictable), אפשר להרכיב פונקציות ללא חשש מהשלכות לא צפויות של פונקציה אחת על השנייה (כאן הסדר שלהן יכול להיות משנה).&lt;/p>
&lt;p>פונקציות PF גם נוחות יותר לתכנות מקבילי (parallel), מכיוון שאסור לפונקציות הללו לקרוא מכל מקור אחר או לכתוב לכל מקור אחר מלבד הקלט שלהן. הן לא ישפיעו על מידע שלעוד טרדים (Threads) אחרים יש גישה אליהם, מה שבעצם מונע race condition.&lt;/p>
&lt;p>אבל לפונקציה PF יש חסרון מאוד קריטי: היא לא יכולה לבצע IO! אחרת התואר נשלל ממנה. אם היא מקבלת אינפוט ממקור אחר (read), היא תלויה גם בערך שהיא קראה אותו, ועלולה להחזיר ערך שאינו תלוי בקלט. אם היא משנה משהוא בדטאבייס (write), היא משפיעה על מידע במקור אחר.&lt;/p>
&lt;p>מבלי כל ביצוע של IO, אנחנו לא נוכל לקרוא מידע מהדיסק, מהרשת, או לקבל קלט מהאינטראקציה של המשתמש.
איך פותרים את זה? ע&amp;quot;י&amp;hellip;לא, כרגע סוג של אי אפשר לפתור את זה.&lt;/p>
&lt;p>שפות תכנות פונקציונאליות כמו Haskell &amp;amp; Scala משתמשות ב- IO Monad, מעטפת אבסטרקטית ש&amp;rsquo;מאפשרת&amp;rsquo; לפונקציות שלהן גם להיות IO ע&amp;quot;י בוילר פלייט קוד שנכתב מאחורי הקלעים בשבילנו המתכנתים, אבל זה לא באמת פתרון.&lt;/p>
&lt;p>כך או כך, פונקציות PF ו- IO לא בדיוק יכולות להתקיים אחת לצד השניה. הפתרון האולי אלגנטי ביותר יהיה לכתוב את ה IO הרלוונטי עם הכלים שיש לנו, ואת שאר הקוד להמשיך לפי קווי היסוד של תכנות פונקציונאלי (למי שמעוניין כמובן).&lt;/p></content><category scheme="https://neocode.blog/categories/%D7%9B%D7%9C%D7%9C%D7%99/" term="כללי" label="כללי"/><category scheme="https://neocode.blog/tags/%D7%9B%D7%9C%D7%9C%D7%99/" term="כללי" label="כללי"/></entry><entry><title type="text">REST מה זה?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/rest/"/><id>https://neocode.blog/posts/rest/</id><updated>2020-09-17T17:00:58+03:00</updated><published>2020-09-17T10:43:26+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">קצת אחרי בועת הדוט קום, החלה מלחמת אופל בין SOAP ל- REST, שמטרתן הייתה לקבוע סטנדרט לבנייה ותקשורת בין &amp;ldquo;Web Services&amp;rdquo;, כלומר לקבוע איך בונים מערכות המתקשרות ביניהן דרך האינטרנט הגדול. בקרב הזה REST ניצח, לפחות לעת עתה.
את המושג REST, שנקרא Representational State Transfer טבע לראשונה רוי פילדינג, כמה שנים אחרי שמייקרוסופט שיחררה את הפרוטוקול שלה: SOAP.</summary><content type="html">&lt;p>קצת אחרי בועת הדוט קום, החלה מלחמת אופל בין SOAP ל- REST, שמטרתן הייתה לקבוע סטנדרט לבנייה ותקשורת בין &amp;ldquo;Web Services&amp;rdquo;, כלומר לקבוע איך בונים מערכות המתקשרות ביניהן דרך האינטרנט הגדול. בקרב הזה REST ניצח, לפחות לעת עתה.&lt;/p>
&lt;p>את המושג REST, שנקרא Representational State Transfer טבע לראשונה רוי פילדינג, כמה שנים אחרי שמייקרוסופט שיחררה את הפרוטוקול שלה: SOAP. עם השנים REST הפכה לגישה הדומיננטית ביותר לבניית Web Services, בעיקר בגלל ש REST הייתה פשוטה יותר, נוחה, והרבה יותר גמישה וסלחנית. למשל, לפי REST אפשר להעביר מידע בתצורות שונות כמו ג&amp;rsquo;ייסון, XML וכד&amp;rsquo;. ב SOAP, אפשר להעביר מידע רק בתצורת XML.&lt;/p>
&lt;p>קשה להשוואת בין SOAP ל REST, מכיוון שאי אפשר. REST היא ארכיטקטורה עם סט חוקים שצריך ליישם, ו-SOAP הוא פרוטוקול. אך עדיין סרביסים התפלגו לכאלה שנבנים תוך שימוש ב SOAP כפרוטוקול תקשורת, וכאלה שעומדים בתנאים של REST.&lt;/p>
&lt;p>הגישה של REST מכריחה כל מערכת שרוצה להיחשב כ &amp;lsquo;RESTful&amp;rsquo; לעמוד בתנאים הבאים:&lt;/p>
&lt;p>א) לחלק את המבנה לקליינט ושרת. הקליינט מציג את המידע, והשרת מעבד ושומר את המידע. שניהם צריכים להיות מופרדים ולא קשורים אחד לשני (או לדעת על קיום וזהותם אחד של השני).&lt;/p>
&lt;p>ב) Stateless - המערכת לא צריכה לנהל שום סטייט של אף קליינט. זה אומר שהקליינט צריך לספק לשרת מספיק מידע בקריאה בשביל שהשרת יוכל לזהות את הקליינט ולבצע את הפעולות שהקליינט דורש ממנו.&lt;/p>
&lt;p>ג) Caching- השרת יכול להחזיר לקליינט בקשה ולהצהיר לקליינט שהוא יכול לשמור את המידע שקיבל, ולהשתמש בו עד לפרק הזמן שהשרת ממליץ. כך הקליינט יכול לחסוך קריאה לשרת כשיש בידו את המידע העדכני. עוד דרך יכולה להיות בעזרת ETAG, כשמסמנים טוקן ייחודי לתשובה, והשרת והקליינט יכולים לוודא ביניהם אם המידע השתנה. אם המידע בשרת לא השתנה, הטוקן ETAG יהיה אותו טוקן מהתשובות הקודמות. אם הטוקן שונה- המידע השתנה ויש לבקש את המידע מחדש (עם טוקן חדש).&lt;/p>
&lt;p>ד) האפשרות להרכיב שכבות בין התקשורת- הקליינט ו\או השרת אינם חייבים לתקשר ביניהם ישירות. למשל אפשר להכניס middle man כמו פרוקסי שייתן עוד שכבת אבטחה או לוגיקה ביניהם. כל זה מבלי לשנות משהוא אצל השרת או הקליינט.&lt;/p>
&lt;p>ה) ממשק אחיד (Uniform Interface) לתקשורת בין סרביסים ולקליינט-שרת. הבקשה מהקליינט צריכה לציין את צורת המידע שהוא מעוניין להעביר ולקבל, ועליו להעביר מספיק מידע בשביל שהשרת יוכל לעבד את הבקשה ולשנות את המידע בדטאבייס.&lt;/p>
&lt;p>לדוגמה, הקליינט רוצה לשלוח מידע בתצורת ג&amp;rsquo;ייסון, ולשמור את המידע בשרת. היא מזדהה בבקשה, מכניס בהודעה את המידע ומידע נוסף רלוונטי (כמו id כאלה ואחרים), ומשתמש בפרוטוקול מוגדר מראש POST שהשרת יודע שהוא נועד לשמירת מידע.&lt;/p>
&lt;p>בנוסף, כדי להקל על הניווט בין המידע שקיים בשרת, כל מידע מקבל ייחוס בדמות של לינק (resource), כך שאפשר לנווט אליו או לשנות את המידע. לדוגמה, אם יש לנו משתמשים והודעות של המשתמשים, אז הלינק המיוחס למשתמש יכול להיות /user ולהודעות /user/id/messages. השאיפה, היא ליצור שפה אחידה שתתרגם צורך מסוים, כלינק.&lt;/p>
&lt;p>הפאזל האחרון לממשק האחיד מכיל את המושג HATEOS - Hyper As The Engine Of Application Sate. הכוונה היא שהניווט באתר\סרביס הוא דרך לינקים. השרת מחזיר בתשובתו טקסט (שכיום יהיה בדר&amp;quot;כ אובייקט ג&amp;rsquo;ייסון) שמכיל בתוכו לינקים, והלינקים הללו הם ההוראות אל הקליינט (או סרביס אחר) לאיך לנווט באתר\סרביס (אנאלוגיה למשתמש שנכנס לעמוד ראשי של אתר כלשהוא, ומשם מתחיל את הניווט שלו לאיך ליצור או לשנות מידע קיים\חדש.
השימוש בזה כיום הוא פחות נפוץ, כשרוב הקליינטים כיום מרנדרים לעצמם מראש את הלינקים בתוך הUI, ולא בדיוק מחכים להוראות מהשרת. אם הקליינט צריך לדעת איך לנווט ולגשת אל המידע, הוא פשוט משתמש בדוקומנטציה (כמו swagger).&lt;/p>
&lt;p>אם נחבר את כל הממשק, GET /users היא שפה אחידה ל&amp;quot;הבאנה לי את המשתמש&amp;rdquo;. כיום בדר&amp;quot;כ מציינים את תצורת המידע כג&amp;rsquo;ייסון. בתוך התשובה מהשרת, אנחנו אמורים לקבל גם לינקים המיוחסים למשתמש כמו שמירה (user/) או עריכה (user/1).&lt;/p>
&lt;p>נכון ש-REST היא הפופולארית ביותר, אבל אם אפשר לקרוא לכל סרביס שמגדיר את העצמו כ-RESTful, זה מעט שנוי במחלוקת. הרבה מאוד APIs לא באמת יכולים לסמן וי על &lt;em>כל&lt;/em> החוקים (למשל, הרבה לא עובדים במדויק לפי HATEOS), אבל עדיין יכולים לתקשר אחד עם השני תחת הסטנדרט של פרוטוקול ה-HTTP. בנוסף, פרוטוקולים חדשים כמו GRPC מתחילים להתעורר ולתפוס תאוצה, כך שאולי נראה גישות חדשות ומודרניות יותר לבנות מערכות שמתקשרות דרך האינטרנט.&lt;/p></content></entry><entry><title type="text">על NAT</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/nat/"/><id>https://neocode.blog/posts/nat/</id><updated>2020-09-13T21:12:12+03:00</updated><published>2020-09-14T08:30:00+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">איך שורדים עם רק 4 מיליארד כתובות IP לכל האינטרנט? NAT!
כשאנחנו משתמשים באינטרנט אנחנו זקוקים לכתובת IP. כמו דואר רגיל, יש צורך בנמען ומוען- גם למחשב ששולח בקשה וגם לשרת שאליו היא נשלחת צריכה להיות כתובת IP כדי שידעו איך לתקשר ביניהם.</summary><content type="html">&lt;p>איך שורדים עם רק 4 מיליארד כתובות IP לכל האינטרנט? NAT!&lt;/p>
&lt;p>כשאנחנו משתמשים באינטרנט אנחנו זקוקים לכתובת IP. כמו דואר רגיל, יש צורך בנמען ומוען- גם למחשב ששולח בקשה וגם לשרת שאליו היא נשלחת צריכה להיות כתובת IP כדי שידעו איך לתקשר ביניהם. בפרוטוקול ה-IP הנוכחי, IPv4, יש קצת יותר מ-4 מיליארד כתובות IP זמינות לשימוש, שזה בבירור לא מספיק לכמות המכשירים המחוברים לאינטרנט. מסיבה זו פותח פרוטוקול IPv6 שמגדיל את מספר הכתובות הזמינות לשימוש מ-4 מיליארד ל-340 undecillion, שזה 340 ואז 36 ספרות אחריו (340,282,366,920,938,463,463,374,607,431,768,211,456). אבל גם היום IPv6 לא בשימוש רחב מספיק ולא כולם תומכים בו. אז איך שרדנו עד עכשיו?&lt;/p>
&lt;p>קודם כל, חשוב להבדיל בין שני סוגי כתובות IP: ציבוריות ופרטיות. כתובות IP ציבוריות רשומות באופן פומבי וכולם יכולים לגשת אליהן. כתובת ה-IP של הראוטר שלכם ושל השרת שאתם ניגשים אליו היא כתובת ציבורית. לעומת זאת, כתובות IP פרטיות לא רשומות באופן פומבי וניתן לגשת אליהן רק בתוך הרשת, כלומר רק בתוך הבית או העסק.&lt;/p>
&lt;p>ניקח לדוגמה את הרשת הביתית שלכם. הראוטר שלכם מקבל כתובת IP מהספקית שלכם. בשביל לחסוך 10-20 כתובות IP לכל מכשיר שמחובר לרשת הביתית שלכם, הראוטר משתמש בטכניקה שנקראת NAT (Network Address Translation). הראוטר מחלק לכל המכשירים שמחוברים אליו כתובות פרטיות, ששייכות לכמה טווחים שנקבעו לשימוש זה- כל הכתובות מהצורה &lt;div dir="ltr">10.X.X.X&lt;/div>, כל הכתובת מהצורה &lt;div dir="ltr">172.16-31.X.X&lt;/div> וכל הכתובות מהצורה &lt;div dir="ltr">192.168.X.X&lt;/div>, קצת פחות מ-18 מיליון בסך הכל. בטווח האחרון לדוגמה, המחשב יהיה עם הכתובת 192.168.0.1, הפלאפון 192.168.0.2 וכו&amp;rsquo;. כשאתם תגישו בקשה לאינטרנט, בעזרת ה-NAT הראוטר ימיר את הכתובת הפרטית לכתובת הציבורית ולכן כלפי חוץ כל המכשירים ברשת יחלקו אותה כתובת IP. ה-NAT עובד גם בכיוון השני, כשהבקשה חוזרת מהאינטרנט לכתובת הציבורית של הראוטר ואז בעזרת ה-NAT הראוטר מעביר אותה לכתובת הפרטית הנכונה, בין אם זה למחשב או לפלאפון.&lt;/p>
&lt;p>יש ארבעה סוגים או יישומים עיקריים של NAT:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>SNAT - Static NAT: מדובר ב-NAT שמספק כתובת IP ציבורית קבועה לכל כתובת IP פנימית. אם להמשיך עם הדוגמה שלמעלה, אז נוכל לשייך את הכתובת הציבורית 91.198.174.192 לכתובת 192.168.0.1 וכך כל מי שניגש לכתובת 91.198.174.192 ייגש למחשב שלנו (או עם דוגמה יותר ריאליסטית- שרת FTP). כל מי שיגש לכתובת 91.198.174.193 יופנה לכתובת 192.168.0.2, כלומר לפלאפון (או לשרת מייל). הכתובות לא חייבות להיות עוקבות כמובן. מדובר ב-NAT מאוד בזבזני והוא משמש בעיקר לתנועה נכנסת. המטרה העיקרית שלו היא לחשוף שרת עם כתובת IP פרטית לאינטרנט הציבורי.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DNAT - Dynamic NAT: בדומה ל-NAT סטטי גם DNAT מספק כתובת ציבורית לכל כתובת פרטית, אבל באופן קצת שונה. כאן הראוטר מחזיק במלאי של כתובת IP ובכל בקשה כתובת IP פנימית מנותבת לכתובת IP זמינה ברשימה. לדוגמה, אם נתחבר עם המחשב, כלומר עם 192.168.0.1, נקבל את הכתובת 83.2.3.1. לאחר מכן נתחבר עם הפלאפון, ונקבל את הכתובת 83.2.3.2 וכן הלאה, כשכל מכשיר מקבל כתובת פנויה מהרשימה של הראוטר וכתובות מתפנות אחרי שהמשתמש התנתק. גם גישה זו בזבזנית והיא משמשת בעיקר לצורכי תנועה יוצאת. שיטה זו למעשה מסתירה את ה-IP של המשתמשים ומקשה על תוקפים חיצונים לזהות אותו, שכן כתובת ה-IP שלו משתנה באופן תכוף. השימוש של DNAT הוא דומו בעיקרון ל-SNAT, כלומר מתן כתובת ציבורית לכל כתובת פרטית שלנו, אבל הוא נוח במיוחד כאשר אין חשיבות לאיזה מכשיר יקבל איזו כתובת ואז, במקרה שיש לנו 250 שרתים לדוגמה, במקום ליצור 250 רשומות SNAT נוכל לספק פשוט כתובות באופן דינמי בהתאם למה שזמין.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PAT - Port Address Translation: הצורה הכי נפוצה של ה-NAT. כאן לכל מכשיר ברשת הפנימית (פלאפון, מחשב) יש כתובת IP פרטית (192.168.0.1, 192.168.0.2) ולראוטר יש כתובת IP ציבורית (91.198.174.192). במעבר בין הרשת הפנימית לחיצונית, כתובת ה-IP הפרטית מוחלפת לכתובת IP ציבורית עם תוספת של פורט. לדוגמה פניה מהמחשב תגיע לראוטר ותצא ממנו בצורה 91.198.174.192:8001, והפניה מהפלאפון תצא בצורה 91.198.174.192:8002. כך ה-NAT יודע לנווט בקלות את הטראפיק ויודע איזה מידע אמור להגיע לאיזה מכשיר בדיוק. יש כ-65.5 אלף פורטים זמינים לשימוש, חלקם שמורים לשימושים מסוימים (לדוגמה 22 ל-SSH, כאשר 80 שמור ל-HTTP ו-443 ל-HTTPS וכו&amp;rsquo;), אך יש עשרות אלפים שזמינים לשימוש.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Port Forwarding: רלוונטית בעיקר כשיש רק כתובת IP ציבורית אחת, אבל מספר שרתים ציבוריים שצריכים לחלוק אותה, ולכן גם בעיקר רלוונטית כשמדובר בתנועה נכנסת. כך לדוגמה אם נרצה לגשת לשרת ה-FTP שלנו, שכתובת ה-IP הפרטית שלו היא (192.168.0.1) וכתובת ה-IP הציבורית שלנו היא 91.198.174.192, אז עם Port Forwarding נוכל להפנות כל גישה לכתובת 91.198.174.192:21 לשרת ה-FTP שלנו. בדומה נוכל להפנות את הכתובת 91.198.174.192:25 לכתובת 192.168.0.2 שמשתמשת את שרת המייל שלנו, את הכתובת 91.198.174.192:80 לשרת ה-Web שלנו שנמצא בכתובת 192.168.0.3 וכו&amp;rsquo;.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>ה-NAT כמובן לא חף מחסרונות. תרגום הכתובות לוקח זמן שיוצר דיליי ועלול לפגוע בביצועים (אם כי לא סביר שיורגש), תוכנות מסוימות עלולות לא לעבוד בגלל הגדרות לא נכונות, במיוחד אפליקציות שדורשות פורטים ספציפיים כמו שרתי Web או טורנטים.&lt;/p>
&lt;p>לסיכום, NAT זו טכנולוגיה שמתרגמת כתובות IP פרטיות וציבוריות ומאפשרת לנו לקבל אבטחה מוספת על ידי הסתרת כתובות IP של מכשירי קצה, להאריך את תוחלת החיים של ה-IPv4 על ידי חיסכון בכתובות ציבוריות ולהפריד את הרשת הפנימית שלנו מהרשת החיצונית. עם המעבר ל-IPv6 בעתיד הקרוב, לכל מכשיר קצה תהיה כתובת IP ציבורית משלו וה-NAT יהפוך מהר מאוד לנחלת העבר.&lt;/p></content></entry><entry><title type="text">Load Balancer</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/load-balancer/"/><id>https://neocode.blog/posts/load-balancer/</id><updated>2020-09-08T14:40:55+03:00</updated><published>2020-09-08T14:40:19+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">איך מתמודדים עם עומס על השרת(ים) כיום? אחת התשובות- Load Balancer.
הרעיון של Load Balancer בעצם נהפך להכרח אצל הרבה חברות עקב הפריצה הענקית של המשתמשים באינטרנט. פעם עוד היה אפשר להרים את המחשב של אמא בתור שרת בסיסי בסלון כמו צוקרברג, אבל מהר מאוד זה הפסיק להיות לו כפתרון לגיטימי.</summary><content type="html">&lt;p>איך מתמודדים עם עומס על השרת(ים) כיום? אחת התשובות- Load Balancer.&lt;/p>
&lt;p>הרעיון של Load Balancer בעצם נהפך להכרח אצל הרבה חברות עקב הפריצה הענקית של המשתמשים באינטרנט. פעם עוד היה אפשר להרים את המחשב של אמא בתור שרת בסיסי בסלון כמו צוקרברג, אבל מהר מאוד זה הפסיק להיות לו כפתרון לגיטימי. בכלל, כיום אתרים ואפליקציות מתמודדות עם ריבוי בקשות עצום. הפתרון, נמצא איפשהוא בין שני סוגים של scaling לפניות.&lt;/p>
&lt;p>הראשון: vertical scaling, שהוא אומר; שדרג את המכונה(שרת). תוסיף עוד RAM, תחליף ל- AMD RYZEN ותרביץ מכונה שתצליח לעמוד בריבוי הפניות. הבעיה הגדולה ביותר של זה היא שיש גבול עליון של כוח מחשובי שאפשר להגיע אליו יחסית מהר והגבול הזה גם ככה לא מספיק (לשרתים שמתקשים לעמוד בעומס).&lt;/p>
&lt;p>השני: horizontal scaling, שהוא אומר; שכפל את השרתים כך שיש ריבוי מכונות כדי שכולם יוכלו להתחלק עם הריבוי משתמשים\בקשות.&lt;/p>
&lt;p>הבעיה שנוצרה מ- horizontal scaling היא; איך לחלק את העבודה בין המכונות?, כלומר איך להחליט לאיזה שרת להפנות בקשה מסוימת. איך יודעים מתי שרת א&amp;rsquo; פנוי ושרת ב&amp;rsquo; לא פנוי?&lt;/p>
&lt;p>אז הרעיון של Load Balancer נועד לפתור בין היתר את הבעיות הנ&amp;quot;ל. Load Balancer בסיסי הוא כמו ראוטר, המפנה את הבקשות אל המכונות הרלוונטיים. בדר&amp;quot;כ זה יהיה שרת שמתפקד כמו reverse proxy (או כ). הוא יושב בתקשורת באמצע של הקליינט והשרת (או חוות שרתים).&lt;/p>
&lt;p>יש שני סוגים של Load Balancers פופולריים, L4 ו- L7. אז L4 מתייחס לכך שיש לו גישה רק לפורטים וה-IPים של הבקשה, ו7L מתייחס לכך שיש לו גישה לכל המידע בבקשת http (כמו body, routes, headers).&lt;/p>
&lt;p>זה אומר ש- 4L יכול לבצע את הלוגיקה של הניתוב רק בעזרת הפורטים וה-IPים של הבקשה. ה-4L מתרגם את התקשורת TCP ומחליף את ה-IP שלו עצמו (הנמען של הבקשה מהקליינט) עם ה-IP של השרת שהוא מחליט לנתב אליו את הבקשה. זה נקרא NAT – Network Address Translation.&lt;/p>
&lt;p>ל-L7 יש גישה למידע של הבקשה ולכן הוא יכול לבצע יותר לוגיקה בהתאם למידע. לדוגמה, להחזיר 401 כשה- authorization header של הבקשה ריק או לא תקין. L7 יודע גם לנתב בהתאם ל-routes, למשל ב- GET /images הוא ינתב לשרת הרלוונטי שמחזיר תמונות.&lt;/p>
&lt;p>ל- L7 יש 2 תקשורות TCP, אחת של הקליינט, ואחת שהוא מייצר עם השרת המנותב. הסיבות ליצירת התקשורת השנייה היא למשל בשינוי המידע בפניה, ואז העברת המידע החדש עם התקשורת החדשה. בנוסף, הרבה פעמים L7 מיושם גם כ- SSL Termination Gateway (פיענוח של המידע המוצפן) במקום שהשרתים יצטרכו להיות up to date עם התעודות SSL שלהן. 7L הוא reverse proxy קלאסי עם יכולות ניתוב.&lt;/p>
&lt;p>יש גם כמובן Internal Load Balancers (בשפה של AWS) שהם חבויים ולא ניתנים לגישה פומבית, אלא נמצאים בתוך רשת פרטית ומנהלים שם את הinfrastructure. דוגמה לכך היא ה- Docker Swarm שמנתב ומנהל את הסרביסים\שרתים שנמצאים בתוך השרת הפרטי.&lt;/p>
&lt;p>יש סוגים שונים של לוגיקה לכל Load Balancer שבעזרתו הוא מנתב את הבקשות לשרתים השונים, והלוגיקה תלויה בצרכים של האתר\אפליקציה. ישנם אלגוריתמים כמו round robin, שהוא כמו לחלק קלפים לאנשים לפי הסדר; הבקשה מנותבת לשרת הראשון, אח&amp;quot;כ לשני, שלישי עד אחרון השרתים- ואז חוזר חלילה לשרת הראשון.&lt;/p>
&lt;p>עוד אלגוריתם נקרא Weighted Response Time, אלגוריתם שמחשב מי השרת שמגיב הכי מהר- ואליו תנותב הבקשה. החישוב מתבצע בעזרת health checks שה- load balancer שולח בקשות מידי פעם ובודק את התקינות והמהירות תגובה של השרתים.&lt;/p>
&lt;p>אלגוריתם נוסף הוא Source IP Hash, שזה אלגוריתם בו ה-IP של הקליינט וה-IP של השרת אליה נשלחה הבקשה נתפרים יחד להאש (מפתח ייחודי), כך שיהיה אפשר לדעת בדיוק לאיזה שרת הקליינט ניגש בבקשה הקודמת, במידה והבקשה\התקשורת נפגעה, או שיש לקליינט צורך ממשי להגיע לאותו שרת ספציפי. דוגמה לכך היא במקרים בהם הקליינט צריך גישה ל-session ספציפי, בשרת ספציפי.&lt;/p>
&lt;p>ישנם מקרים בהם יש עומס של פעילות ביום וירידה חדה של פעילות בלילה. במקרים כאלה, יש צורך בלהעלות\להוריד שרתים בהתאם לעומס הבקשות בזמן אמת. רוב העננים מאפשרים את היכולות הללו, בעזרת שכפול ה-image של השרתים כך שכל השרתים יהיו זהים ומתחילים לבצע סקיילינג אוטומטי של השרתים. ב- AWS זה נקרא Auto Scaling, ובאז&amp;rsquo;ור זה נקרא Scaling Set.&lt;/p>
&lt;p>על פניו load balancer נראה מסובך, אבל הביצוע עצמו הוא דיי straight forward. רוב העננים מאפשרים להרים אחד כזה בכמה קליקים מבלי לעשות עמידת ידיים. גם הקונפיגורציה והלוגיקה של הניתוב לא מסובכים כשמבינים על פני השטח איך הדברים עובדים (או צריכים לעבוד).&lt;/p>
&lt;p>באז&amp;rsquo;ור למשל, צריך לעשות את הדברים הבאים:&lt;/p>
&lt;p>-להגדיר רשת פרטית לשרתים ול- load balancer&lt;/p>
&lt;p>-להגדיר שרתים שאליהם אנחנו רוצים לנתב&lt;/p>
&lt;p>-להרים שרת load balancer (דרך אז&amp;rsquo;ור) בכמה קליקים&lt;/p>
&lt;p>-להגדיר לו הגדרות כמו health checks, ssl, routing&lt;/p>
&lt;p>-ליצור &amp;ldquo;Backend Pool&amp;rdquo; – בעצם לקשר את השרתים שלנו עם הבאלאנסר&lt;/p>
&lt;ul>
&lt;li>יש load balancer עובד!&lt;/li>
&lt;/ul></content></entry><entry><title type="text">על VPN</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/vpn/"/><id>https://neocode.blog/posts/vpn/</id><updated>2020-09-08T15:01:03+03:00</updated><published>2020-09-07T12:43:26+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">כולנו נתקלנו בפרסומות ואינסוף חסויות לשירותי VPN מכל מיני סיבות- אבטחה, פרטיות או סתם בשביל לצפות בנטפליקס אמריקה. אבל איך בדיוק VPN עובד?
בעבר, VPN (או Virtual Private Network – רשת פרטית וירטואלית) היה בשימוש בעיקר בקרב עסקים, בדגש על חברות גדולות, בכדי לאפשר לעובדים לגשת לרשת המאובטחת במשרד מהבית באמצעות חיבור מאובטח.</summary><content type="html">&lt;p>כולנו נתקלנו בפרסומות ואינסוף חסויות לשירותי VPN מכל מיני סיבות- אבטחה, פרטיות או סתם בשביל לצפות בנטפליקס אמריקה. אבל איך בדיוק VPN עובד?&lt;/p>
&lt;p>בעבר, VPN (או Virtual Private Network – רשת פרטית וירטואלית) היה בשימוש בעיקר בקרב עסקים, בדגש על חברות גדולות, בכדי לאפשר לעובדים לגשת לרשת המאובטחת במשרד מהבית באמצעות חיבור מאובטח. בשביל להבין למה היה צורך ב-VPN, כדאי להבין איך אנחנו מתחברים לאינטרנט.&lt;/p>
&lt;p>נניח שאנחנו רוצים להיכנס ליוטיוב מהמחשב, פלאפון או כל ציוד קצה אחר. קודם כל המידע נשלח מהמחשב שלנו לראוטר/מודם. לראוטר/מודם יש כתובת IP שמהווה מזהה, מעיין תעודת זהות. משם הבקשה עוברת לספקית האינטרנט שלנו, לאחת מחוות השרתים שלה, סביר להניח שבפתח תקווה או בתל אביב.&lt;/p>
&lt;p>משם המידע יוצא דרך כבל תת ימי לאיטליה, ומשם מדלג ברשת ענק של &amp;ldquo;כבישים&amp;rdquo; בדמות סיבים אופטיים על אדמת אירופה משרת לשרת עד שמגיע לשרת המיועד של גוגל. הבקשה מגיעה ליוטיוב, הוא בתגובה שולח את התגובה ומחזיר אותה כל הדרך חזרה.&lt;/p>
&lt;p>אז איפה הבעיה? קודם כל, בכל נקודה בדרך המידע שלנו חשוף ללא מעט עיניים. מידע שעובר באופן לא מוצפן יהיה נגיש לכל בעל גישה לנקודות האלו. זו הסיבה שלהשתמש באינטרנט ציבורי, בין אם בבית החולים או בבית הקפה, כדי להתחבר לבנק הוא לא צעד מומלץ. כל אדם עם קצת ידע טכני יוכל לקרוא את כל המידע שעובר ברשת- כל הודעה, כל סיסמה. אבל גם אם המידע מוצפן, המידע שלנו נגיש להרבה גורמים אחרים. הספקית והרבה מהנקודות בדרך יכולות לראות לאן אנחנו רוצים לגשת ולקבל את היסטורית הגלישה שלנו ומידע שאולי היינו מעדיפים לשמור לעצמנו. גם האתר יוכל לראות מי אנחנו. כל הגורמים כמעט בוודאות שומרים לוגים מפורטים עם המידע שלנו.&lt;/p>
&lt;p>וכאן נכנס ה-VPN לתמונה. בכדי לייצר חיבור המאובטח ה-VPN יצר מעיין תעלה (Tunnel Protocol) שמהווה מעטפת מאובטחת לחיבור. ברגע שמזוהה חדירה כלשהי לתעלה, ה-VPN מנתק באופן מיידי את החיבור ומחבר את הלקוח באמצעות נתיב אחר. כלומר אם באיזשהו שלב בסדרת הדילוגים אחד השרתים שנחתנו עליהם &amp;ldquo;חשוף&amp;rdquo;, ה-VPN יעבור לנתיב אחר. במקום לעבור מבארי איטליה לציריך ומשם לפרנקפורט, ה-VPN אולי יזהה שהחיבור דרך ציריך חשוף, ינתק אותנו ויחבר מחדש בנתיב שעובר מבארי לרומא, משם לבאזל ולבסוף יגיע לפרנקפורט.&lt;/p>
&lt;p>בתוך התעלה הזו עובר המידע כשהוא מוצפן. כך גם אם למישהו יש גישה לתחנה כלשהי בדרך, הוא לא יוכל לקרוא את המידע ששלחנו- לא ברשת פרטית ולא ברשת ציבורית.&lt;/p>
&lt;p>ואם כל זה לא מספיק, המידע עובר בתחנת ביניים- שרת ה-VPN. כשאנחנו מחוברים ל-VPN אנחנו שולחים את הבקשה מוצפנת לשרת ה-VPN. השרת מפענח את הבקשה ומביא לנו אותה. הוא מהווה מעיין מידל מן- במקום לשלוח הודעה ליוטיוב באופן ישיר, אנחנו שולחים הודעה ל-VPN ואז הוא שולח את ההודעה ליוטיוב ובכך מסתיר את הזהות שלנו מיוטיוב, שמבחינתו מי ששלח לו הודעה זה שרת ה-VPN, לא אנחנו. בזכות ההצפנה גם כל הנקודות בדרך לשרת ה-VPN לא יודעות מה ביקשנו, כי המידע מוצפן. הן רק יודעות ששלחנו בקשה כלשהי לשרת כלשהו.&lt;/p>
&lt;p>זו גם הסיבה ש-VPN מאפשר לנו לצפות בנטפליקס במדינות זרות- אם נניח שאנחנו מחוברים לשרת VPN בניו יורק וגולשים בנטפליקס, מבחינת נטפליקס התקבלה בקשה ממחשב מתל אביב אלא מקבל בקשה ממחשב בניו יורק ולכן הוא יציג לו תוכן שמתאים לתיוג הגיאוגרפי של ניו יורק. כך גם לגבי כל חסימת תוכן על בסיס גיאוגרפי אחר- בין אם ב-BBC או ביוטיוב.&lt;/p>
&lt;p>גם כשמדובר בצנזורה במדינות כמו סין או איראן ה-VPN פותר את הבעיה בדרך דומה- במקום לגשת לשרת ויקיפדיה, ניגשים לשרת ה-VPN. המדינה לא יכולה לראות מה שלחתי ל-VPN ולכן הבקשה עוברת, משם ה-VPN מבקש בעצמו מויקיפדיה את האתר ושולח לנו אותו בחזרה מוצפן. ככה ניגשנו לויקיפדיה בלי שהאח הגדול ידע- מבחינתו ביקשנו משהו משרת כלשהו ולכן זה בסדר.&lt;/p>
&lt;p>אז מה הקאטץ’? יש כמה. דבר ראשון, חולשה די בולטת היא שרת ה-VPN עצמו. הוא יודע מי שלח את הבקשה והוא יודע מה היא (הרי הוא הוריד את ההצפנה כדי לקרוא). אנחנו למעשה צריכים לסמוך על חברות ה-VPN שהן מוחקות את הלוגים שלהן.&lt;/p>
&lt;p>בעיה נוספת היא המהירות- ההצפנה והנקודה הנוספת, במיוחד אם היא רחוקה, יכולה להאט דרסטית את הגלישה. במקרה שאנחנו מתחברים מישראל דרך ארהב לאתר אירופאי לדוגמה, אנחנו נתחבר מהבית, לספקית, לאיטליה, לפרנקפורט, משם לונדון/אמסטרדם, לניו יורק, לשרת ה-VPN, שאחר כך ישלח את הבקשה לניו יורק, לונדון, נקודה כלשהי באירופה, חזרה ללונדון, ניו יורק, שרת VPN ושוב לניו יורק, לונדון, פרנקפורט, איטליה, ישראל, אלינו. אם אנחנו ניגשים לשרת אמריקאי אנחנו חוסכים 2 כיוונים לאירופה, אבל עדיין מדובר בדרך שחוצה יבשות ואוקיינוס ואנחנו נחווה ניחות (גם אם לא אחד שיורגש יותר מדי).&lt;/p>
&lt;p>עם זאת כדאי לציין שבשעות עומס לפעמים דווקא ה-VPN יכול להיות יותר מהיר, בגלל שהוא עובר ב&amp;quot;סמטאות&amp;rdquo; אינטרנט מאובטחות יותר ולכן ניגש לשרת בדרך פחות עמוסה, בניגוד לרוב האנשים שיעברו דרך כביש סואן.&lt;/p></content></entry><entry><title type="text">כמה ארוכה פונקציה צריכה להיות?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/function-length/"/><id>https://neocode.blog/posts/function-length/</id><updated>2020-09-08T19:00:40+03:00</updated><published>2020-09-06T16:52:35+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">אם נשאל את דוד בוב, זה כנראה יהיה עד 100&amp;hellip;
קשה באמת להגדיר כמה ארוכה פונקציה צריכה להיות, וכנראה שאי אפשר לנקב במספר ממשי (כל מספר שננקב כנראה יהיה שרירותיׂ), אבל אפשר להתווכח שלפונקציות קצרות יש מספר יתרונות בולטים שקשה להתעלם מהם.</summary><content type="html">&lt;p>אם נשאל את דוד בוב, זה כנראה יהיה עד 100&amp;hellip;&lt;/p>
&lt;p>קשה באמת להגדיר כמה ארוכה פונקציה צריכה להיות, וכנראה שאי אפשר לנקב במספר ממשי (כל מספר שננקב כנראה יהיה שרירותיׂ), אבל אפשר להתווכח שלפונקציות קצרות יש מספר יתרונות בולטים שקשה להתעלם מהם.&lt;/p>
&lt;p>כשאני מתייחס לפונקציות קצרות, הכוונה היא לפירוק הקוד בפונקציה אחת לתתי פונקציות. או כמו שחובבי פילוסופיית היוניקס אוהבים לומר: כל פונקציה צריכה לעשות משהוא אחד, ולעשות אותו טוב. הקוד &lt;em>לא&lt;/em> צריך להיות מושפע מאורך הפונקציה. הקוד הוא חלק נפרד, שנכתב בהתאם ליעילות הרלוונטית ועד כמה הוא קריא.&lt;/p>
&lt;p>אם ניקח פונקציה ארוכה מאוד ונתחיל לפרק אותה לתתי פונקציות, הדבר הראשון שיבלוט בעין זה שקל יותר להבין מה הפונקציה עושה (אם זה לא ברור לפי השם), ובערך איך היא עושה זאת. זה משמעותית תופס את העין מאשר קטע קוד ארוך שצריך להתחיל לקרוא שורה שורה ולתפוס את התמונה כמו פאזל לא מורכב (לא משנה עד כמה הקוד &amp;lsquo;קריא&amp;rsquo;).&lt;/p>
&lt;p>בנוסף, עטיפת קטעי קוד בפונקציות נותנת לנו עוד שכבת הפשטה. שכבת ההפשטה הזאת מעודדת אותנו להשתמש יותר בפונקציות הקיימות, מצמצמת חזרה על קוד קיים, ומאפשרת לנו יותר גמישות פונקציונאלית בתוך הפונקציות.&lt;/p>
&lt;p>מבחינת דיבוג גם יש יתרון- יהיה קל יותר לדבאג פונקציות מפורקות מבלי שנצטרך לדעת איזה חלק בקוד לתפוס כנקודת עצירה.&lt;/p>
&lt;p>טסטים גם עשויים לקבל יתרון כשאפשר לבנות יוניט טסטים על פונקציות בודדות במקום על אחת (למרות שעל עקרון כזה יש וויכוח, האם צריך לבדוק את התוצאה של הפונקציה דרך תתי הפונקציות שלה, הוא דרך הפונקציה כמכלול?).&lt;/p>
&lt;p>אני אף פעם לא בעד פתרונות שחור או לבן- כי כנראה פתרונות כאלה לא קיימים, לפחות לא בתוכנה. אבל לפונקציות קצרות, המפורקות לתתי פונקציות, כן יש יתרונות מאוד בולטים שקשה להתווכח איתם. לגבי חסרונות? אולי שיש יותר מידי לגו לשחק איתם, והשאלה היא אם זה חסרון מספיק גדול.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">UTF-8, ASCII &amp; Unicode</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/utf-ascii-unicode/"/><id>https://neocode.blog/posts/utf-ascii-unicode/</id><updated>2020-09-08T19:00:31+03:00</updated><published>2020-08-27T16:41:41+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">מה זה כל האסקים, UTFים וכל קידודים האלה?
נתחיל מהאב הקדמון- קוד מורס האגדי. קוד מורס הומצא כשיטה להעביר הודעה דרך אמצעים אלקטרונים ולתרגם את הצלילים המועברים לאותיות. את ההודעה בונים בעזרת תקשורת בינארית(בתוספת של רווח בין הצלילים)- נקודה או קו. כך למשל את ההודעה &amp;ldquo;SOS&amp;rdquo; שכולנו מכירים, אפשר לקרוא בקוד מורס כ- &amp;ldquo;&amp;hellip; - - - &amp;hellip;&amp;rdquo;, ואם נשמע את הצליל של ההודעה הזאת, הוא יהיה מאוד מוכר לכולנו מאיפשהוא (כי טחנו את הצליל בכל מקום בסרטים הישנים).</summary><content type="html">&lt;p>מה זה כל האסקים, UTFים וכל קידודים האלה?&lt;/p>
&lt;p>נתחיל מהאב הקדמון- קוד מורס האגדי. קוד מורס הומצא כשיטה להעביר הודעה דרך אמצעים אלקטרונים ולתרגם את הצלילים המועברים לאותיות. את ההודעה בונים בעזרת תקשורת בינארית(בתוספת של רווח בין הצלילים)- נקודה או קו. כך למשל את ההודעה &amp;ldquo;SOS&amp;rdquo; שכולנו מכירים, אפשר לקרוא בקוד מורס כ- &amp;ldquo;&amp;hellip; - - - &amp;hellip;&amp;rdquo;, ואם נשמע את הצליל של ההודעה הזאת, הוא יהיה מאוד מוכר לכולנו מאיפשהוא (כי טחנו את הצליל בכל מקום בסרטים הישנים).&lt;/p>
&lt;p>קוד מורס שירת את האנושות עד עליית המחשבים והתקשורת בין המחשבים, המשתמשת בתקשורת בינארית של 0 ו-1, דאז האנושות הייתה צריכה להתקדם קצת ולמצוא דרך חדשה לתרגם את המידע שנשמר או נשלח ברשת בצורה של 0 או 1&amp;rsquo;ים- לתווים ומספרים ממשיים.&lt;/p>
&lt;p>אז שיטות להפיכת מספרים רגילים לבינאריים וההפך- היה לנו. 1 זה 1, 2 זה 10, 3 זה 11 וכל&amp;rsquo;. אבל לתווים- לא היה לנו.&lt;/p>
&lt;p>ואז נולדה לה טבלת ה- ASCII, שהיא מכילה את כל התווים של המקלדת שלכם, כש-33 התווים הראשונים מיוחסים ל&amp;quot;פקודות&amp;rdquo; כמו SPACE, TAB, ESC , ו-65 עד 127 לשאר התווים כמו אותיות קטנות וגדולות (באנגלית בלבד- זה חשוב), + - = וכל&amp;rsquo;. הטבלת ASCII הראשונית הייתה מוגדרת ל- 7 ביטים לייצוג תו, כך שיש 128 אפשרויות סה&amp;quot;כ. עכשיו אפשר לחזור אחריי: 1000001 זה A, ו- 1000010 זה B. הוריי אפשר לתרגם תווים מבינארית לאנגלית!&lt;/p>
&lt;p>על אף ההתקדמות המטאורית, שאפילו בעזרת טבלת ASCII הטיסו חללית לירח, היה נחוץ בעוד פריצת דרך: אנחנו רוצים להעביר תווים בינלאומיים בכל העולם, ולא רק באנגלית. מה עם קצת אותיות בסינית, רוסית ועברית? ומה עם קצת אימוג&amp;rsquo;יז?&lt;/p>
&lt;p>שוב נכנסנו להריון והפעם הולדנו את ה- Unicode, שהיא טבלה שאפתנית המאכלסת את כל התווים בעולם- עברית, רוסית, יפנית, אימוג&amp;rsquo;י, ועוד (לכל תו יש &amp;ldquo;code point&amp;rdquo; שהוא המזהה הייחודי שלו בטבלה). עכשיו יש לנו טבלה משודרגת, וכל שנותר לנו הוא לייחס כל תוו לייצוג הבינארי שלו. לשם כך נוצרו להם קידודים שונים עם חוקים משלהם.&lt;/p>
&lt;p>כאן נכנס UTF-8 לתמונה. UTF-8 בהגדרתו הוא שימוש ב-8 ביטים לפחות לייצוג של תוו כלשהוא, &lt;em>הכולל&lt;/em> את השימוש הרגיל של ה- ASCII שלנו. זה אומר, שהייצוג של A ב-UTF8 יהיה 01000001. גם ב- ASCII אגב הורחבו התווים מ-128 אפשרויות ל- 256 אפשרויות, כיאה לקומבינציות של byte אחד.&lt;/p>
&lt;p>מחיפוש בגוגל נתון שיש כ- 143,859 תווים ל-unicode, אבל התשובה כנראה מורכבת יותר. בכל מקרה, זה הרבה מעל ל-256 האפשרויות שיש בבייט אחד. אז מה עושים? ממשיכים לעוד בייט, ועוד בייט עד 6 בייטים (כלומר הקפיצות יהיו של bytes).&lt;/p>
&lt;p>ומה עם UTF 16, 32? אותו רעיון- הייצוג של כל תו יהיה לפי 16 או 32 ביטים בהתאמה. לפי ההיגיון UTF-8 נשמע יעיל יותר, מכיוון שכל תוו מיוצג במינימום של 8 ביטים, בזמן שהאחרים ע&amp;quot;י 16 ו-32, אבל זה לא מדויק. ישנם מקרים בהם דווקא להשתמש ב 16-UTF יעיל יותר (כמו בשפות אסיאתיות מסוימות), שכן פרזנטציות של אותיות בשפות מסויימות ב- 8UTF יהיו בגודל 4 בייטים, וב-16 יהיו בגודל 2 בייטים. בנוסף, מכיוון שטבלת ASCII תומכת בייצוג של 8 ביטים לתו, אז קידודים כמו 16,32 UTF לא ייתמכו במערכות המתבססות על ASCII.&lt;/p>
&lt;p>לקינוח, מה זה בדיוק codec? זה פשוט הסוג של הקידוד שאנחנו משתמשים בו. UTF-8 למשל, הוא סוג של codec.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">הצפנה א-סימטרית</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/asymmetric-encryption/"/><id>https://neocode.blog/posts/asymmetric-encryption/</id><updated>2020-09-08T19:00:37+03:00</updated><published>2020-08-24T16:46:08+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">Asymmetric encryption &amp;amp; public/private puke
בעידן של היום, כשהפרטיות והאבטחה שלנו ברשת רק הולכות ונשחקות, כדאי להיזכר בחשיבות של ההצפנה- מהיסודות של אינטרנט פתוח, חופשי ומאובטח. ובגזרה הזו הצפנה אסימטרית היא השיטה הכי נפוצה וכנראה שהכי חשובה, אבל עד כמה אתם יודעים איך היא עובדת?</summary><content type="html">&lt;p>Asymmetric encryption &amp;amp; public/private puke&lt;/p>
&lt;p>בעידן של היום, כשהפרטיות והאבטחה שלנו ברשת רק הולכות ונשחקות, כדאי להיזכר בחשיבות של ההצפנה- מהיסודות של אינטרנט פתוח, חופשי ומאובטח. ובגזרה הזו הצפנה אסימטרית היא השיטה הכי נפוצה וכנראה שהכי חשובה, אבל עד כמה אתם יודעים איך היא עובדת?&lt;/p>
&lt;p>בשביל להבין את הצורך בהצפנה א-סימטרית כדאי להכיר את ההצפנה הסימטרית הפשוטה יותר. בהצפנה סימטרית אנחנו משתמשים במפתח סודי אחד גם לפיענוח וגם להצפנה. כלומר אם א’ וב’ רוצים להעביר ביניהם קובץ מוצפן סימטרית, א’ יצור מפתח סודי (סיסמה) שישמש להצפנת הקובץ, ישלח את הקובץ המוצפן לב’ ואז ב’ יצטרך להשתמש באותו המפתח של א’ בכדי לפענח את ההצפנה ולקבל את המידע הנחוץ.&lt;/p>
&lt;p>הבעיה היא שגם השולח וגם המקבל צריכים להיות עם אותו המפתח הסודי, מה שאומר שהם יאלצו לשתף אותו ביניהם בדרך כזו או אחרת, כך שבשלב כלשהו בדרך הם יאלצו לשתף את המפתח באופן לא מוצפן- וזה רע.&lt;/p>
&lt;p>את הבעיה הזו פותרת הצפנה א-סימטרית. בהצפנה א-סימטרית משתמשים בשני מפתחות- מפתח ציבורי ומפתח פרטי. המפתח הציבורי חשוף לכולם, והוא המפתח שיוצר את ההצפנה. השולח נעזר במפתח הציבורי של המקבל בכדי לייצר קובץ מוצפן.&lt;/p>
&lt;p>על מנת לפענח את ההצפנה יש להיעזר במפתח הפרטי, שנמצא רק אצל המקבל. גם השולח לא יכול לפענח את הקורס שהוא עצמו הצפין מאחר ואין לו את המפתח הפרטי.&lt;/p>
&lt;p>דוגמה: א’ וב’ שולחים אחד לשני הודעות עם הצפנה א-סימטרית. לכל אחד מהם יש 3 מפתחות- לא’ יש את המפתח הציבורי שלו, את המפתח הפרטי שלו ואת המפתח הציבורי של ב’. לב’ יש את המפתח הפרטי והציבורי שלו ואת המפתח הציבורי של א’. כשא’ שולח הודעה לב’, הוא מצפין אותה עם המפתח הציבורי של ב’. לאחר שההודעה הוצפנה הדרך היחידה לקרוא אותה היא באמצעות המפתח הפרטי של ב’ ולכן לא’ אין יכולת לקרוא את מה שהוא עצמו כתב. ההודעה נשלחת לב’ שבאמצעות המפתח הפרטי שלו קורא אותה.&lt;/p>
&lt;p>המפתחות הפרטיים קשורים למפתחות הציבוריים ויכולים לפענח את ההצפנה שהם יצרו, אבל אי אפשר למצוא אותם באמצעות מפתח ציבורי.&lt;/p>
&lt;p>כל עוד הנמען שומר על המפתח הפרטי שלו, אי אפשר לפצח את ההצפנה ולראות את המידע שהועבר. גם במידה והמפתח הסודי של אחד הצדדים נגנב, אפשר לקרוא רק את ההודעות שנשלחו אליו. כלומר, אם המפתח הפרטי של א’ נגנב, אז כל ההודעות שנשלחו לא’, הודעות שהוצפנו על ידי המפתח הציבורי של א’ ומפוענחות על ידי המפתח הפרטי של א’, יהיו חשופות למי שמחזיק במפתח, אבל לא ההודעות שא’ שלח לב’. ההודעות שא’ שלח לב’ מוצפנות עם המפתח הציבורי של ב’ ועל מנת לפענח אותן יש צורך במפתח הפרטי של ב’.&lt;/p>
&lt;p>תכונה חשובה נוספת של הצפנה א-סימטרית היא היכולת להצפין את ההודעה עם המפתח הפרטי ואז לפענח אותה עם המפתח הציבורי. אמנם כל אחד יכול לקרוא את המידע שהרי לכל אחד יש את הגישה למפתח הציבורי, אבל מאחר והמידע הוצפן עם המפתח הפרטי שנמצא רק אצל אדם אחד אנחנו יכולים לאמת שמי ששלח את המידע הזה הוא אכן מי שהוא מתיימר להיות.&lt;/p>
&lt;p>ההבדלים בין השיטות מתבטאים בין היתר באורך המפתחות. מאחר ובהצפנה א-סימטרית חייב להיות קשר מתמטי בין המפתח הציבורי למפתח הפרטי, פורצים יכולים באופן תיאורטי &amp;ldquo;להסיק&amp;rdquo; את המפתח הפרטי מהציבורי. כתוצאה מכך המפתחות בהצפנה א-סימטרית הם ארוכים באופן משמעותי- מפתח של 2048 ביט בהצפנה א-סימטרית מספק פחות או יותר את אותה רמת האבטחה של מפתח 128 ביט בהצפנה סימטרית.&lt;/p>
&lt;p>היתרונות של השיטה הם אבטחה מוגברת ופתרון בעיית שיתוף המפתח הסודי, כמו גם אימות זהות השולח על ידי חתימה דיגטלית בדמות המפתח הפרטי. החסרונות הם האיטיות של השיטה ביחס להצפנה סימטרית והכוח העצום של המפתח הפרטי- אם המפתח הפרטי אבד או נגנב כל המידע אבד או נגנב.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">איך ללמוד רקורסיה באופן אינטואיטיבי</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/intuitive-recursion/"/><id>https://neocode.blog/posts/intuitive-recursion/</id><updated>2020-09-08T19:00:47+03:00</updated><published>2020-08-20T16:54:53+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">בשביל ללמוד רקורסיה, צריך ללמוד רקורסיה! או איך ללמוד רקורסיה the intuitive way 🙂.
פונקציה רקורסיבית היא פונקציה שקוראת לעצמה בתוך עצמה (ושכולם כבר הפנימו כנראה). אבל עדיין יש אלמנטים עמומים שמבלבלים אנשים ברקורסיה (ובצדק).
הדבר הראשון שמבלבל אנשים הוא איך קוראים לפונקציה בתוך עצמה, כשלא סיימנו עדיין את הפונקציה.</summary><content type="html">&lt;p>בשביל ללמוד רקורסיה, צריך ללמוד רקורסיה! או איך ללמוד רקורסיה the intuitive way 🙂.&lt;/p>
&lt;p>פונקציה רקורסיבית היא פונקציה שקוראת לעצמה בתוך עצמה (ושכולם כבר הפנימו כנראה). אבל עדיין יש אלמנטים עמומים שמבלבלים אנשים ברקורסיה (ובצדק).&lt;/p>
&lt;p>הדבר הראשון שמבלבל אנשים הוא איך קוראים לפונקציה בתוך עצמה, כשלא סיימנו עדיין את הפונקציה. הדבר השני, הוא איך ההיגיון מאחורי הקלעים עובד, שפולט את התשובה הנכונה כמו קסם.&lt;/p>
&lt;p>הסיבה שלקרוא לפונקציה בתוך עצמה &amp;ldquo;עובד&amp;rdquo;, הוא בגלל שכל קריאה לפונקציה נשמרת בזיכרון ב-stack (מחסנית), אשר עובדת לפי אחרון נכנס, ראשון יוצא. לדוגמה, אם נריץ את האלגוריתם הבא:&lt;/p>
&lt;p>func(n = 4):
if n == 0 return
func(n-1)
print(n)&lt;/p>
&lt;p>קודם כל יודפס 1, אח&amp;quot;כ 2, 3 ואז 4. זה בגלל שהקריאות נשמרות במחסנית לפי הסדר הבא: קודם נכנס למחסנית func(4), אחריו func(3)&amp;hellip;עד 0, הקריאה העליונה במחסנית. כשמגיעים לתנאי העצירה (0), מפסיקים לשמור קריאות במחסנית ומתחילים לעבור לשורת ההדפסה print בכל אחת מהקריאות מהסוף להתחלה במחסנית: מדפיסים 1, ואז 2 וכן הלאה.&lt;/p>
&lt;p>קטע מעניין, הוא שעדיין אפשר להגיע ל-stackoverflow גם מבלי להשתמש במשפט הקסם &amp;ldquo;בלי תנאי עצירה&amp;rdquo;, שכן אם נציב מספר גדול כמו 10000, האלגוריתם עדיין יקרוס מ-stackoverflow בגלל השימוש הכבד במחסנית (צריך לשמור n קריאות במחסנית).&lt;/p>
&lt;p>לעומת זאת, אם נחליף את הסדר של ה- print:&lt;/p>
&lt;p>func(n = 4):
if n == 0 return
print(n)
func(n-1)&lt;/p>
&lt;p>ההדפסה תהיה הפוכה: התוצאה שנקבל היא 4, אחריו 3, 2, ואז 1. הפונקציה מדפיסה את המספר n, וקוראת לעצמה שוב עם n-1. ברגע שהגענו לתנאי העצירה n=0, אין עוד מה לעשות והקריאות חוזרות אחת אחרי השניה מהסוף להתחלה ללא קריאה לפעולות נוספות. אלגוריתם כזה נקרא tail recursion.&lt;/p>
&lt;p>ההגדרה המילולית ל-tail recursion היא &amp;ldquo;הפעולה האחרונה של הפונקציה היא הקריאה לפונקציה עצמה&amp;rdquo;, כלומר אין עוד שורות או חישובים נוספים שעליה לבצע והיא מחזירה את התוצאה הסופית (אם יש מה להחזיר, לא במקרה שלנו). אלגוריתם שמשתמש ב-tail recursion יכול להיות לפעמים יעיל יותר מרקורסיה רגילה, שכן יש קומפיילרים המסוגלים לייעל את השימוש במחסנית (כלומר מתנהג כמו מימוש איטרטיבי).&lt;/p>
&lt;p>באלגוריתמים בהם צריך להחזיר תוצאה, כמו למשל בפונקציה רקורסיבית לחישוב עצרת (כאשר n = 4), הרעיון עובד בצורה דומה:
fact(n = 4)
if n == 1 return 1
return n*fact(n-1)&lt;/p>
&lt;p>הקריאה הראשונה שנכנסת למחסנית הוא fact4, והיא אומרת &amp;ldquo;תן לי את התוצאה של fact3 ואני אתן לך את התוצאה של 4!. אותו דבר ל-fact3 עד שמגיעים ל n = 1, שבמקרה מחזיר 1 כתנאי עצירה. ואז מלמעלה למטה:&lt;/p>
&lt;p>fact(1) = 1
fact (2) = 2 * fact(1) = 2&lt;em>1
fact(3) = 3 * fact(2) = 3&lt;/em>2
fact(4) = 4 * fact(3) = 4*6 = 24&lt;/p>
&lt;p>אלגוריתם של tail recursion ייראה כך:&lt;/p>
&lt;p>facTail(n = 4, results = 1):
if(n == 1) return results
return facTail(n-1, results * n)&lt;/p>
&lt;p>הפעולה האחרונה היא קריאה רקורסיבית, והפונקציה מעדכנת את הפרמטר results עד התנאי עצירה, מחזירה את הערך הסופי ומעיפה את כל הקריאות מהמחסנית אחד אחד.&lt;/p>
&lt;p>בגלל השימוש הנדיב שלה במחסנית, רקורסיה (לפחות רגילה) תהיה איטית יותר מאלגוריתם איטרטיבי, ולכן ברוב המקרים התירוץ להשתמש באלגוריתם רקורסיבי יהיה בהתאם לאינטואיטיביות של המימוש.&lt;/p>
&lt;p>בדר&amp;quot;כ האלגוריתמים האינטואיטיביים למימוש רקורסיבי הם במעבר על עצים, או מימושים של בעיות divide and conquer או במילים ישראליות- לפוצץ את הבעיה לחתיכות קטנות ולפתור. האלגוריתם לפתרון של tower of hanoi היא דוגמה ממש נפלאה לאיך אלגוריתם איטרטיבי ומסובך נחתך למס&amp;rsquo; שורות מצומצם במימוש רקורסיבי.&lt;/p>
&lt;p>הרעיון המרכזי שצריך להפנים בפונקציה רקורסיבית רגילה, היא איך נשמרות הקריאות במחסנית, ולעבוד מלמעלה למטה- ואז הרבה יותר קל להבין את ההגיון מאחורי האלגוריתם. ב- tail recursion צריך להפנים שבסה&amp;quot;כ מעדכנים כל פעם פרמטר(ים) ועובדים איתו מהגדול לקטן עד שבסוף מחזירים אותו.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">מה זה DNS, ומה הוא עושה?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/dns/"/><id>https://neocode.blog/posts/dns/</id><updated>2020-09-08T19:00:39+03:00</updated><published>2020-08-17T16:59:21+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">פרוטוקול ה-DNS, או בשמו המלא Domain Name System, הוא פרוטקול שכולנו משתמשים בו כל הזמן והופך את האינטרט לנגיש לכולם. למרות זאת, הוא לא זוכה למספיק יחס.
ה-DNS הוא למעשה ספר הטלפונים של האינטרנט. כשאנחנו מנסים להיכנס לויקיפדיה לדוגמה, אנחנו מזינים לשורת הכתובת בדפדפן כתובת שנוחה לבני אדם- wikipedia.</summary><content type="html">&lt;p>פרוטוקול ה-DNS, או בשמו המלא Domain Name System, הוא פרוטקול שכולנו משתמשים בו כל הזמן והופך את האינטרט לנגיש לכולם. למרות זאת, הוא לא זוכה למספיק יחס.&lt;/p>
&lt;p>ה-DNS הוא למעשה ספר הטלפונים של האינטרנט. כשאנחנו מנסים להיכנס לויקיפדיה לדוגמה, אנחנו מזינים לשורת הכתובת בדפדפן כתובת שנוחה לבני אדם- wikipedia.org. הבעיה היא שמחשבים לא עובדים בצורה כזו, הכתובות של מחשבים הן כתובות IP מספריות. למעשה הכתובת של ויקיפדיה עבור המחשב היא 91.198.174.192 בפרוטקול IPv4 או 2620:0:862:ed1a::1 בפרוטקול Ipv6, ואף אחת מהן לא ידידותית למשתמש.&lt;/p>
&lt;p>וכאן ה-DNS נכנס לתמונה. ה-DNS מקשר בין הכתובת ה&amp;quot;אנושית&amp;rdquo; wikipedia.org לכתובת האמיתית- 91.198.174.192.&lt;/p>
&lt;p>איך ה-DNS יודע לקשר כתובות?&lt;/p>
&lt;p>כשאנחנו מזינים את הכתובת ולוחצים אינטר, נשלחת בקשה לשרת ה-DNS שלנו. איזה שרת בדיוק? זה תלוי. בהנחה שלא שיניתם את הגדרות ה-DNS אצלכם (בראוטר/מחשב/פלאפון וכו&amp;rsquo;), אתם משתשמשים בשרתי ברירת המחדל שהם השרתים של ספקית האינטרנט שלכם (שזה צעד ממש לא חכם, אבל זה לפוסט אחר).&lt;/p>
&lt;p>השרת הזה נקרא DNS recursive resolver ואפשר להסתכל עליו כמעיין ספרנית שמקבלת שאילתא (query) ואז הולכת לחפש את הספר שמתאים לה (כתובת דומיין) על ידי סדרה של בקשות בשביל למצוא את המיקום המדויק.&lt;/p>
&lt;p>התחנה הראשונה היא שרת Root Nameserver. השרת הזה למעשה מפנה את הספרנית למדור הנכון בספריה, שהוא ה-TLD (Top Level Domain) Nameserver המתאים או במילים אחרות- לשרת המתאים לסיומת הדומיין. בדוגמה שלwikipedia.org, ה-Root יפנה אותנו (כלומר את ה-DNS resolver) ל-TLD Nameserver שמתאים לסיומת org.&lt;/p>
&lt;p>מהרוט אנחנו מגיעים ל-TLD Nameserver המתאים. ה-TLD NS הוא למעשה המדף המתאים בספריה שמכיל את כל הספרים בקטג&amp;rsquo; שביקשנו, או במקרה שלנו את כל הדומיינים עם סיומת org. ה-TLD NS מוצא את הרשומה של wikipedia.org ומפנה אותנו עם המידע הזה ל-Authoritative Nameserver, או לספר הספציפי.&lt;/p>
&lt;p>השלב האחרון במסע שלנו מגיע כשה-resolver שולח בקשה ל-Authoritative Nameserver. ה-Autoritative NS מספק לו את המידע שהוא בדמות רקורד DNS מלא שכולל את כתובת ה-IP המתאימה וכל תת כתובת אחרת שנחוצה וההפניות שלה (לדוגמה תת דומיין שמפנה למקום אחר).&lt;/p>
&lt;p>מכאן ה-DNS resolver חוזר למחשב שלנו, מצויד בכתובת ה-IP של האתר שביקשנו. הדפדפן שולח בקשת HTTP לשרת ומקבל בחזרה את העמוד המבוקש. בנוסף לכך, גם ה-resolver וגם המחשב שלנו ישמרו את הבקשה הזו ב-cache כדי לחסוך את הטיול הזה בפעם הבאה שאנחנו צריכים את כתובת ה-IP של האתר.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">למה JWT הוא ערק ערק ככה חזק?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/jwt/"/><id>https://neocode.blog/posts/jwt/</id><updated>2020-09-08T19:00:46+03:00</updated><published>2020-08-13T17:01:42+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">אוטנטיקציה דרך קוקיז עובדת לא רע בכלל לאתרים, וקשה להצביע על יתרונות אבסולוטים למעבר אל אוטנטיקציה דרך JWT. אבל זה, כמובן, כשהאתר הוא אתר, ושהוא נתמך ע&amp;quot;י דפדפנים שתומכים בקוקיז. מה עם אפליקציות נייטיב, שאין להן תמיכה של קוקיז? כאן JWT זורח.</summary><content type="html">&lt;p>אוטנטיקציה דרך קוקיז עובדת לא רע בכלל לאתרים, וקשה להצביע על יתרונות אבסולוטים למעבר אל אוטנטיקציה דרך JWT. אבל זה, כמובן, כשהאתר הוא אתר, ושהוא נתמך ע&amp;quot;י דפדפנים שתומכים בקוקיז. מה עם אפליקציות נייטיב, שאין להן תמיכה של קוקיז? כאן JWT זורח.&lt;/p>
&lt;p>למען הסר ספק, ההבדלים בין Authentication, Authorization הן ש-authentication הוא הזדהות (מי אתה?), ו- authorization הוא &amp;ldquo;אם אתה רוצה לקנות ערק תראה לי שאתה 21+&amp;rdquo; (הרשאה).&lt;/p>
&lt;p>אז הביטוי JWT נקרא Json Web Token, והמימוש שלו חמוד לאללה. JWT זה טוקן הנראה כגוש האש גדול, המופרד ל-3 חלקים בעזרת נקודה חמודה.&lt;/p>
&lt;p>הסטרינג הראשון, הוא בד&amp;quot;כ json בעצמו שמכיל מידע על האלגוריתם האש שהשתמשו בטוקן כדי לחתום אותו. הסטרינג השני, שהוא גם בד&amp;quot;כ Json, הוא המידע עצמו שרוצים לשמור כדי שהמשתמש יוכל להזדהות (כמו ID של המשתמש, תאריך תפוגה ועוד&amp;rsquo;).&lt;/p>
&lt;p>שני ה- jsonים מקודדים לסטנדרט של base64url, ו&lt;em>אינם&lt;/em> מוצפנים, כמובן. כל אחד יכול לפענח את שני הסטרינגים הללו ולקרוא את המידע. מכאן, מגיע הבטיחות בחלק השלישי של הטוקן: החתימה.&lt;/p>
&lt;p>הרעיון של הטוקן הוא לא להעביר מידע מוצפן (לפחות לא JWT סימטרי), אלא לוודא שאף אחד לא &lt;em>משנה&lt;/em> את המידע. בשביל לוודא זאת, לוקחים את החלק הראשון (שנקרא גם header), החלק השני (שנקרא גם payload), מחברים אותם לסטרינג אחד, מוסיפים לו מפתח שקיים אצל השרת &lt;em>בלבד&lt;/em>, ומהאהשים בהתאם להגדרות האלגוריתם של החלק הראשון (ה-header). התוצאה: סטרינג, או &amp;lsquo;חתימה&amp;rsquo; שהיא החלק האחרון בטוקן. וזה, מוודא לנו שאף אחד לא נגע בטוקן. מי שיצר אותו יקבל את אותו הטוקן ללא שינויים זדוניים.&lt;/p>
&lt;p>מכיוון שרק לשרת יש את המפתח שאנחנו מוסיפים לחתימה, אף אחד אחר לא יכול לייצר את החתימה, ולכן אף אחד לא יוכל לעבוד על השרת. כשהשרת מקבל את הטוקן, הוא פועל שוב ע&amp;quot;פ ההוראות למעלה, ומוודא שהחתימה שיוצאת לו, היא אותה חתימה המתקבלת בטוקן. לא- מחזיר 401, כן- יאללה ערק.&lt;/p>
&lt;p>המקרה בו יש רק מפתח אחד, נקרא JWT סימטרי. כלומר, קיים רק מפתח אחד (&amp;lsquo;פרטי&amp;rsquo;) שיכול לאשר את החתימה, ובשביל שעוד שרתים יוכלו לאשר את הטוקן, צריך לפזר את המפתח ביניהם. זה בד&amp;quot;כ מתכון לפירצות אבטחה, כשאם שרת אחד נפרץ, כל השרתים שמחזיקים את המפתח נמצאים בסכנה.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">למה חיפוש בינארי קיים או עדיף, למה בעצם להסתבך עם עצים בינארים?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/binary-search-and-binary-trees/"/><id>https://neocode.blog/posts/binary-search-and-binary-trees/</id><updated>2020-09-08T19:04:12+03:00</updated><published>2020-08-10T17:04:00+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">כדי למדוד מהירות (פוטנציאל) אלגוריתמי כלשהיא, אנחנו נאלצים לבודד את המשתנים אשר מפריעים לנו למדוד את הפוטנציאל הטהור של האלגוריתם, כמו לבודד את המכונה מהמשוואה. איננו רוצים שאלגוריתם יהיה מהיר יותר כי יש לך את ה- AMD Ryzen החדש. בשביל זה יש לנו את הסיבוכיות- המודדת את כמות האופרציות שאלגוריתם מבצע, וכך נוכל להעריך גם את הפוטנציאל.</summary><content type="html">&lt;p>כדי למדוד מהירות (פוטנציאל) אלגוריתמי כלשהיא, אנחנו נאלצים לבודד את המשתנים אשר מפריעים לנו למדוד את הפוטנציאל הטהור של האלגוריתם, כמו לבודד את המכונה מהמשוואה. איננו רוצים שאלגוריתם יהיה מהיר יותר כי יש לך את ה- AMD Ryzen החדש. בשביל זה יש לנו את הסיבוכיות- המודדת את כמות האופרציות שאלגוריתם מבצע, וכך נוכל להעריך גם את הפוטנציאל.&lt;/p>
&lt;p>חיפוש בינארי הוא &lt;em>עוד&lt;/em> אלגוריתם שנולד מתוך הרצון לחתוך כמה שיותר את כמות האופרציות בזמן חיפוש, והקונספט שלו דומה לחיפוש בספרי דפי זהב שפעם היה לכולנו. במקום לחפש איבר אחד אחרי השני, אנחנו חותכים את החיפוש ספציפית לאות שבה מתחיל השם שאנחנו מחפשים. זה כל כך אפקטיבי, שאנחנו יכולים למצוא שם של אדם תוך כמה שניות, מאשר אפילו כמה שעות.&lt;/p>
&lt;p>יש לציין, שאי אפשר לבצע חיפוש בינארי עם הרשימה לא מסודרת. לא נוכל לחפש לפי אות אם האותיות לא מסודרת לפי ה- א&amp;rsquo; ב&amp;rsquo;.&lt;/p>
&lt;p>המשמעות של בינארי, אגב, פירושו יחס בין 2 פרטים. 0 או 1. זה או זה. פה או שם. ומכאן השם של חיפוש בינארי-אם לא פה אז אולי שם.&lt;/p>
&lt;p>אז הקונספט של חיפוש בינארי הוא דיי קליל. ניקח מערך מספרים ממויין, ונחפש ספרה כלשהיא. נתחיל מהאמצע- אם הספרה לא שווה, האם היא גדולה מן הספרה האמצעית? אם כן, נחתוך את הרשימה בחצי ונתחיל שוב, וכך הלאה. המעבר של &amp;ldquo;לחתוך בחצי&amp;rdquo; את המערך נותן לנו סיבוכיות של logn, במקום סיבוכיות של n, בה נצטרך לעבור איבר איבר במערך (דמיינו מעבר לפי שם שם בדפי זהב לפי הסדר של הא&amp;rsquo; ב&amp;rsquo;).&lt;/p>
&lt;p>הפונקציה &amp;lsquo;log&amp;rsquo; היא שיטה נעימה (או פחות?) יותר לשאלה: הבסיס בחזקת מה, ייתן לי את המספר x? בדר&amp;quot;כ כשרואים &amp;lsquo;רק&amp;rsquo; את המילה log, מתכוונים לבסיס 2.
כלומר, כמות הפעמים שנחתוך את המערך עד למציאת האיבר שלנו, היא &lt;em>במקרה הכי גרוע&lt;/em> פשוט החזקה. אם המערך שלנו הוא באורך 8, ייקח לנו במקסימום 3 פעמים שנצטרך לחתוך ולמצוא את האיבר שלנו.&lt;/p>
&lt;p>זה נהיה קריטי כשהמערך גדל מעריכית, אבל כמות האופרציות נשארת כפונקציה לוגריתמית.&lt;/p>
&lt;p>ומכאן אפשר לשאול, יש לנו חיפוש בינארי- למה צריך עץ בינארי? עץ בינארי גם מאפשר לנו חיפוש בlogn, אבל כמובן רק אם הוא עץ מאוזן (כדוגמת עצי AVL, אדום שחור). אם העץ אינו מאוזן, הוא &lt;em>יכול&lt;/em> לתת לנו חיפוש ב- logn, אבל החיפוש יכול להיות לינארי (בהתאם לכמות האיברים, n). לעומת זאת אם הוא מאוזן, הוא &lt;em>מבטיח לנו תמיד&lt;/em> חיפוש בlogn.&lt;/p>
&lt;p>היתרון שיש לעצים בינארים מאוזנים על פני חיפוש בינארי, הוא דווקא בהכנסה וההוצאה (insert, remove). בעצים בינארים מאוזנים גם ההכנסות וההוצאות נשארים logn (על אף שהם צריכים לאזן את עצמם), בזמן שבמערכים ההכנסה וההוצאה היא לינארית, בהתאם ל- n ולמיקום במערך שיש להוסיפה.&lt;/p>
&lt;p>לכן, המימוש של עצים בינארים יהיה מהיר יותר למקרים בהם לא רק יש צורך לחפש, אלא לבצע מניפולאציה כבדה על האיברים במערך.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">האם מיקרוסרביסים היא ארכיטקטורת העתיד?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/microservices/"/><id>https://neocode.blog/posts/microservices/</id><updated>2020-09-08T19:06:38+03:00</updated><published>2020-08-02T17:05:35+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">למעשה, מיקרוסרביסים כבר תפס חלק נכבד (אבל לא אבסולוטי) מארכיטקטורת הצד שרת של היום, אז השאלה הנכונה יותר לשאול היא &amp;lsquo;האם היא כאן להישאר&amp;rsquo;.
ההפך הגמור ממיקרוסרביסים היא ה&amp;rsquo;מונולית&amp;rsquo; הידועה (כלומר monolith), שהיא &amp;ldquo;הכל במקום אחד&amp;rdquo;. גם ה- UI, גם הלוגיקה של השרת, הכל- מודבקים עם סלוטייפ ביחד תחת unit אחד הפונה לדטאבייס אחד.</summary><content type="html">&lt;p>למעשה, מיקרוסרביסים כבר תפס חלק נכבד (אבל לא אבסולוטי) מארכיטקטורת הצד שרת של היום, אז השאלה הנכונה יותר לשאול היא &amp;lsquo;האם היא כאן להישאר&amp;rsquo;.&lt;/p>
&lt;p>ההפך הגמור ממיקרוסרביסים היא ה&amp;rsquo;מונולית&amp;rsquo; הידועה (כלומר monolith), שהיא &amp;ldquo;הכל במקום אחד&amp;rdquo;. גם ה- UI, גם הלוגיקה של השרת, הכל- מודבקים עם סלוטייפ ביחד תחת unit אחד הפונה לדטאבייס אחד.&lt;/p>
&lt;p>מיקרוסרביסים נולד מתוך האנליות של &amp;lsquo;single responsibility&amp;rsquo; שמתעקשת(ובצדק) לבודד את כל הלוגיקה למודולים נפרדים, שאינם תלויים באופן מוחלט, ואינם דבוקים אחד בשני.&lt;/p>
&lt;p>במיקרוסרביסים, כל לוגיקה או מודול מחולקים ל&amp;rsquo;סרביסים&amp;rsquo; שונים, שכל אחד פונה לדטאבייס משלו. כל סרביס יכול להיות כתוב בשפה אחרת, תחת כל רציונל שהוא רוצה (כל עוד אפשר לתקשר איתו). כל סרביס יכול להיות שרת שרץ על מכונה נפרדת או להשתתף תחת אותה מכונה תוך שימוש בפורטים שונים כד לגשת אליהם.&lt;/p>
&lt;p>היתרון הבולט של מיקרוסרביסים הוא היכולת לפזר מפתחים לסרביסים שונים, מבלי להתחיל לקבל מרק של קונפליקטים, כשבמונולית המפתחים היו נוגעים בצלחת האחד של השני. הדילוור (delivery) של פיצ&amp;rsquo;רים חדשים הופך למשמעותית קל ומהיר יותר.&lt;/p>
&lt;p>היתרון העצום השני, הוא היכולת לבצע scaling רק לסרביסים החמים שמשתמשים בהם הכי הרבה. בניגוד למונולית, שם אתה צריך להיגרר להרחבת השרת ו\או הזיכרון של כל השרת רק בגלל לוגיקה ספציפית אחת, למשל.&lt;/p>
&lt;p>היתרון האחרון(בערך) נובע מה-single responsibility, שמפרידה את המודולים אחד מהשני ומצמצמת קשירות בקוד.&lt;/p>
&lt;p>אבל בפיתוח (לפחות), לכל פתרון יש מחיר. והמחיר של מיקרוסרביסים הוא לא כל כך זול.&lt;/p>
&lt;p>ראשית, מיקרוסרביסים כמעט תמיד תהיה איטית יותר מכל ארכיטקטורה מונוליתית. אם במונולית המודולים תקשרו אחד עם השני דרך הזיכרון, התקשור עכשיו עובר לתקשורת דרך הרשת. אם אתה צריך לוגיקה, מידע או כל שירות אחר- אתה צריך לבצע קריאת HTTP לסרביס האחר, או לכמה סרביסים. פיתוחים כגון HTTP2 או מימושים מתוחכמים של parallelism קיימים ואולי עשויים להפוך את הבדלי המהירות לredundant, אבל עדיין מיקרוסרביסים איטית יותר.&lt;/p>
&lt;p>המחיר השני הוא הקושי לפתח. זה לא פשוט בכלל לתכנן סרביסים השונים אחד מהשני, כשכל אחד תלוי במידע מסרביס אחר. איך לגשת למידע? איך לקבל את המידע? הרבה סרביסים יהיו תלויים במידע מסרביסים שונים, ומימוש לא נכון יכול להפוך לסיוט מהלך על 10.&lt;/p>
&lt;p>יש לציין, המונח &amp;lsquo;מיקרוסרביסים&amp;rsquo; הוא מונח כללי שאינו מתאר רק ארכיטקטורת צד שרת. יש hype גם בתחומים אחרים כמו למשל micro frontend.&lt;/p>
&lt;p>עכשיו נותר רק לשאול, אצלכם עובדים עם מיקרוסרביסים או מונולית?&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">לכידות(cohesion) או; איך לסדר מגירה כמו שצריך.</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/cohesion/"/><id>https://neocode.blog/posts/cohesion/</id><updated>2020-09-08T19:00:38+03:00</updated><published>2020-07-29T17:06:52+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">הכוונה בלכידות היא עד כמה הרכיבים קשורים אחד לשני, בתוך מודול ספציפי. ככל שהלכידות &amp;lsquo;גבוהה&amp;rsquo; יותר, ככה &amp;lsquo;יותר טוב&amp;rsquo;.
במחלקה למשל, לכידות נמדדת ע&amp;quot;פ כמה כל הפונקציות משתמשות בכמה שיותר משתנים הקיימים בה. ככל שכל הפונקציות משתמשות בכמה שיותר משתנים בתוך המחלקה, כך הסממן ברור: הקשר בין המשתנים לפונקציונאליות של המחלקה חזקים יותר ולהיפך.</summary><content type="html">&lt;p>הכוונה בלכידות היא &lt;em>עד כמה&lt;/em> הרכיבים קשורים אחד לשני, בתוך מודול ספציפי. ככל שהלכידות &amp;lsquo;גבוהה&amp;rsquo; יותר, ככה &amp;lsquo;יותר טוב&amp;rsquo;.&lt;/p>
&lt;p>במחלקה למשל, לכידות נמדדת ע&amp;quot;פ כמה כל הפונקציות משתמשות בכמה שיותר משתנים הקיימים בה. ככל שכל הפונקציות משתמשות בכמה שיותר משתנים בתוך המחלקה, כך הסממן ברור: הקשר בין המשתנים לפונקציונאליות של המחלקה חזקים יותר ולהיפך.&lt;/p>
&lt;p>עוד מדד ללכידות, היא עד כמה הפונקציות במודול משרתות מטרה ברורה ומוגדרת. ככל שהמחלקה(למשל) שואפת להיות יותר פונקציונאלית ולצאת מתחום האחריות הברורה שלה, היא מאבדת מהשופטים נקודות (דוגמא קונקרטית: מתכנת, שאחראי לכתוב קוד, ועכשיו גם צריך לנקות את השירותים- זוהי הפרה ברורה של הגדרת המטרה שלו!).&lt;/p>
&lt;p>ולמה זה כל כך משנה? אז לכידות מתקשרת באופן עקיף ל&amp;rsquo;צמידות&amp;rdquo;, או בשפה העממית tight coupling. נגיד שאתם פותחים מגירת סכו&amp;quot;ם במטבח ומגלים שכל המגירה מבולגנת מהיסוד- מזלגות מעל הכפות וסכינים מעל הצלחות. לא רק שיהיה קשה לסדר את המגירה, היא לא ברורה בעליל. עכשיו תתארו שהמגירה מסודרת להפליא. מזלגות איפה שהמזלגות, וסכינים איפה שהסכינים. הכל מסודר, אפשר להכניס בקלות סכו&amp;quot;ם חדש למגירה.&lt;/p>
&lt;p>לכידות היא עוד מדד מרכזי ב- oo (הלוא object oriented) המאפשר לנו להוריד את הסמתוכה ש-oo מעודד אותנו לייצר, ולשמור על מודולים (ו\או מחלקות במקרה שלנו) מלהיות צמודים ותלויים אחד בשני. ככל שתחום האחריות מופרד אחד מהשני, קל יותר להבין את המערכת, לדבאג אותה ולשנות\להוסיף. או במילים פשוטות יותר: המתכנתים יזדקנו לאט יותר.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">הממ…To comment or not to comment?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/to-comment-or-not-to-comment/"/><id>https://neocode.blog/posts/to-comment-or-not-to-comment/</id><updated>2020-09-08T19:00:44+03:00</updated><published>2020-07-27T17:08:19+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">פעם, המנטרה הייתה ברורה- קוד עם דוקומנטציה ברורה ומסודרת לכל דבר. היום משום מה, הגישה הזאת התעדנה קצת.
הגישה היום הולכת ככה: הערות זה רע. התוצאה: רואים הרבה מאוד מערכות שלפעמים לא נמצא שורת comment אחת.
האם זה תקין? אולי. האם commenting הפך לילד רע?</summary><content type="html">&lt;p>פעם, המנטרה הייתה ברורה- קוד עם דוקומנטציה ברורה ומסודרת לכל דבר. היום משום מה, הגישה הזאת התעדנה קצת.&lt;/p>
&lt;p>הגישה היום הולכת ככה: הערות זה רע. התוצאה: רואים הרבה מאוד מערכות שלפעמים לא נמצא שורת comment אחת.&lt;/p>
&lt;p>האם זה תקין? אולי. האם commenting הפך לילד רע? לא בדיוק.&lt;/p>
&lt;p>נתחיל ממקרה קלאסי של נגד הערה: מפתח כתב פונקציה, תיעד כמה שורות יפות ומתובלנות את הביצוע של הקוד, והמשיך לדרכו. כמה ימים אח&amp;quot;כ, תיקן באג, שינה שורה או שתיים, והמשיך לדרכו. אבל רגע, מה עם הדוקומנטציה? אופסי.&lt;/p>
&lt;p>ברגע שמתכנת צריך לתעד ולכתוב דוקומנטציה מלאה לכל קוד\פונקציה, הוא ממש מבצע חתונה קתולית בינו לבין הקוד וההערות. יד ביד, כמו זוג אוהבים, הוא ייצטרך לתחזק גם את הקוד וגם את ההערות. זה יוצר עומס, בלבול, שגיאות וכמובן עצבים. וזה לא אמור להיות ככה.&lt;/p>
&lt;p>בעיה נוספת שהערות מייצרות לנו היא&amp;hellip;זמן. לכתוב הערות לכל דבר לא יתרום אף פעם ליכולת של הקוד, או לביצוע של הקוד. אם זמן הוא מרכיב קריטי בפיתוח, צריך ממש לשקול לדלג על שלב כתיבת ההערות.&lt;/p>
&lt;p>הגישה שהתפתחה לה כיום כנגד כתיבת הערות נקראת ROC, כלומר: Really Obvious Code. שהקוד ידבר בפני עצמו, יהיה ברור ומסודר. מי שיירצה להבין איך הקוד עובד, צריך להסתכל על הקוד ולא על הסיפור שמעליו.&lt;/p>
&lt;p>אז האם לכתוב הערות הפך לboogyman של המפתחים היום? אז לא, לא בדיוק.&lt;/p>
&lt;p>יש מקומות בהם דווקא כן צריך דוקומנטציה ברורה, למשל ב- public API, librarys, שם אתה זקוק שהמשתמש יבין את המימושים השונים ולא יילך לאיבוד. אבל גם שם אפשר ללכת בגישה קצת אחרת מאשר משל של ארנב וצב מעל כל פונקציה. הגישה אומרת כך: כתוב מה הפונקציה &lt;em>צריכה&lt;/em> לעשות, ולא &lt;em>מה היא עושה&lt;/em>. את הפונקציונאליות של הקוד משאירים לקוד עצמו, ואת הפילוסופיה מאחוריה- להערות.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">Composition Over Inheritance?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/composition-over-inheritance/"/><id>https://neocode.blog/posts/composition-over-inheritance/</id><updated>2020-09-08T19:00:38+03:00</updated><published>2020-07-23T17:09:42+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">בפעם הראשונה שבניתי פרוייקט (ובמקרה הוא היה בג&amp;rsquo;אווה), הוא ככל הנראה היה הפרוייקט הכי שאפתני שלי; ניסיתי למפות את גוף האדם. ההשראה נבעה מהיכולת של Inheritance, שאיפשרה לי ליצור קשרים ויחסים בין אובייקטים.
מיותר לציין שהפרוייקט נגנז לאלתר, בעיקר בגלל קש קטן שהפך את כל הקשרים והיחסים שבניתי.</summary><content type="html">&lt;p>בפעם הראשונה שבניתי פרוייקט (ובמקרה הוא היה בג&amp;rsquo;אווה), הוא ככל הנראה היה הפרוייקט הכי שאפתני שלי; ניסיתי למפות את גוף האדם. ההשראה נבעה מהיכולת של Inheritance, שאיפשרה לי ליצור קשרים ויחסים בין אובייקטים.&lt;/p>
&lt;p>מיותר לציין שהפרוייקט נגנז לאלתר, בעיקר בגלל קש קטן שהפך את כל הקשרים והיחסים שבניתי. הירושה דפקה את הכל.&lt;/p>
&lt;p>לירושה יש הרבה יתרונות, אבל יש לה מספר חסרונות מצומצם, והרסניות. מביניהן, והפופולארית- אנחנו לא תמיד יכולים (או צריכים) ליצור קשר של אב-בן בצורה נכונה, כזאת שתואמת לעולם האמיתי. ברגע שנוצר צורך שאינו תואם ליחס שבנינו, הכל מתחיל להתפורר לנו ומתחיל שלב ה refactorrrr.&lt;/p>
&lt;p>מאז השרשתי את המושג הרכבה מעל ירושה- במקום ליצור קשר בין אובייקטים בעזרת ירושה, אפשר בעזרת הרכבה (לשתול רפרנס של &amp;ldquo;היחס&amp;rdquo; בתור אובייקט כפרופרטי במחלקה). זה מאפשר גמישות כשאתה רוצה לשנות את היחס, ופלוס קטן הוא שאפשר להחביא את הגישה לאובייקט, כלומר encapsulate, יתרון שאין לנו בירושה (לא תוכל להחביא את הגישה ל-human בירושה כשאתה משתמש באובייקט של person).&lt;/p>
&lt;p>פגשתי מתכנתים שנשבעים לא להשתמש בירושה בכלל- ולא בטוח שזאת גישה נכונה. לירושה יש את היתרונות שלה, במיוחד במניעת חזרה על הקוד.&lt;/p>
&lt;p>אני בד&amp;quot;כ לא מאמין בשחור ולבן- יש הרבה צבעים מסביב כשזה קשור לכתיבת קוד, ו&amp;quot;לשלב&amp;rdquo; זאת לא בהכרח מילה גסה בפיתוח.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">Functional Programming</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/functional-programming/"/><id>https://neocode.blog/posts/functional-programming/</id><updated>2020-09-08T19:00:41+03:00</updated><published>2020-07-22T17:10:53+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">אולי Functional Programming נשמע כמו שיעור סטודיו בחדר כושר, אבל למרות שהשם שלו נשמע מיינסטרימי, יש פילוסופיה שלמה ומעניינת מאחוריה.
המוטיב המרכזי שחוזר: פונקציות. לפשט את הכל לפונצקיות, ולהתייחס אל פונקציות בעדינות וחוכמה. כל קטע קוד שקיים במערכת, צריך להיות עטוף כפונקציה המבצעת פעולה אחת פשוטה, תוך קבלת קלט, ופליטת פלט כלשהו.</summary><content type="html">&lt;p>אולי Functional Programming נשמע כמו שיעור סטודיו בחדר כושר, אבל למרות שהשם שלו נשמע מיינסטרימי, יש פילוסופיה שלמה ומעניינת מאחוריה.&lt;/p>
&lt;p>המוטיב המרכזי שחוזר: פונקציות. לפשט את הכל לפונצקיות, ולהתייחס אל פונקציות בעדינות וחוכמה. כל קטע קוד שקיים במערכת, צריך להיות עטוף כפונקציה המבצעת פעולה אחת פשוטה, תוך קבלת קלט, ופליטת פלט כלשהו.&lt;/p>
&lt;p>הרעיון מאחורי המוטיב לקוח מהגישה המתמטית: הפונקציה מבצעת פעולה אחת, אתה יודע מה היא, ומה תהיה התוצאה בהתאם לקלט.
ובקוד, זה מתבטא בכך שאתה לא צריך &amp;ldquo;לדבאג&amp;rdquo; את הפונקציה ולהבין מה לא בסדר איתה, אלא אמור לקחת בחשבון שהיא &lt;em>עובדת כמו שצריך&lt;/em> (אם נכתב כמו שצריך), וגם ברורה בדיוק מה היא עושה, כך שאתה בכלל לא צריך להתחיל להיכנס לכל פונקציה בקוד. כל הבעיות שיכולות &amp;ldquo;לצוץ&amp;rdquo; צריכות להיות קשורות בשרשור והלוגיה של הפונקציות, ולא בפונקציות עצמן.&lt;/p>
&lt;p>בנוסף, בתכנות פונקציונאלי (שאתייחס כ-FP) כל האובייקטים הם immutable, כלומר ברגע שמייצרים אותם, אסור לשנות אותם. אם אתה רוצה לערוך אותם, תצטרך להחזיר עם פונקציה אובייקט חדש עם הערכים החדשים. לחידוד, להעביר כקלט את האובייקט לפונקציה ולערוך את האובייקט בתוך הפונקציה
עצמה לא מתקבל בחשבון.&lt;/p>
&lt;p>וכמובן, שאין יותר forloop, במיוחד fori (בגלל שהוא מבצע שינוי סטייט ל-i!), ובכדי לבצע איטרציה כלשהיא, משתמשים ברקורסיה (בכל זאת, אני ראיתי מספיק מתכנתיי FP שעדיין משתמשים בforeach, ולא נראה שהעולם קרס להם).&lt;/p>
&lt;p>לסיום, ל-FP יש מה לומר גם על error handling &amp;amp; null. מכיוון שפונקציות ב-FP הן כמו אלגברה, אין לך בדיוק ערך של NULL. השיטה המקובלת היא לעטוף את הערך המוחזר באובייקט כלשהוא, ולבדוק אם יש בו ערך (או לקרוא לפונקציה מתאימה). בשפות שמשרישות פילוסופיה FPית (כמו קוטלין וסקאלה) זה קצת יותר מחומם מזה.&lt;/p>
&lt;p>כדי למנוע אקספשיינס, ב-Go הפכו כל שגיאה לערך בפני עצמו. אתה כבר לא מקריס את האפליקציה כשנוצרת לך השגיאה, אלא מחזיר אותה בפונקציה כערך בפני עצמו (בדר&amp;quot;כ כסוג של Tupel) ונותן לקורא הפונקציה להסתבך עם עצמו. האם זה יעיל? אולי, אבל דורש המון שכפול קוד.&lt;/p>
&lt;p>בתמונה: קטע מאימון פונקציונאלי שרשורי, וקצת קריא יותר. החדי קרן מבינינו יבחינו שאפשר לקצרר את השורה עוד יותר.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry></feed>