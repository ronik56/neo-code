<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="he"><title type="text">NeoCode</title><subtitle type="html">קהילה חדשה ומודרנית המנסה לעשות סדר בעולם הפיתוח, ובמיוחד איך לכתוב קוד.</subtitle><updated>2020-09-13T19:30:34+03:00</updated><id>https://neocode.blog/</id><link rel="alternate" type="text/html" href="https://neocode.blog/"/><link rel="self" type="application/atom+xml" href="https://neocode.blog/atom.xml"/><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><generator uri="https://gohugo.io/" version="0.74.3">Hugo</generator><entry><title type="text">על NAT</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/nat/"/><id>https://neocode.blog/posts/nat/</id><updated>2020-09-13T19:24:50+03:00</updated><published>2020-09-12T08:30:00+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">איך שורדים עם רק 4 מיליארד כתובות IP לכל האינטרנט? NAT!
כשאנחנו משתמשים באינטרנט אנחנו זקוקים לכתובת IP. כמו דואר רגיל, יש צורך בנמען ומוען- גם למחשב ששולח בקשה וגם לשרת שאליו היא נשלחת צריכה להיות כתובת IP כדי שידעו איך לתקשר ביניהם.</summary><content type="html">&lt;p>איך שורדים עם רק 4 מיליארד כתובות IP לכל האינטרנט? NAT!&lt;/p>
&lt;p>כשאנחנו משתמשים באינטרנט אנחנו זקוקים לכתובת IP. כמו דואר רגיל, יש צורך בנמען ומוען- גם למחשב ששולח בקשה וגם לשרת שאליו היא נשלחת צריכה להיות כתובת IP כדי שידעו איך לתקשר ביניהם. בפרוטוקול ה-IP הנוכחי, IPv4, יש קצת יותר מ-4 מיליארד כתובות IP זמינות לשימוש, שזה בבירור לא מספיק לכמות המכשירים המחוברים לאינטרנט. מסיבה זו פותח פרוטוקול IPv6 שמגדיל את מספר הכתובות הזמינות לשימוש מ-4 מיליארד ל-340 undecillion, שזה 340 ואז 36 ספרות אחריו (340,282,366,920,938,463,463,374,607,431,768,211,456). אבל גם היום IPv6 לא בשימוש רחב מספיק ולא כולם תומכים בו. אז איך שרדנו עד עכשיו?&lt;/p>
&lt;p>קודם כל, חשוב להבדיל בין שני סוגי כתובות IP: ציבוריות ופרטיות. כתובות IP ציבוריות רשומות באופן פומבי וכולם יכולים לגשת אליהן. כתובת ה-IP של הראוטר שלכם ושל השרת שאתם ניגשים אליו היא כתובת ציבורית. לעומת זאת, כתובות IP פרטיות לא רשומות באופן פומבי וניתן לגשת אליהן רק בתוך הרשת, כלומר רק בתוך הבית או העסק.&lt;/p>
&lt;p>ניקח לדוגמה את הרשת הביתית שלכם. הראוטר שלכם מקבל כתובת IP מהספקית שלכם. בשביל לחסוך 10-20 כתובות IP לכל מכשיר שמחובר לרשת הביתית שלכם, הראוטר משתמש בטכניקה שנקראת NAT (Network Address Translation). הראוטר מחלק לכל המכשירים שמחוברים אליו כתובות פרטיות, ששייכות לכמה טווחים שנקבעו לשימוש זה- כל הכתובות מהצורה &lt;div dir="ltr">10.X.X.X&lt;/div>, כל הכתובת מהצורה &lt;div dir="ltr">172.16-31.X.X&lt;/div> וכל הכתובות מהצורה &lt;div dir="ltr">192.168.X.X&lt;/div>, קצת פחות מ-18 מיליון בסך הכל. בטווח האחרון לדוגמה, המחשב יהיה עם הכתובת 192.168.0.1, הפלאפון 192.168.0.2 וכו&amp;rsquo;. כשאתם תגישו בקשה לאינטרנט, בעזרת ה-NAT הראוטר ימיר את הכתובת הפרטית לכתובת הציבורית ולכן כלפי חוץ כל המכשירים ברשת יחלקו אותה כתובת IP. ה-NAT עובד גם בכיוון השני, כשהבקשה חוזרת מהאינטרנט לכתובת הציבורית של הראוטר ואז בעזרת ה-NAT הראוטר מעביר אותה לכתובת הפרטית הנכונה, בין אם זה למחשב או לפלאפון.&lt;/p>
&lt;p>יש ארבעה סוגים או יישומים עיקריים של NAT:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>SNAT - Static NAT: מדובר ב-NAT שמספק כתובת IP ציבורית קבועה לכל כתובת IP פנימית. אם להמשיך עם הדוגמה שלמעלה, אז נוכל לשייך את הכתובת הציבורית 91.198.174.192 לכתובת 192.168.0.1 וכך כל מי שניגש לכתובת 91.198.174.192 ייגש למחשב שלנו (או עם דוגמה יותר ריאליסטית- שרת FTP). כל מי שיגש לכתובת 91.198.174.193 יופנה לכתובת 192.168.0.2, כלומר לפלאפון (או לשרת מייל). הכתובות לא חייבות להיות עוקבות כמובן. מדובר ב-NAT מאוד בזבזני והוא משמש בעיקר לתנועה נכנסת. המטרה העיקרית שלו היא לחשוף שרת עם כתובת IP פרטית לאינטרנט הציבורי.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DNAT - Dynamic NAT: בדומה ל-NAT סטטי גם DNAT מספק כתובת ציבורית לכל כתובת פרטית, אבל באופן קצת שונה. כאן הראוטר מחזיק במלאי של כתובת IP ובכל בקשה כתובת IP פנימית מנותבת לכתובת IP זמינה ברשימה. לדוגמה, אם נתחבר עם המחשב, כלומר עם 192.168.0.1, נקבל את הכתובת 83.2.3.1. לאחר מכן נתחבר עם הפלאפון, ונקבל את הכתובת 83.2.3.2 וכן הלאה, כשכל מכשיר מקבל כתובת פנויה מהרשימה של הראוטר וכתובות מתפנות אחרי שהמשתמש התנתק. גם גישה זו בזבזנית והיא משמשת בעיקר לצורכי תנועה יוצאת. שיטה זו למעשה מסתירה את ה-IP של המשתמשים ומקשה על תוקפים חיצונים לזהות אותו, שכן כתובת ה-IP שלו משתנה באופן תכוף. השימוש של DNAT הוא דומו בעיקרון ל-SNAT, כלומר מתן כתובת ציבורית לכל כתובת פרטית שלנו, אבל הוא נוח במיוחד כאשר אין חשיבות לאיזה מכשיר יקבל איזו כתובת ואז, במקרה שיש לנו 250 שרתים לדוגמה, במקום ליצור 250 רשומות SNAT נוכל לספק פשוט כתובות באופן דינמי בהתאם למה שזמין.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PAT - Port Address Translation: הצורה הכי נפוצה של ה-NAT. כאן לכל מכשיר ברשת הפנימית (פלאפון, מחשב) יש כתובת IP פרטית (192.168.0.1, 192.168.0.2) ולראוטר יש כתובת IP ציבורית (91.198.174.192). במעבר בין הרשת הפנימית לחיצונית, כתובת ה-IP הפרטית מוחלפת לכתובת IP ציבורית עם תוספת של פורט. לדוגמה פניה מהמחשב תגיע לראוטר ותצא ממנו בצורה 91.198.174.192:8001, והפניה מהפלאפון תצא בצורה 91.198.174.192:8002. כך ה-NAT יודע לנווט בקלות את הטראפיק ויודע איזה מידע אמור להגיע לאיזה מכשיר בדיוק. יש כ-65.5 אלף פורטים זמינים לשימוש, חלקם שמורים לשימושים מסוימים (לדוגמה 22 ל-SSH, כאשר 80 שמור ל-HTTP ו-443 ל-HTTPS וכו&amp;rsquo;), אך יש עשרות אלפים שזמינים לשימוש.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Port Forwarding: רלוונטית בעיקר כשיש רק כתובת IP ציבורית אחת, אבל מספר שרתים ציבוריים שצריכים לחלוק אותה, ולכן גם בעיקר רלוונטית כשמדובר בתנועה נכנסת. כך לדוגמה אם נרצה לגשת לשרת ה-FTP שלנו, שכתובת ה-IP הפרטית שלו היא (192.168.0.1) וכתובת ה-IP הציבורית שלנו היא 91.198.174.192, אז עם Port Forwarding נוכל להפנות כל גישה לכתובת 91.198.174.192:21 לשרת ה-FTP שלנו. בדומה נוכל להפנות את הכתובת 91.198.174.192:25 לכתובת 192.168.0.2 שמשתמשת את שרת המייל שלנו, את הכתובת 91.198.174.192:80 לשרת ה-Web שלנו שנמצא בכתובת 192.168.0.3 וכו&amp;rsquo;.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>ה-NAT כמובן לא חף מחסרונות. תרגום הכתובות לוקח זמן שיוצר דיליי ועלול לפגוע בביצועים (אם כי לא סביר שיורגש), תוכנות מסוימות עלולות לא לעבוד בגלל הגדרות לא נכונות, במיוחד אפליקציות שדורשות פורטים ספציפיים כמו שרתי Web או טורנטים.&lt;/p>
&lt;p>לסיכום, NAT זו טכנולוגיה שמתרגמת כתובות IP פרטיות וציבוריות ומאפשרת לנו לקבל אבטחה מוספת על ידי הסתרת כתובות IP של מכשירי קצה, להאריך את תוחלת החיים של ה-IPv4 על ידי חיסכון בכתובות ציבוריות ולהפריד את הרשת הפנימית שלנו מהרשת החיצונית. עם המעבר ל-IPv6 בעתיד הקרוב, לכל מכשיר קצה תהיה כתובת IP ציבורית משלו וה-NAT יהפוך מהר מאוד לנחלת העבר.&lt;/p></content></entry><entry><title type="text">Load Balancer</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/load-balancer/"/><id>https://neocode.blog/posts/load-balancer/</id><updated>2020-09-08T14:40:55+03:00</updated><published>2020-09-08T14:40:19+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">איך מתמודדים עם עומס על השרת(ים) כיום? אחת התשובות- Load Balancer.
הרעיון של Load Balancer בעצם נהפך להכרח אצל הרבה חברות עקב הפריצה הענקית של המשתמשים באינטרנט. פעם עוד היה אפשר להרים את המחשב של אמא בתור שרת בסיסי בסלון כמו צוקרברג, אבל מהר מאוד זה הפסיק להיות לו כפתרון לגיטימי.</summary><content type="html">&lt;p>איך מתמודדים עם עומס על השרת(ים) כיום? אחת התשובות- Load Balancer.&lt;/p>
&lt;p>הרעיון של Load Balancer בעצם נהפך להכרח אצל הרבה חברות עקב הפריצה הענקית של המשתמשים באינטרנט. פעם עוד היה אפשר להרים את המחשב של אמא בתור שרת בסיסי בסלון כמו צוקרברג, אבל מהר מאוד זה הפסיק להיות לו כפתרון לגיטימי. בכלל, כיום אתרים ואפליקציות מתמודדות עם ריבוי בקשות עצום. הפתרון, נמצא איפשהוא בין שני סוגים של scaling לפניות.&lt;/p>
&lt;p>הראשון: vertical scaling, שהוא אומר; שדרג את המכונה(שרת). תוסיף עוד RAM, תחליף ל- AMD RYZEN ותרביץ מכונה שתצליח לעמוד בריבוי הפניות. הבעיה הגדולה ביותר של זה היא שיש גבול עליון של כוח מחשובי שאפשר להגיע אליו יחסית מהר והגבול הזה גם ככה לא מספיק (לשרתים שמתקשים לעמוד בעומס).&lt;/p>
&lt;p>השני: horizontal scaling, שהוא אומר; שכפל את השרתים כך שיש ריבוי מכונות כדי שכולם יוכלו להתחלק עם הריבוי משתמשים\בקשות.&lt;/p>
&lt;p>הבעיה שנוצרה מ- horizontal scaling היא; איך לחלק את העבודה בין המכונות?, כלומר איך להחליט לאיזה שרת להפנות בקשה מסוימת. איך יודעים מתי שרת א&amp;rsquo; פנוי ושרת ב&amp;rsquo; לא פנוי?&lt;/p>
&lt;p>אז הרעיון של Load Balancer נועד לפתור בין היתר את הבעיות הנ&amp;quot;ל. Load Balancer בסיסי הוא כמו ראוטר, המפנה את הבקשות אל המכונות הרלוונטיים. בדר&amp;quot;כ זה יהיה שרת שמתפקד כמו reverse proxy (או כ). הוא יושב בתקשורת באמצע של הקליינט והשרת (או חוות שרתים).&lt;/p>
&lt;p>יש שני סוגים של Load Balancers פופולריים, L4 ו- L7. אז L4 מתייחס לכך שיש לו גישה רק לפורטים וה-IPים של הבקשה, ו7L מתייחס לכך שיש לו גישה לכל המידע בבקשת http (כמו body, routes, headers).&lt;/p>
&lt;p>זה אומר ש- 4L יכול לבצע את הלוגיקה של הניתוב רק בעזרת הפורטים וה-IPים של הבקשה. ה-4L מתרגם את התקשורת TCP ומחליף את ה-IP שלו עצמו (הנמען של הבקשה מהקליינט) עם ה-IP של השרת שהוא מחליט לנתב אליו את הבקשה. זה נקרא NAT – Network Address Translation.&lt;/p>
&lt;p>ל-L7 יש גישה למידע של הבקשה ולכן הוא יכול לבצע יותר לוגיקה בהתאם למידע. לדוגמה, להחזיר 401 כשה- authorization header של הבקשה ריק או לא תקין. L7 יודע גם לנתב בהתאם ל-routes, למשל ב- GET /images הוא ינתב לשרת הרלוונטי שמחזיר תמונות.&lt;/p>
&lt;p>ל- L7 יש 2 תקשורות TCP, אחת של הקליינט, ואחת שהוא מייצר עם השרת המנותב. הסיבות ליצירת התקשורת השנייה היא למשל בשינוי המידע בפניה, ואז העברת המידע החדש עם התקשורת החדשה. בנוסף, הרבה פעמים L7 מיושם גם כ- SSL Termination Gateway (פיענוח של המידע המוצפן) במקום שהשרתים יצטרכו להיות up to date עם התעודות SSL שלהן. 7L הוא reverse proxy קלאסי עם יכולות ניתוב.&lt;/p>
&lt;p>יש גם כמובן Internal Load Balancers (בשפה של AWS) שהם חבויים ולא ניתנים לגישה פומבית, אלא נמצאים בתוך רשת פרטית ומנהלים שם את הinfrastructure. דוגמה לכך היא ה- Docker Swarm שמנתב ומנהל את הסרביסים\שרתים שנמצאים בתוך השרת הפרטי.&lt;/p>
&lt;p>יש סוגים שונים של לוגיקה לכל Load Balancer שבעזרתו הוא מנתב את הבקשות לשרתים השונים, והלוגיקה תלויה בצרכים של האתר\אפליקציה. ישנם אלגוריתמים כמו round robin, שהוא כמו לחלק קלפים לאנשים לפי הסדר; הבקשה מנותבת לשרת הראשון, אח&amp;quot;כ לשני, שלישי עד אחרון השרתים- ואז חוזר חלילה לשרת הראשון.&lt;/p>
&lt;p>עוד אלגוריתם נקרא Weighted Response Time, אלגוריתם שמחשב מי השרת שמגיב הכי מהר- ואליו תנותב הבקשה. החישוב מתבצע בעזרת health checks שה- load balancer שולח בקשות מידי פעם ובודק את התקינות והמהירות תגובה של השרתים.&lt;/p>
&lt;p>אלגוריתם נוסף הוא Source IP Hash, שזה אלגוריתם בו ה-IP של הקליינט וה-IP של השרת אליה נשלחה הבקשה נתפרים יחד להאש (מפתח ייחודי), כך שיהיה אפשר לדעת בדיוק לאיזה שרת הקליינט ניגש בבקשה הקודמת, במידה והבקשה\התקשורת נפגעה, או שיש לקליינט צורך ממשי להגיע לאותו שרת ספציפי. דוגמה לכך היא במקרים בהם הקליינט צריך גישה ל-session ספציפי, בשרת ספציפי.&lt;/p>
&lt;p>ישנם מקרים בהם יש עומס של פעילות ביום וירידה חדה של פעילות בלילה. במקרים כאלה, יש צורך בלהעלות\להוריד שרתים בהתאם לעומס הבקשות בזמן אמת. רוב העננים מאפשרים את היכולות הללו, בעזרת שכפול ה-image של השרתים כך שכל השרתים יהיו זהים ומתחילים לבצע סקיילינג אוטומטי של השרתים. ב- AWS זה נקרא Auto Scaling, ובאז&amp;rsquo;ור זה נקרא Scaling Set.&lt;/p>
&lt;p>על פניו load balancer נראה מסובך, אבל הביצוע עצמו הוא דיי straight forward. רוב העננים מאפשרים להרים אחד כזה בכמה קליקים מבלי לעשות עמידת ידיים. גם הקונפיגורציה והלוגיקה של הניתוב לא מסובכים כשמבינים על פני השטח איך הדברים עובדים (או צריכים לעבוד).&lt;/p>
&lt;p>באז&amp;rsquo;ור למשל, צריך לעשות את הדברים הבאים:&lt;/p>
&lt;p>-להגדיר רשת פרטית לשרתים ול- load balancer&lt;/p>
&lt;p>-להגדיר שרתים שאליהם אנחנו רוצים לנתב&lt;/p>
&lt;p>-להרים שרת load balancer (דרך אז&amp;rsquo;ור) בכמה קליקים&lt;/p>
&lt;p>-להגדיר לו הגדרות כמו health checks, ssl, routing&lt;/p>
&lt;p>-ליצור &amp;ldquo;Backend Pool&amp;rdquo; – בעצם לקשר את השרתים שלנו עם הבאלאנסר&lt;/p>
&lt;ul>
&lt;li>יש load balancer עובד!&lt;/li>
&lt;/ul></content></entry><entry><title type="text">על VPN</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/vpn/"/><id>https://neocode.blog/posts/vpn/</id><updated>2020-09-08T15:01:03+03:00</updated><published>2020-09-07T12:43:26+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">כולנו נתקלנו בפרסומות ואינסוף חסויות לשירותי VPN מכל מיני סיבות- אבטחה, פרטיות או סתם בשביל לצפות בנטפליקס אמריקה. אבל איך בדיוק VPN עובד?
בעבר, VPN (או Virtual Private Network – רשת פרטית וירטואלית) היה בשימוש בעיקר בקרב עסקים, בדגש על חברות גדולות, בכדי לאפשר לעובדים לגשת לרשת המאובטחת במשרד מהבית באמצעות חיבור מאובטח.</summary><content type="html">&lt;p>כולנו נתקלנו בפרסומות ואינסוף חסויות לשירותי VPN מכל מיני סיבות- אבטחה, פרטיות או סתם בשביל לצפות בנטפליקס אמריקה. אבל איך בדיוק VPN עובד?&lt;/p>
&lt;p>בעבר, VPN (או Virtual Private Network – רשת פרטית וירטואלית) היה בשימוש בעיקר בקרב עסקים, בדגש על חברות גדולות, בכדי לאפשר לעובדים לגשת לרשת המאובטחת במשרד מהבית באמצעות חיבור מאובטח. בשביל להבין למה היה צורך ב-VPN, כדאי להבין איך אנחנו מתחברים לאינטרנט.&lt;/p>
&lt;p>נניח שאנחנו רוצים להיכנס ליוטיוב מהמחשב, פלאפון או כל ציוד קצה אחר. קודם כל המידע נשלח מהמחשב שלנו לראוטר/מודם. לראוטר/מודם יש כתובת IP שמהווה מזהה, מעיין תעודת זהות. משם הבקשה עוברת לספקית האינטרנט שלנו, לאחת מחוות השרתים שלה, סביר להניח שבפתח תקווה או בתל אביב.&lt;/p>
&lt;p>משם המידע יוצא דרך כבל תת ימי לאיטליה, ומשם מדלג ברשת ענק של &amp;ldquo;כבישים&amp;rdquo; בדמות סיבים אופטיים על אדמת אירופה משרת לשרת עד שמגיע לשרת המיועד של גוגל. הבקשה מגיעה ליוטיוב, הוא בתגובה שולח את התגובה ומחזיר אותה כל הדרך חזרה.&lt;/p>
&lt;p>אז איפה הבעיה? קודם כל, בכל נקודה בדרך המידע שלנו חשוף ללא מעט עיניים. מידע שעובר באופן לא מוצפן יהיה נגיש לכל בעל גישה לנקודות האלו. זו הסיבה שלהשתמש באינטרנט ציבורי, בין אם בבית החולים או בבית הקפה, כדי להתחבר לבנק הוא לא צעד מומלץ. כל אדם עם קצת ידע טכני יוכל לקרוא את כל המידע שעובר ברשת- כל הודעה, כל סיסמה. אבל גם אם המידע מוצפן, המידע שלנו נגיש להרבה גורמים אחרים. הספקית והרבה מהנקודות בדרך יכולות לראות לאן אנחנו רוצים לגשת ולקבל את היסטורית הגלישה שלנו ומידע שאולי היינו מעדיפים לשמור לעצמנו. גם האתר יוכל לראות מי אנחנו. כל הגורמים כמעט בוודאות שומרים לוגים מפורטים עם המידע שלנו.&lt;/p>
&lt;p>וכאן נכנס ה-VPN לתמונה. בכדי לייצר חיבור המאובטח ה-VPN יצר מעיין תעלה (Tunnel Protocol) שמהווה מעטפת מאובטחת לחיבור. ברגע שמזוהה חדירה כלשהי לתעלה, ה-VPN מנתק באופן מיידי את החיבור ומחבר את הלקוח באמצעות נתיב אחר. כלומר אם באיזשהו שלב בסדרת הדילוגים אחד השרתים שנחתנו עליהם &amp;ldquo;חשוף&amp;rdquo;, ה-VPN יעבור לנתיב אחר. במקום לעבור מבארי איטליה לציריך ומשם לפרנקפורט, ה-VPN אולי יזהה שהחיבור דרך ציריך חשוף, ינתק אותנו ויחבר מחדש בנתיב שעובר מבארי לרומא, משם לבאזל ולבסוף יגיע לפרנקפורט.&lt;/p>
&lt;p>בתוך התעלה הזו עובר המידע כשהוא מוצפן. כך גם אם למישהו יש גישה לתחנה כלשהי בדרך, הוא לא יוכל לקרוא את המידע ששלחנו- לא ברשת פרטית ולא ברשת ציבורית.&lt;/p>
&lt;p>ואם כל זה לא מספיק, המידע עובר בתחנת ביניים- שרת ה-VPN. כשאנחנו מחוברים ל-VPN אנחנו שולחים את הבקשה מוצפנת לשרת ה-VPN. השרת מפענח את הבקשה ומביא לנו אותה. הוא מהווה מעיין מידל מן- במקום לשלוח הודעה ליוטיוב באופן ישיר, אנחנו שולחים הודעה ל-VPN ואז הוא שולח את ההודעה ליוטיוב ובכך מסתיר את הזהות שלנו מיוטיוב, שמבחינתו מי ששלח לו הודעה זה שרת ה-VPN, לא אנחנו. בזכות ההצפנה גם כל הנקודות בדרך לשרת ה-VPN לא יודעות מה ביקשנו, כי המידע מוצפן. הן רק יודעות ששלחנו בקשה כלשהי לשרת כלשהו.&lt;/p>
&lt;p>זו גם הסיבה ש-VPN מאפשר לנו לצפות בנטפליקס במדינות זרות- אם נניח שאנחנו מחוברים לשרת VPN בניו יורק וגולשים בנטפליקס, מבחינת נטפליקס התקבלה בקשה ממחשב מתל אביב אלא מקבל בקשה ממחשב בניו יורק ולכן הוא יציג לו תוכן שמתאים לתיוג הגיאוגרפי של ניו יורק. כך גם לגבי כל חסימת תוכן על בסיס גיאוגרפי אחר- בין אם ב-BBC או ביוטיוב.&lt;/p>
&lt;p>גם כשמדובר בצנזורה במדינות כמו סין או איראן ה-VPN פותר את הבעיה בדרך דומה- במקום לגשת לשרת ויקיפדיה, ניגשים לשרת ה-VPN. המדינה לא יכולה לראות מה שלחתי ל-VPN ולכן הבקשה עוברת, משם ה-VPN מבקש בעצמו מויקיפדיה את האתר ושולח לנו אותו בחזרה מוצפן. ככה ניגשנו לויקיפדיה בלי שהאח הגדול ידע- מבחינתו ביקשנו משהו משרת כלשהו ולכן זה בסדר.&lt;/p>
&lt;p>אז מה הקאטץ’? יש כמה. דבר ראשון, חולשה די בולטת היא שרת ה-VPN עצמו. הוא יודע מי שלח את הבקשה והוא יודע מה היא (הרי הוא הוריד את ההצפנה כדי לקרוא). אנחנו למעשה צריכים לסמוך על חברות ה-VPN שהן מוחקות את הלוגים שלהן.&lt;/p>
&lt;p>בעיה נוספת היא המהירות- ההצפנה והנקודה הנוספת, במיוחד אם היא רחוקה, יכולה להאט דרסטית את הגלישה. במקרה שאנחנו מתחברים מישראל דרך ארהב לאתר אירופאי לדוגמה, אנחנו נתחבר מהבית, לספקית, לאיטליה, לפרנקפורט, משם לונדון/אמסטרדם, לניו יורק, לשרת ה-VPN, שאחר כך ישלח את הבקשה לניו יורק, לונדון, נקודה כלשהי באירופה, חזרה ללונדון, ניו יורק, שרת VPN ושוב לניו יורק, לונדון, פרנקפורט, איטליה, ישראל, אלינו. אם אנחנו ניגשים לשרת אמריקאי אנחנו חוסכים 2 כיוונים לאירופה, אבל עדיין מדובר בדרך שחוצה יבשות ואוקיינוס ואנחנו נחווה ניחות (גם אם לא אחד שיורגש יותר מדי).&lt;/p>
&lt;p>עם זאת כדאי לציין שבשעות עומס לפעמים דווקא ה-VPN יכול להיות יותר מהיר, בגלל שהוא עובר ב&amp;quot;סמטאות&amp;rdquo; אינטרנט מאובטחות יותר ולכן ניגש לשרת בדרך פחות עמוסה, בניגוד לרוב האנשים שיעברו דרך כביש סואן.&lt;/p></content></entry><entry><title type="text">כמה ארוכה פונקציה צריכה להיות?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/function-length/"/><id>https://neocode.blog/posts/function-length/</id><updated>2020-09-08T19:00:40+03:00</updated><published>2020-09-06T16:52:35+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">אם נשאל את דוד בוב, זה כנראה יהיה עד 100&amp;hellip;
קשה באמת להגדיר כמה ארוכה פונקציה צריכה להיות, וכנראה שאי אפשר לנקב במספר ממשי (כל מספר שננקב כנראה יהיה שרירותיׂ), אבל אפשר להתווכח שלפונקציות קצרות יש מספר יתרונות בולטים שקשה להתעלם מהם.</summary><content type="html">&lt;p>אם נשאל את דוד בוב, זה כנראה יהיה עד 100&amp;hellip;&lt;/p>
&lt;p>קשה באמת להגדיר כמה ארוכה פונקציה צריכה להיות, וכנראה שאי אפשר לנקב במספר ממשי (כל מספר שננקב כנראה יהיה שרירותיׂ), אבל אפשר להתווכח שלפונקציות קצרות יש מספר יתרונות בולטים שקשה להתעלם מהם.&lt;/p>
&lt;p>כשאני מתייחס לפונקציות קצרות, הכוונה היא לפירוק הקוד בפונקציה אחת לתתי פונקציות. או כמו שחובבי פילוסופיית היוניקס אוהבים לומר: כל פונקציה צריכה לעשות משהוא אחד, ולעשות אותו טוב. הקוד &lt;em>לא&lt;/em> צריך להיות מושפע מאורך הפונקציה. הקוד הוא חלק נפרד, שנכתב בהתאם ליעילות הרלוונטית ועד כמה הוא קריא.&lt;/p>
&lt;p>אם ניקח פונקציה ארוכה מאוד ונתחיל לפרק אותה לתתי פונקציות, הדבר הראשון שיבלוט בעין זה שקל יותר להבין מה הפונקציה עושה (אם זה לא ברור לפי השם), ובערך איך היא עושה זאת. זה משמעותית תופס את העין מאשר קטע קוד ארוך שצריך להתחיל לקרוא שורה שורה ולתפוס את התמונה כמו פאזל לא מורכב (לא משנה עד כמה הקוד &amp;lsquo;קריא&amp;rsquo;).&lt;/p>
&lt;p>בנוסף, עטיפת קטעי קוד בפונקציות נותנת לנו עוד שכבת הפשטה. שכבת ההפשטה הזאת מעודדת אותנו להשתמש יותר בפונקציות הקיימות, מצמצמת חזרה על קוד קיים, ומאפשרת לנו יותר גמישות פונקציונאלית בתוך הפונקציות.&lt;/p>
&lt;p>מבחינת דיבוג גם יש יתרון- יהיה קל יותר לדבאג פונקציות מפורקות מבלי שנצטרך לדעת איזה חלק בקוד לתפוס כנקודת עצירה.&lt;/p>
&lt;p>טסטים גם עשויים לקבל יתרון כשאפשר לבנות יוניט טסטים על פונקציות בודדות במקום על אחת (למרות שעל עקרון כזה יש וויכוח, האם צריך לבדוק את התוצאה של הפונקציה דרך תתי הפונקציות שלה, הוא דרך הפונקציה כמכלול?).&lt;/p>
&lt;p>אני אף פעם לא בעד פתרונות שחור או לבן- כי כנראה פתרונות כאלה לא קיימים, לפחות לא בתוכנה. אבל לפונקציות קצרות, המפורקות לתתי פונקציות, כן יש יתרונות מאוד בולטים שקשה להתווכח איתם. לגבי חסרונות? אולי שיש יותר מידי לגו לשחק איתם, והשאלה היא אם זה חסרון מספיק גדול.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">UTF-8, ASCII &amp; Unicode</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/utf-ascii-unicode/"/><id>https://neocode.blog/posts/utf-ascii-unicode/</id><updated>2020-09-08T19:00:31+03:00</updated><published>2020-08-27T16:41:41+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">מה זה כל האסקים, UTFים וכל קידודים האלה?
נתחיל מהאב הקדמון- קוד מורס האגדי. קוד מורס הומצא כשיטה להעביר הודעה דרך אמצעים אלקטרונים ולתרגם את הצלילים המועברים לאותיות. את ההודעה בונים בעזרת תקשורת בינארית(בתוספת של רווח בין הצלילים)- נקודה או קו. כך למשל את ההודעה &amp;ldquo;SOS&amp;rdquo; שכולנו מכירים, אפשר לקרוא בקוד מורס כ- &amp;ldquo;&amp;hellip; - - - &amp;hellip;&amp;rdquo;, ואם נשמע את הצליל של ההודעה הזאת, הוא יהיה מאוד מוכר לכולנו מאיפשהוא (כי טחנו את הצליל בכל מקום בסרטים הישנים).</summary><content type="html">&lt;p>מה זה כל האסקים, UTFים וכל קידודים האלה?&lt;/p>
&lt;p>נתחיל מהאב הקדמון- קוד מורס האגדי. קוד מורס הומצא כשיטה להעביר הודעה דרך אמצעים אלקטרונים ולתרגם את הצלילים המועברים לאותיות. את ההודעה בונים בעזרת תקשורת בינארית(בתוספת של רווח בין הצלילים)- נקודה או קו. כך למשל את ההודעה &amp;ldquo;SOS&amp;rdquo; שכולנו מכירים, אפשר לקרוא בקוד מורס כ- &amp;ldquo;&amp;hellip; - - - &amp;hellip;&amp;rdquo;, ואם נשמע את הצליל של ההודעה הזאת, הוא יהיה מאוד מוכר לכולנו מאיפשהוא (כי טחנו את הצליל בכל מקום בסרטים הישנים).&lt;/p>
&lt;p>קוד מורס שירת את האנושות עד עליית המחשבים והתקשורת בין המחשבים, המשתמשת בתקשורת בינארית של 0 ו-1, דאז האנושות הייתה צריכה להתקדם קצת ולמצוא דרך חדשה לתרגם את המידע שנשמר או נשלח ברשת בצורה של 0 או 1&amp;rsquo;ים- לתווים ומספרים ממשיים.&lt;/p>
&lt;p>אז שיטות להפיכת מספרים רגילים לבינאריים וההפך- היה לנו. 1 זה 1, 2 זה 10, 3 זה 11 וכל&amp;rsquo;. אבל לתווים- לא היה לנו.&lt;/p>
&lt;p>ואז נולדה לה טבלת ה- ASCII, שהיא מכילה את כל התווים של המקלדת שלכם, כש-33 התווים הראשונים מיוחסים ל&amp;quot;פקודות&amp;rdquo; כמו SPACE, TAB, ESC , ו-65 עד 127 לשאר התווים כמו אותיות קטנות וגדולות (באנגלית בלבד- זה חשוב), + - = וכל&amp;rsquo;. הטבלת ASCII הראשונית הייתה מוגדרת ל- 7 ביטים לייצוג תו, כך שיש 128 אפשרויות סה&amp;quot;כ. עכשיו אפשר לחזור אחריי: 1000001 זה A, ו- 1000010 זה B. הוריי אפשר לתרגם תווים מבינארית לאנגלית!&lt;/p>
&lt;p>על אף ההתקדמות המטאורית, שאפילו בעזרת טבלת ASCII הטיסו חללית לירח, היה נחוץ בעוד פריצת דרך: אנחנו רוצים להעביר תווים בינלאומיים בכל העולם, ולא רק באנגלית. מה עם קצת אותיות בסינית, רוסית ועברית? ומה עם קצת אימוג&amp;rsquo;יז?&lt;/p>
&lt;p>שוב נכנסנו להריון והפעם הולדנו את ה- Unicode, שהיא טבלה שאפתנית המאכלסת את כל התווים בעולם- עברית, רוסית, יפנית, אימוג&amp;rsquo;י, ועוד (לכל תו יש &amp;ldquo;code point&amp;rdquo; שהוא המזהה הייחודי שלו בטבלה). עכשיו יש לנו טבלה משודרגת, וכל שנותר לנו הוא לייחס כל תוו לייצוג הבינארי שלו. לשם כך נוצרו להם קידודים שונים עם חוקים משלהם.&lt;/p>
&lt;p>כאן נכנס UTF-8 לתמונה. UTF-8 בהגדרתו הוא שימוש ב-8 ביטים לפחות לייצוג של תוו כלשהוא, &lt;em>הכולל&lt;/em> את השימוש הרגיל של ה- ASCII שלנו. זה אומר, שהייצוג של A ב-UTF8 יהיה 01000001. גם ב- ASCII אגב הורחבו התווים מ-128 אפשרויות ל- 256 אפשרויות, כיאה לקומבינציות של byte אחד.&lt;/p>
&lt;p>מחיפוש בגוגל נתון שיש כ- 143,859 תווים ל-unicode, אבל התשובה כנראה מורכבת יותר. בכל מקרה, זה הרבה מעל ל-256 האפשרויות שיש בבייט אחד. אז מה עושים? ממשיכים לעוד בייט, ועוד בייט עד 6 בייטים (כלומר הקפיצות יהיו של bytes).&lt;/p>
&lt;p>ומה עם UTF 16, 32? אותו רעיון- הייצוג של כל תו יהיה לפי 16 או 32 ביטים בהתאמה. לפי ההיגיון UTF-8 נשמע יעיל יותר, מכיוון שכל תוו מיוצג במינימום של 8 ביטים, בזמן שהאחרים ע&amp;quot;י 16 ו-32, אבל זה לא מדויק. ישנם מקרים בהם דווקא להשתמש ב 16-UTF יעיל יותר (כמו בשפות אסיאתיות מסוימות), שכן פרזנטציות של אותיות בשפות מסויימות ב- 8UTF יהיו בגודל 4 בייטים, וב-16 יהיו בגודל 2 בייטים. בנוסף, מכיוון שטבלת ASCII תומכת בייצוג של 8 ביטים לתו, אז קידודים כמו 16,32 UTF לא ייתמכו במערכות המתבססות על ASCII.&lt;/p>
&lt;p>לקינוח, מה זה בדיוק codec? זה פשוט הסוג של הקידוד שאנחנו משתמשים בו. UTF-8 למשל, הוא סוג של codec.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">הצפנה א-סימטרית</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/asymmetric-encryption/"/><id>https://neocode.blog/posts/asymmetric-encryption/</id><updated>2020-09-08T19:00:37+03:00</updated><published>2020-08-24T16:46:08+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">Asymmetric encryption &amp;amp; public/private puke
בעידן של היום, כשהפרטיות והאבטחה שלנו ברשת רק הולכות ונשחקות, כדאי להיזכר בחשיבות של ההצפנה- מהיסודות של אינטרנט פתוח, חופשי ומאובטח. ובגזרה הזו הצפנה אסימטרית היא השיטה הכי נפוצה וכנראה שהכי חשובה, אבל עד כמה אתם יודעים איך היא עובדת?</summary><content type="html">&lt;p>Asymmetric encryption &amp;amp; public/private puke&lt;/p>
&lt;p>בעידן של היום, כשהפרטיות והאבטחה שלנו ברשת רק הולכות ונשחקות, כדאי להיזכר בחשיבות של ההצפנה- מהיסודות של אינטרנט פתוח, חופשי ומאובטח. ובגזרה הזו הצפנה אסימטרית היא השיטה הכי נפוצה וכנראה שהכי חשובה, אבל עד כמה אתם יודעים איך היא עובדת?&lt;/p>
&lt;p>בשביל להבין את הצורך בהצפנה א-סימטרית כדאי להכיר את ההצפנה הסימטרית הפשוטה יותר. בהצפנה סימטרית אנחנו משתמשים במפתח סודי אחד גם לפיענוח וגם להצפנה. כלומר אם א’ וב’ רוצים להעביר ביניהם קובץ מוצפן סימטרית, א’ יצור מפתח סודי (סיסמה) שישמש להצפנת הקובץ, ישלח את הקובץ המוצפן לב’ ואז ב’ יצטרך להשתמש באותו המפתח של א’ בכדי לפענח את ההצפנה ולקבל את המידע הנחוץ.&lt;/p>
&lt;p>הבעיה היא שגם השולח וגם המקבל צריכים להיות עם אותו המפתח הסודי, מה שאומר שהם יאלצו לשתף אותו ביניהם בדרך כזו או אחרת, כך שבשלב כלשהו בדרך הם יאלצו לשתף את המפתח באופן לא מוצפן- וזה רע.&lt;/p>
&lt;p>את הבעיה הזו פותרת הצפנה א-סימטרית. בהצפנה א-סימטרית משתמשים בשני מפתחות- מפתח ציבורי ומפתח פרטי. המפתח הציבורי חשוף לכולם, והוא המפתח שיוצר את ההצפנה. השולח נעזר במפתח הציבורי של המקבל בכדי לייצר קובץ מוצפן.&lt;/p>
&lt;p>על מנת לפענח את ההצפנה יש להיעזר במפתח הפרטי, שנמצא רק אצל המקבל. גם השולח לא יכול לפענח את הקורס שהוא עצמו הצפין מאחר ואין לו את המפתח הפרטי.&lt;/p>
&lt;p>דוגמה: א’ וב’ שולחים אחד לשני הודעות עם הצפנה א-סימטרית. לכל אחד מהם יש 3 מפתחות- לא’ יש את המפתח הציבורי שלו, את המפתח הפרטי שלו ואת המפתח הציבורי של ב’. לב’ יש את המפתח הפרטי והציבורי שלו ואת המפתח הציבורי של א’. כשא’ שולח הודעה לב’, הוא מצפין אותה עם המפתח הציבורי של ב’. לאחר שההודעה הוצפנה הדרך היחידה לקרוא אותה היא באמצעות המפתח הפרטי של ב’ ולכן לא’ אין יכולת לקרוא את מה שהוא עצמו כתב. ההודעה נשלחת לב’ שבאמצעות המפתח הפרטי שלו קורא אותה.&lt;/p>
&lt;p>המפתחות הפרטיים קשורים למפתחות הציבוריים ויכולים לפענח את ההצפנה שהם יצרו, אבל אי אפשר למצוא אותם באמצעות מפתח ציבורי.&lt;/p>
&lt;p>כל עוד הנמען שומר על המפתח הפרטי שלו, אי אפשר לפצח את ההצפנה ולראות את המידע שהועבר. גם במידה והמפתח הסודי של אחד הצדדים נגנב, אפשר לקרוא רק את ההודעות שנשלחו אליו. כלומר, אם המפתח הפרטי של א’ נגנב, אז כל ההודעות שנשלחו לא’, הודעות שהוצפנו על ידי המפתח הציבורי של א’ ומפוענחות על ידי המפתח הפרטי של א’, יהיו חשופות למי שמחזיק במפתח, אבל לא ההודעות שא’ שלח לב’. ההודעות שא’ שלח לב’ מוצפנות עם המפתח הציבורי של ב’ ועל מנת לפענח אותן יש צורך במפתח הפרטי של ב’.&lt;/p>
&lt;p>תכונה חשובה נוספת של הצפנה א-סימטרית היא היכולת להצפין את ההודעה עם המפתח הפרטי ואז לפענח אותה עם המפתח הציבורי. אמנם כל אחד יכול לקרוא את המידע שהרי לכל אחד יש את הגישה למפתח הציבורי, אבל מאחר והמידע הוצפן עם המפתח הפרטי שנמצא רק אצל אדם אחד אנחנו יכולים לאמת שמי ששלח את המידע הזה הוא אכן מי שהוא מתיימר להיות.&lt;/p>
&lt;p>ההבדלים בין השיטות מתבטאים בין היתר באורך המפתחות. מאחר ובהצפנה א-סימטרית חייב להיות קשר מתמטי בין המפתח הציבורי למפתח הפרטי, פורצים יכולים באופן תיאורטי &amp;ldquo;להסיק&amp;rdquo; את המפתח הפרטי מהציבורי. כתוצאה מכך המפתחות בהצפנה א-סימטרית הם ארוכים באופן משמעותי- מפתח של 2048 ביט בהצפנה א-סימטרית מספק פחות או יותר את אותה רמת האבטחה של מפתח 128 ביט בהצפנה סימטרית.&lt;/p>
&lt;p>היתרונות של השיטה הם אבטחה מוגברת ופתרון בעיית שיתוף המפתח הסודי, כמו גם אימות זהות השולח על ידי חתימה דיגטלית בדמות המפתח הפרטי. החסרונות הם האיטיות של השיטה ביחס להצפנה סימטרית והכוח העצום של המפתח הפרטי- אם המפתח הפרטי אבד או נגנב כל המידע אבד או נגנב.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">איך ללמוד רקורסיה באופן אינטואיטיבי</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/intuitive-recursion/"/><id>https://neocode.blog/posts/intuitive-recursion/</id><updated>2020-09-08T19:00:47+03:00</updated><published>2020-08-20T16:54:53+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">בשביל ללמוד רקורסיה, צריך ללמוד רקורסיה! או איך ללמוד רקורסיה the intuitive way 🙂.
פונקציה רקורסיבית היא פונקציה שקוראת לעצמה בתוך עצמה (ושכולם כבר הפנימו כנראה). אבל עדיין יש אלמנטים עמומים שמבלבלים אנשים ברקורסיה (ובצדק).
הדבר הראשון שמבלבל אנשים הוא איך קוראים לפונקציה בתוך עצמה, כשלא סיימנו עדיין את הפונקציה.</summary><content type="html">&lt;p>בשביל ללמוד רקורסיה, צריך ללמוד רקורסיה! או איך ללמוד רקורסיה the intuitive way 🙂.&lt;/p>
&lt;p>פונקציה רקורסיבית היא פונקציה שקוראת לעצמה בתוך עצמה (ושכולם כבר הפנימו כנראה). אבל עדיין יש אלמנטים עמומים שמבלבלים אנשים ברקורסיה (ובצדק).&lt;/p>
&lt;p>הדבר הראשון שמבלבל אנשים הוא איך קוראים לפונקציה בתוך עצמה, כשלא סיימנו עדיין את הפונקציה. הדבר השני, הוא איך ההיגיון מאחורי הקלעים עובד, שפולט את התשובה הנכונה כמו קסם.&lt;/p>
&lt;p>הסיבה שלקרוא לפונקציה בתוך עצמה &amp;ldquo;עובד&amp;rdquo;, הוא בגלל שכל קריאה לפונקציה נשמרת בזיכרון ב-stack (מחסנית), אשר עובדת לפי אחרון נכנס, ראשון יוצא. לדוגמה, אם נריץ את האלגוריתם הבא:&lt;/p>
&lt;p>func(n = 4):
if n == 0 return
func(n-1)
print(n)&lt;/p>
&lt;p>קודם כל יודפס 1, אח&amp;quot;כ 2, 3 ואז 4. זה בגלל שהקריאות נשמרות במחסנית לפי הסדר הבא: קודם נכנס למחסנית func(4), אחריו func(3)&amp;hellip;עד 0, הקריאה העליונה במחסנית. כשמגיעים לתנאי העצירה (0), מפסיקים לשמור קריאות במחסנית ומתחילים לעבור לשורת ההדפסה print בכל אחת מהקריאות מהסוף להתחלה במחסנית: מדפיסים 1, ואז 2 וכן הלאה.&lt;/p>
&lt;p>קטע מעניין, הוא שעדיין אפשר להגיע ל-stackoverflow גם מבלי להשתמש במשפט הקסם &amp;ldquo;בלי תנאי עצירה&amp;rdquo;, שכן אם נציב מספר גדול כמו 10000, האלגוריתם עדיין יקרוס מ-stackoverflow בגלל השימוש הכבד במחסנית (צריך לשמור n קריאות במחסנית).&lt;/p>
&lt;p>לעומת זאת, אם נחליף את הסדר של ה- print:&lt;/p>
&lt;p>func(n = 4):
if n == 0 return
print(n)
func(n-1)&lt;/p>
&lt;p>ההדפסה תהיה הפוכה: התוצאה שנקבל היא 4, אחריו 3, 2, ואז 1. הפונקציה מדפיסה את המספר n, וקוראת לעצמה שוב עם n-1. ברגע שהגענו לתנאי העצירה n=0, אין עוד מה לעשות והקריאות חוזרות אחת אחרי השניה מהסוף להתחלה ללא קריאה לפעולות נוספות. אלגוריתם כזה נקרא tail recursion.&lt;/p>
&lt;p>ההגדרה המילולית ל-tail recursion היא &amp;ldquo;הפעולה האחרונה של הפונקציה היא הקריאה לפונקציה עצמה&amp;rdquo;, כלומר אין עוד שורות או חישובים נוספים שעליה לבצע והיא מחזירה את התוצאה הסופית (אם יש מה להחזיר, לא במקרה שלנו). אלגוריתם שמשתמש ב-tail recursion יכול להיות לפעמים יעיל יותר מרקורסיה רגילה, שכן יש קומפיילרים המסוגלים לייעל את השימוש במחסנית (כלומר מתנהג כמו מימוש איטרטיבי).&lt;/p>
&lt;p>באלגוריתמים בהם צריך להחזיר תוצאה, כמו למשל בפונקציה רקורסיבית לחישוב עצרת (כאשר n = 4), הרעיון עובד בצורה דומה:
fact(n = 4)
if n == 1 return 1
return n*fact(n-1)&lt;/p>
&lt;p>הקריאה הראשונה שנכנסת למחסנית הוא fact4, והיא אומרת &amp;ldquo;תן לי את התוצאה של fact3 ואני אתן לך את התוצאה של 4!. אותו דבר ל-fact3 עד שמגיעים ל n = 1, שבמקרה מחזיר 1 כתנאי עצירה. ואז מלמעלה למטה:&lt;/p>
&lt;p>fact(1) = 1
fact (2) = 2 * fact(1) = 2&lt;em>1
fact(3) = 3 * fact(2) = 3&lt;/em>2
fact(4) = 4 * fact(3) = 4*6 = 24&lt;/p>
&lt;p>אלגוריתם של tail recursion ייראה כך:&lt;/p>
&lt;p>facTail(n = 4, results = 1):
if(n == 1) return results
return facTail(n-1, results * n)&lt;/p>
&lt;p>הפעולה האחרונה היא קריאה רקורסיבית, והפונקציה מעדכנת את הפרמטר results עד התנאי עצירה, מחזירה את הערך הסופי ומעיפה את כל הקריאות מהמחסנית אחד אחד.&lt;/p>
&lt;p>בגלל השימוש הנדיב שלה במחסנית, רקורסיה (לפחות רגילה) תהיה איטית יותר מאלגוריתם איטרטיבי, ולכן ברוב המקרים התירוץ להשתמש באלגוריתם רקורסיבי יהיה בהתאם לאינטואיטיביות של המימוש.&lt;/p>
&lt;p>בדר&amp;quot;כ האלגוריתמים האינטואיטיביים למימוש רקורסיבי הם במעבר על עצים, או מימושים של בעיות divide and conquer או במילים ישראליות- לפוצץ את הבעיה לחתיכות קטנות ולפתור. האלגוריתם לפתרון של tower of hanoi היא דוגמה ממש נפלאה לאיך אלגוריתם איטרטיבי ומסובך נחתך למס&amp;rsquo; שורות מצומצם במימוש רקורסיבי.&lt;/p>
&lt;p>הרעיון המרכזי שצריך להפנים בפונקציה רקורסיבית רגילה, היא איך נשמרות הקריאות במחסנית, ולעבוד מלמעלה למטה- ואז הרבה יותר קל להבין את ההגיון מאחורי האלגוריתם. ב- tail recursion צריך להפנים שבסה&amp;quot;כ מעדכנים כל פעם פרמטר(ים) ועובדים איתו מהגדול לקטן עד שבסוף מחזירים אותו.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">מה זה DNS, ומה הוא עושה?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/dns/"/><id>https://neocode.blog/posts/dns/</id><updated>2020-09-08T19:00:39+03:00</updated><published>2020-08-17T16:59:21+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">פרוטוקול ה-DNS, או בשמו המלא Domain Name System, הוא פרוטקול שכולנו משתמשים בו כל הזמן והופך את האינטרט לנגיש לכולם. למרות זאת, הוא לא זוכה למספיק יחס.
ה-DNS הוא למעשה ספר הטלפונים של האינטרנט. כשאנחנו מנסים להיכנס לויקיפדיה לדוגמה, אנחנו מזינים לשורת הכתובת בדפדפן כתובת שנוחה לבני אדם- wikipedia.</summary><content type="html">&lt;p>פרוטוקול ה-DNS, או בשמו המלא Domain Name System, הוא פרוטקול שכולנו משתמשים בו כל הזמן והופך את האינטרט לנגיש לכולם. למרות זאת, הוא לא זוכה למספיק יחס.&lt;/p>
&lt;p>ה-DNS הוא למעשה ספר הטלפונים של האינטרנט. כשאנחנו מנסים להיכנס לויקיפדיה לדוגמה, אנחנו מזינים לשורת הכתובת בדפדפן כתובת שנוחה לבני אדם- wikipedia.org. הבעיה היא שמחשבים לא עובדים בצורה כזו, הכתובות של מחשבים הן כתובות IP מספריות. למעשה הכתובת של ויקיפדיה עבור המחשב היא 91.198.174.192 בפרוטקול IPv4 או 2620:0:862:ed1a::1 בפרוטקול Ipv6, ואף אחת מהן לא ידידותית למשתמש.&lt;/p>
&lt;p>וכאן ה-DNS נכנס לתמונה. ה-DNS מקשר בין הכתובת ה&amp;quot;אנושית&amp;rdquo; wikipedia.org לכתובת האמיתית- 91.198.174.192.&lt;/p>
&lt;p>איך ה-DNS יודע לקשר כתובות?&lt;/p>
&lt;p>כשאנחנו מזינים את הכתובת ולוחצים אינטר, נשלחת בקשה לשרת ה-DNS שלנו. איזה שרת בדיוק? זה תלוי. בהנחה שלא שיניתם את הגדרות ה-DNS אצלכם (בראוטר/מחשב/פלאפון וכו&amp;rsquo;), אתם משתשמשים בשרתי ברירת המחדל שהם השרתים של ספקית האינטרנט שלכם (שזה צעד ממש לא חכם, אבל זה לפוסט אחר).&lt;/p>
&lt;p>השרת הזה נקרא DNS recursive resolver ואפשר להסתכל עליו כמעיין ספרנית שמקבלת שאילתא (query) ואז הולכת לחפש את הספר שמתאים לה (כתובת דומיין) על ידי סדרה של בקשות בשביל למצוא את המיקום המדויק.&lt;/p>
&lt;p>התחנה הראשונה היא שרת Root Nameserver. השרת הזה למעשה מפנה את הספרנית למדור הנכון בספריה, שהוא ה-TLD (Top Level Domain) Nameserver המתאים או במילים אחרות- לשרת המתאים לסיומת הדומיין. בדוגמה שלwikipedia.org, ה-Root יפנה אותנו (כלומר את ה-DNS resolver) ל-TLD Nameserver שמתאים לסיומת org.&lt;/p>
&lt;p>מהרוט אנחנו מגיעים ל-TLD Nameserver המתאים. ה-TLD NS הוא למעשה המדף המתאים בספריה שמכיל את כל הספרים בקטג&amp;rsquo; שביקשנו, או במקרה שלנו את כל הדומיינים עם סיומת org. ה-TLD NS מוצא את הרשומה של wikipedia.org ומפנה אותנו עם המידע הזה ל-Authoritative Nameserver, או לספר הספציפי.&lt;/p>
&lt;p>השלב האחרון במסע שלנו מגיע כשה-resolver שולח בקשה ל-Authoritative Nameserver. ה-Autoritative NS מספק לו את המידע שהוא בדמות רקורד DNS מלא שכולל את כתובת ה-IP המתאימה וכל תת כתובת אחרת שנחוצה וההפניות שלה (לדוגמה תת דומיין שמפנה למקום אחר).&lt;/p>
&lt;p>מכאן ה-DNS resolver חוזר למחשב שלנו, מצויד בכתובת ה-IP של האתר שביקשנו. הדפדפן שולח בקשת HTTP לשרת ומקבל בחזרה את העמוד המבוקש. בנוסף לכך, גם ה-resolver וגם המחשב שלנו ישמרו את הבקשה הזו ב-cache כדי לחסוך את הטיול הזה בפעם הבאה שאנחנו צריכים את כתובת ה-IP של האתר.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">למה JWT הוא ערק ערק ככה חזק?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/jwt/"/><id>https://neocode.blog/posts/jwt/</id><updated>2020-09-08T19:00:46+03:00</updated><published>2020-08-13T17:01:42+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">אוטנטיקציה דרך קוקיז עובדת לא רע בכלל לאתרים, וקשה להצביע על יתרונות אבסולוטים למעבר אל אוטנטיקציה דרך JWT. אבל זה, כמובן, כשהאתר הוא אתר, ושהוא נתמך ע&amp;quot;י דפדפנים שתומכים בקוקיז. מה עם אפליקציות נייטיב, שאין להן תמיכה של קוקיז? כאן JWT זורח.</summary><content type="html">&lt;p>אוטנטיקציה דרך קוקיז עובדת לא רע בכלל לאתרים, וקשה להצביע על יתרונות אבסולוטים למעבר אל אוטנטיקציה דרך JWT. אבל זה, כמובן, כשהאתר הוא אתר, ושהוא נתמך ע&amp;quot;י דפדפנים שתומכים בקוקיז. מה עם אפליקציות נייטיב, שאין להן תמיכה של קוקיז? כאן JWT זורח.&lt;/p>
&lt;p>למען הסר ספק, ההבדלים בין Authentication, Authorization הן ש-authentication הוא הזדהות (מי אתה?), ו- authorization הוא &amp;ldquo;אם אתה רוצה לקנות ערק תראה לי שאתה 21+&amp;rdquo; (הרשאה).&lt;/p>
&lt;p>אז הביטוי JWT נקרא Json Web Token, והמימוש שלו חמוד לאללה. JWT זה טוקן הנראה כגוש האש גדול, המופרד ל-3 חלקים בעזרת נקודה חמודה.&lt;/p>
&lt;p>הסטרינג הראשון, הוא בד&amp;quot;כ json בעצמו שמכיל מידע על האלגוריתם האש שהשתמשו בטוקן כדי לחתום אותו. הסטרינג השני, שהוא גם בד&amp;quot;כ Json, הוא המידע עצמו שרוצים לשמור כדי שהמשתמש יוכל להזדהות (כמו ID של המשתמש, תאריך תפוגה ועוד&amp;rsquo;).&lt;/p>
&lt;p>שני ה- jsonים מקודדים לסטנדרט של base64url, ו&lt;em>אינם&lt;/em> מוצפנים, כמובן. כל אחד יכול לפענח את שני הסטרינגים הללו ולקרוא את המידע. מכאן, מגיע הבטיחות בחלק השלישי של הטוקן: החתימה.&lt;/p>
&lt;p>הרעיון של הטוקן הוא לא להעביר מידע מוצפן (לפחות לא JWT סימטרי), אלא לוודא שאף אחד לא &lt;em>משנה&lt;/em> את המידע. בשביל לוודא זאת, לוקחים את החלק הראשון (שנקרא גם header), החלק השני (שנקרא גם payload), מחברים אותם לסטרינג אחד, מוסיפים לו מפתח שקיים אצל השרת &lt;em>בלבד&lt;/em>, ומהאהשים בהתאם להגדרות האלגוריתם של החלק הראשון (ה-header). התוצאה: סטרינג, או &amp;lsquo;חתימה&amp;rsquo; שהיא החלק האחרון בטוקן. וזה, מוודא לנו שאף אחד לא נגע בטוקן. מי שיצר אותו יקבל את אותו הטוקן ללא שינויים זדוניים.&lt;/p>
&lt;p>מכיוון שרק לשרת יש את המפתח שאנחנו מוסיפים לחתימה, אף אחד אחר לא יכול לייצר את החתימה, ולכן אף אחד לא יוכל לעבוד על השרת. כשהשרת מקבל את הטוקן, הוא פועל שוב ע&amp;quot;פ ההוראות למעלה, ומוודא שהחתימה שיוצאת לו, היא אותה חתימה המתקבלת בטוקן. לא- מחזיר 401, כן- יאללה ערק.&lt;/p>
&lt;p>המקרה בו יש רק מפתח אחד, נקרא JWT סימטרי. כלומר, קיים רק מפתח אחד (&amp;lsquo;פרטי&amp;rsquo;) שיכול לאשר את החתימה, ובשביל שעוד שרתים יוכלו לאשר את הטוקן, צריך לפזר את המפתח ביניהם. זה בד&amp;quot;כ מתכון לפירצות אבטחה, כשאם שרת אחד נפרץ, כל השרתים שמחזיקים את המפתח נמצאים בסכנה.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">למה חיפוש בינארי קיים או עדיף, למה בעצם להסתבך עם עצים בינארים?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/binary-search-and-binary-trees/"/><id>https://neocode.blog/posts/binary-search-and-binary-trees/</id><updated>2020-09-08T19:04:12+03:00</updated><published>2020-08-10T17:04:00+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">כדי למדוד מהירות (פוטנציאל) אלגוריתמי כלשהיא, אנחנו נאלצים לבודד את המשתנים אשר מפריעים לנו למדוד את הפוטנציאל הטהור של האלגוריתם, כמו לבודד את המכונה מהמשוואה. איננו רוצים שאלגוריתם יהיה מהיר יותר כי יש לך את ה- AMD Ryzen החדש. בשביל זה יש לנו את הסיבוכיות- המודדת את כמות האופרציות שאלגוריתם מבצע, וכך נוכל להעריך גם את הפוטנציאל.</summary><content type="html">&lt;p>כדי למדוד מהירות (פוטנציאל) אלגוריתמי כלשהיא, אנחנו נאלצים לבודד את המשתנים אשר מפריעים לנו למדוד את הפוטנציאל הטהור של האלגוריתם, כמו לבודד את המכונה מהמשוואה. איננו רוצים שאלגוריתם יהיה מהיר יותר כי יש לך את ה- AMD Ryzen החדש. בשביל זה יש לנו את הסיבוכיות- המודדת את כמות האופרציות שאלגוריתם מבצע, וכך נוכל להעריך גם את הפוטנציאל.&lt;/p>
&lt;p>חיפוש בינארי הוא &lt;em>עוד&lt;/em> אלגוריתם שנולד מתוך הרצון לחתוך כמה שיותר את כמות האופרציות בזמן חיפוש, והקונספט שלו דומה לחיפוש בספרי דפי זהב שפעם היה לכולנו. במקום לחפש איבר אחד אחרי השני, אנחנו חותכים את החיפוש ספציפית לאות שבה מתחיל השם שאנחנו מחפשים. זה כל כך אפקטיבי, שאנחנו יכולים למצוא שם של אדם תוך כמה שניות, מאשר אפילו כמה שעות.&lt;/p>
&lt;p>יש לציין, שאי אפשר לבצע חיפוש בינארי עם הרשימה לא מסודרת. לא נוכל לחפש לפי אות אם האותיות לא מסודרת לפי ה- א&amp;rsquo; ב&amp;rsquo;.&lt;/p>
&lt;p>המשמעות של בינארי, אגב, פירושו יחס בין 2 פרטים. 0 או 1. זה או זה. פה או שם. ומכאן השם של חיפוש בינארי-אם לא פה אז אולי שם.&lt;/p>
&lt;p>אז הקונספט של חיפוש בינארי הוא דיי קליל. ניקח מערך מספרים ממויין, ונחפש ספרה כלשהיא. נתחיל מהאמצע- אם הספרה לא שווה, האם היא גדולה מן הספרה האמצעית? אם כן, נחתוך את הרשימה בחצי ונתחיל שוב, וכך הלאה. המעבר של &amp;ldquo;לחתוך בחצי&amp;rdquo; את המערך נותן לנו סיבוכיות של logn, במקום סיבוכיות של n, בה נצטרך לעבור איבר איבר במערך (דמיינו מעבר לפי שם שם בדפי זהב לפי הסדר של הא&amp;rsquo; ב&amp;rsquo;).&lt;/p>
&lt;p>הפונקציה &amp;lsquo;log&amp;rsquo; היא שיטה נעימה (או פחות?) יותר לשאלה: הבסיס בחזקת מה, ייתן לי את המספר x? בדר&amp;quot;כ כשרואים &amp;lsquo;רק&amp;rsquo; את המילה log, מתכוונים לבסיס 2.
כלומר, כמות הפעמים שנחתוך את המערך עד למציאת האיבר שלנו, היא &lt;em>במקרה הכי גרוע&lt;/em> פשוט החזקה. אם המערך שלנו הוא באורך 8, ייקח לנו במקסימום 3 פעמים שנצטרך לחתוך ולמצוא את האיבר שלנו.&lt;/p>
&lt;p>זה נהיה קריטי כשהמערך גדל מעריכית, אבל כמות האופרציות נשארת כפונקציה לוגריתמית.&lt;/p>
&lt;p>ומכאן אפשר לשאול, יש לנו חיפוש בינארי- למה צריך עץ בינארי? עץ בינארי גם מאפשר לנו חיפוש בlogn, אבל כמובן רק אם הוא עץ מאוזן (כדוגמת עצי AVL, אדום שחור). אם העץ אינו מאוזן, הוא &lt;em>יכול&lt;/em> לתת לנו חיפוש ב- logn, אבל החיפוש יכול להיות לינארי (בהתאם לכמות האיברים, n). לעומת זאת אם הוא מאוזן, הוא &lt;em>מבטיח לנו תמיד&lt;/em> חיפוש בlogn.&lt;/p>
&lt;p>היתרון שיש לעצים בינארים מאוזנים על פני חיפוש בינארי, הוא דווקא בהכנסה וההוצאה (insert, remove). בעצים בינארים מאוזנים גם ההכנסות וההוצאות נשארים logn (על אף שהם צריכים לאזן את עצמם), בזמן שבמערכים ההכנסה וההוצאה היא לינארית, בהתאם ל- n ולמיקום במערך שיש להוסיפה.&lt;/p>
&lt;p>לכן, המימוש של עצים בינארים יהיה מהיר יותר למקרים בהם לא רק יש צורך לחפש, אלא לבצע מניפולאציה כבדה על האיברים במערך.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">האם מיקרוסרביסים היא ארכיטקטורת העתיד?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/microservices/"/><id>https://neocode.blog/posts/microservices/</id><updated>2020-09-08T19:06:38+03:00</updated><published>2020-08-02T17:05:35+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">למעשה, מיקרוסרביסים כבר תפס חלק נכבד (אבל לא אבסולוטי) מארכיטקטורת הצד שרת של היום, אז השאלה הנכונה יותר לשאול היא &amp;lsquo;האם היא כאן להישאר&amp;rsquo;.
ההפך הגמור ממיקרוסרביסים היא ה&amp;rsquo;מונולית&amp;rsquo; הידועה (כלומר monolith), שהיא &amp;ldquo;הכל במקום אחד&amp;rdquo;. גם ה- UI, גם הלוגיקה של השרת, הכל- מודבקים עם סלוטייפ ביחד תחת unit אחד הפונה לדטאבייס אחד.</summary><content type="html">&lt;p>למעשה, מיקרוסרביסים כבר תפס חלק נכבד (אבל לא אבסולוטי) מארכיטקטורת הצד שרת של היום, אז השאלה הנכונה יותר לשאול היא &amp;lsquo;האם היא כאן להישאר&amp;rsquo;.&lt;/p>
&lt;p>ההפך הגמור ממיקרוסרביסים היא ה&amp;rsquo;מונולית&amp;rsquo; הידועה (כלומר monolith), שהיא &amp;ldquo;הכל במקום אחד&amp;rdquo;. גם ה- UI, גם הלוגיקה של השרת, הכל- מודבקים עם סלוטייפ ביחד תחת unit אחד הפונה לדטאבייס אחד.&lt;/p>
&lt;p>מיקרוסרביסים נולד מתוך האנליות של &amp;lsquo;single responsibility&amp;rsquo; שמתעקשת(ובצדק) לבודד את כל הלוגיקה למודולים נפרדים, שאינם תלויים באופן מוחלט, ואינם דבוקים אחד בשני.&lt;/p>
&lt;p>במיקרוסרביסים, כל לוגיקה או מודול מחולקים ל&amp;rsquo;סרביסים&amp;rsquo; שונים, שכל אחד פונה לדטאבייס משלו. כל סרביס יכול להיות כתוב בשפה אחרת, תחת כל רציונל שהוא רוצה (כל עוד אפשר לתקשר איתו). כל סרביס יכול להיות שרת שרץ על מכונה נפרדת או להשתתף תחת אותה מכונה תוך שימוש בפורטים שונים כד לגשת אליהם.&lt;/p>
&lt;p>היתרון הבולט של מיקרוסרביסים הוא היכולת לפזר מפתחים לסרביסים שונים, מבלי להתחיל לקבל מרק של קונפליקטים, כשבמונולית המפתחים היו נוגעים בצלחת האחד של השני. הדילוור (delivery) של פיצ&amp;rsquo;רים חדשים הופך למשמעותית קל ומהיר יותר.&lt;/p>
&lt;p>היתרון העצום השני, הוא היכולת לבצע scaling רק לסרביסים החמים שמשתמשים בהם הכי הרבה. בניגוד למונולית, שם אתה צריך להיגרר להרחבת השרת ו\או הזיכרון של כל השרת רק בגלל לוגיקה ספציפית אחת, למשל.&lt;/p>
&lt;p>היתרון האחרון(בערך) נובע מה-single responsibility, שמפרידה את המודולים אחד מהשני ומצמצמת קשירות בקוד.&lt;/p>
&lt;p>אבל בפיתוח (לפחות), לכל פתרון יש מחיר. והמחיר של מיקרוסרביסים הוא לא כל כך זול.&lt;/p>
&lt;p>ראשית, מיקרוסרביסים כמעט תמיד תהיה איטית יותר מכל ארכיטקטורה מונוליתית. אם במונולית המודולים תקשרו אחד עם השני דרך הזיכרון, התקשור עכשיו עובר לתקשורת דרך הרשת. אם אתה צריך לוגיקה, מידע או כל שירות אחר- אתה צריך לבצע קריאת HTTP לסרביס האחר, או לכמה סרביסים. פיתוחים כגון HTTP2 או מימושים מתוחכמים של parallelism קיימים ואולי עשויים להפוך את הבדלי המהירות לredundant, אבל עדיין מיקרוסרביסים איטית יותר.&lt;/p>
&lt;p>המחיר השני הוא הקושי לפתח. זה לא פשוט בכלל לתכנן סרביסים השונים אחד מהשני, כשכל אחד תלוי במידע מסרביס אחר. איך לגשת למידע? איך לקבל את המידע? הרבה סרביסים יהיו תלויים במידע מסרביסים שונים, ומימוש לא נכון יכול להפוך לסיוט מהלך על 10.&lt;/p>
&lt;p>יש לציין, המונח &amp;lsquo;מיקרוסרביסים&amp;rsquo; הוא מונח כללי שאינו מתאר רק ארכיטקטורת צד שרת. יש hype גם בתחומים אחרים כמו למשל micro frontend.&lt;/p>
&lt;p>עכשיו נותר רק לשאול, אצלכם עובדים עם מיקרוסרביסים או מונולית?&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">לכידות(cohesion) או; איך לסדר מגירה כמו שצריך.</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/cohesion/"/><id>https://neocode.blog/posts/cohesion/</id><updated>2020-09-08T19:00:38+03:00</updated><published>2020-07-29T17:06:52+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">הכוונה בלכידות היא עד כמה הרכיבים קשורים אחד לשני, בתוך מודול ספציפי. ככל שהלכידות &amp;lsquo;גבוהה&amp;rsquo; יותר, ככה &amp;lsquo;יותר טוב&amp;rsquo;.
במחלקה למשל, לכידות נמדדת ע&amp;quot;פ כמה כל הפונקציות משתמשות בכמה שיותר משתנים הקיימים בה. ככל שכל הפונקציות משתמשות בכמה שיותר משתנים בתוך המחלקה, כך הסממן ברור: הקשר בין המשתנים לפונקציונאליות של המחלקה חזקים יותר ולהיפך.</summary><content type="html">&lt;p>הכוונה בלכידות היא &lt;em>עד כמה&lt;/em> הרכיבים קשורים אחד לשני, בתוך מודול ספציפי. ככל שהלכידות &amp;lsquo;גבוהה&amp;rsquo; יותר, ככה &amp;lsquo;יותר טוב&amp;rsquo;.&lt;/p>
&lt;p>במחלקה למשל, לכידות נמדדת ע&amp;quot;פ כמה כל הפונקציות משתמשות בכמה שיותר משתנים הקיימים בה. ככל שכל הפונקציות משתמשות בכמה שיותר משתנים בתוך המחלקה, כך הסממן ברור: הקשר בין המשתנים לפונקציונאליות של המחלקה חזקים יותר ולהיפך.&lt;/p>
&lt;p>עוד מדד ללכידות, היא עד כמה הפונקציות במודול משרתות מטרה ברורה ומוגדרת. ככל שהמחלקה(למשל) שואפת להיות יותר פונקציונאלית ולצאת מתחום האחריות הברורה שלה, היא מאבדת מהשופטים נקודות (דוגמא קונקרטית: מתכנת, שאחראי לכתוב קוד, ועכשיו גם צריך לנקות את השירותים- זוהי הפרה ברורה של הגדרת המטרה שלו!).&lt;/p>
&lt;p>ולמה זה כל כך משנה? אז לכידות מתקשרת באופן עקיף ל&amp;rsquo;צמידות&amp;rdquo;, או בשפה העממית tight coupling. נגיד שאתם פותחים מגירת סכו&amp;quot;ם במטבח ומגלים שכל המגירה מבולגנת מהיסוד- מזלגות מעל הכפות וסכינים מעל הצלחות. לא רק שיהיה קשה לסדר את המגירה, היא לא ברורה בעליל. עכשיו תתארו שהמגירה מסודרת להפליא. מזלגות איפה שהמזלגות, וסכינים איפה שהסכינים. הכל מסודר, אפשר להכניס בקלות סכו&amp;quot;ם חדש למגירה.&lt;/p>
&lt;p>לכידות היא עוד מדד מרכזי ב- oo (הלוא object oriented) המאפשר לנו להוריד את הסמתוכה ש-oo מעודד אותנו לייצר, ולשמור על מודולים (ו\או מחלקות במקרה שלנו) מלהיות צמודים ותלויים אחד בשני. ככל שתחום האחריות מופרד אחד מהשני, קל יותר להבין את המערכת, לדבאג אותה ולשנות\להוסיף. או במילים פשוטות יותר: המתכנתים יזדקנו לאט יותר.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">הממ…To comment or not to comment?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/to-comment-or-not-to-comment/"/><id>https://neocode.blog/posts/to-comment-or-not-to-comment/</id><updated>2020-09-08T19:00:44+03:00</updated><published>2020-07-27T17:08:19+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">פעם, המנטרה הייתה ברורה- קוד עם דוקומנטציה ברורה ומסודרת לכל דבר. היום משום מה, הגישה הזאת התעדנה קצת.
הגישה היום הולכת ככה: הערות זה רע. התוצאה: רואים הרבה מאוד מערכות שלפעמים לא נמצא שורת comment אחת.
האם זה תקין? אולי. האם commenting הפך לילד רע?</summary><content type="html">&lt;p>פעם, המנטרה הייתה ברורה- קוד עם דוקומנטציה ברורה ומסודרת לכל דבר. היום משום מה, הגישה הזאת התעדנה קצת.&lt;/p>
&lt;p>הגישה היום הולכת ככה: הערות זה רע. התוצאה: רואים הרבה מאוד מערכות שלפעמים לא נמצא שורת comment אחת.&lt;/p>
&lt;p>האם זה תקין? אולי. האם commenting הפך לילד רע? לא בדיוק.&lt;/p>
&lt;p>נתחיל ממקרה קלאסי של נגד הערה: מפתח כתב פונקציה, תיעד כמה שורות יפות ומתובלנות את הביצוע של הקוד, והמשיך לדרכו. כמה ימים אח&amp;quot;כ, תיקן באג, שינה שורה או שתיים, והמשיך לדרכו. אבל רגע, מה עם הדוקומנטציה? אופסי.&lt;/p>
&lt;p>ברגע שמתכנת צריך לתעד ולכתוב דוקומנטציה מלאה לכל קוד\פונקציה, הוא ממש מבצע חתונה קתולית בינו לבין הקוד וההערות. יד ביד, כמו זוג אוהבים, הוא ייצטרך לתחזק גם את הקוד וגם את ההערות. זה יוצר עומס, בלבול, שגיאות וכמובן עצבים. וזה לא אמור להיות ככה.&lt;/p>
&lt;p>בעיה נוספת שהערות מייצרות לנו היא&amp;hellip;זמן. לכתוב הערות לכל דבר לא יתרום אף פעם ליכולת של הקוד, או לביצוע של הקוד. אם זמן הוא מרכיב קריטי בפיתוח, צריך ממש לשקול לדלג על שלב כתיבת ההערות.&lt;/p>
&lt;p>הגישה שהתפתחה לה כיום כנגד כתיבת הערות נקראת ROC, כלומר: Really Obvious Code. שהקוד ידבר בפני עצמו, יהיה ברור ומסודר. מי שיירצה להבין איך הקוד עובד, צריך להסתכל על הקוד ולא על הסיפור שמעליו.&lt;/p>
&lt;p>אז האם לכתוב הערות הפך לboogyman של המפתחים היום? אז לא, לא בדיוק.&lt;/p>
&lt;p>יש מקומות בהם דווקא כן צריך דוקומנטציה ברורה, למשל ב- public API, librarys, שם אתה זקוק שהמשתמש יבין את המימושים השונים ולא יילך לאיבוד. אבל גם שם אפשר ללכת בגישה קצת אחרת מאשר משל של ארנב וצב מעל כל פונקציה. הגישה אומרת כך: כתוב מה הפונקציה &lt;em>צריכה&lt;/em> לעשות, ולא &lt;em>מה היא עושה&lt;/em>. את הפונקציונאליות של הקוד משאירים לקוד עצמו, ואת הפילוסופיה מאחוריה- להערות.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">Composition Over Inheritance?</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/composition-over-inheritance/"/><id>https://neocode.blog/posts/composition-over-inheritance/</id><updated>2020-09-08T19:00:38+03:00</updated><published>2020-07-23T17:09:42+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">בפעם הראשונה שבניתי פרוייקט (ובמקרה הוא היה בג&amp;rsquo;אווה), הוא ככל הנראה היה הפרוייקט הכי שאפתני שלי; ניסיתי למפות את גוף האדם. ההשראה נבעה מהיכולת של Inheritance, שאיפשרה לי ליצור קשרים ויחסים בין אובייקטים.
מיותר לציין שהפרוייקט נגנז לאלתר, בעיקר בגלל קש קטן שהפך את כל הקשרים והיחסים שבניתי.</summary><content type="html">&lt;p>בפעם הראשונה שבניתי פרוייקט (ובמקרה הוא היה בג&amp;rsquo;אווה), הוא ככל הנראה היה הפרוייקט הכי שאפתני שלי; ניסיתי למפות את גוף האדם. ההשראה נבעה מהיכולת של Inheritance, שאיפשרה לי ליצור קשרים ויחסים בין אובייקטים.&lt;/p>
&lt;p>מיותר לציין שהפרוייקט נגנז לאלתר, בעיקר בגלל קש קטן שהפך את כל הקשרים והיחסים שבניתי. הירושה דפקה את הכל.&lt;/p>
&lt;p>לירושה יש הרבה יתרונות, אבל יש לה מספר חסרונות מצומצם, והרסניות. מביניהן, והפופולארית- אנחנו לא תמיד יכולים (או צריכים) ליצור קשר של אב-בן בצורה נכונה, כזאת שתואמת לעולם האמיתי. ברגע שנוצר צורך שאינו תואם ליחס שבנינו, הכל מתחיל להתפורר לנו ומתחיל שלב ה refactorrrr.&lt;/p>
&lt;p>מאז השרשתי את המושג הרכבה מעל ירושה- במקום ליצור קשר בין אובייקטים בעזרת ירושה, אפשר בעזרת הרכבה (לשתול רפרנס של &amp;ldquo;היחס&amp;rdquo; בתור אובייקט כפרופרטי במחלקה). זה מאפשר גמישות כשאתה רוצה לשנות את היחס, ופלוס קטן הוא שאפשר להחביא את הגישה לאובייקט, כלומר encapsulate, יתרון שאין לנו בירושה (לא תוכל להחביא את הגישה ל-human בירושה כשאתה משתמש באובייקט של person).&lt;/p>
&lt;p>פגשתי מתכנתים שנשבעים לא להשתמש בירושה בכלל- ולא בטוח שזאת גישה נכונה. לירושה יש את היתרונות שלה, במיוחד במניעת חזרה על הקוד.&lt;/p>
&lt;p>אני בד&amp;quot;כ לא מאמין בשחור ולבן- יש הרבה צבעים מסביב כשזה קשור לכתיבת קוד, ו&amp;quot;לשלב&amp;rdquo; זאת לא בהכרח מילה גסה בפיתוח.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry><entry><title type="text">Functional Programming</title><link rel="alternate" type="text/html" href="https://neocode.blog/posts/functional-programming/"/><id>https://neocode.blog/posts/functional-programming/</id><updated>2020-09-08T19:00:41+03:00</updated><published>2020-07-22T17:10:53+03:00</published><author><name>Aviv Cohen</name><uri>https://neocode.blog/</uri><email>coaviv104@gmail.com</email></author><summary type="html">אולי Functional Programming נשמע כמו שיעור סטודיו בחדר כושר, אבל למרות שהשם שלו נשמע מיינסטרימי, יש פילוסופיה שלמה ומעניינת מאחוריה.
המוטיב המרכזי שחוזר: פונקציות. לפשט את הכל לפונצקיות, ולהתייחס אל פונקציות בעדינות וחוכמה. כל קטע קוד שקיים במערכת, צריך להיות עטוף כפונקציה המבצעת פעולה אחת פשוטה, תוך קבלת קלט, ופליטת פלט כלשהו.</summary><content type="html">&lt;p>אולי Functional Programming נשמע כמו שיעור סטודיו בחדר כושר, אבל למרות שהשם שלו נשמע מיינסטרימי, יש פילוסופיה שלמה ומעניינת מאחוריה.&lt;/p>
&lt;p>המוטיב המרכזי שחוזר: פונקציות. לפשט את הכל לפונצקיות, ולהתייחס אל פונקציות בעדינות וחוכמה. כל קטע קוד שקיים במערכת, צריך להיות עטוף כפונקציה המבצעת פעולה אחת פשוטה, תוך קבלת קלט, ופליטת פלט כלשהו.&lt;/p>
&lt;p>הרעיון מאחורי המוטיב לקוח מהגישה המתמטית: הפונקציה מבצעת פעולה אחת, אתה יודע מה היא, ומה תהיה התוצאה בהתאם לקלט.
ובקוד, זה מתבטא בכך שאתה לא צריך &amp;ldquo;לדבאג&amp;rdquo; את הפונקציה ולהבין מה לא בסדר איתה, אלא אמור לקחת בחשבון שהיא &lt;em>עובדת כמו שצריך&lt;/em> (אם נכתב כמו שצריך), וגם ברורה בדיוק מה היא עושה, כך שאתה בכלל לא צריך להתחיל להיכנס לכל פונקציה בקוד. כל הבעיות שיכולות &amp;ldquo;לצוץ&amp;rdquo; צריכות להיות קשורות בשרשור והלוגיה של הפונקציות, ולא בפונקציות עצמן.&lt;/p>
&lt;p>בנוסף, בתכנות פונקציונאלי (שאתייחס כ-FP) כל האובייקטים הם immutable, כלומר ברגע שמייצרים אותם, אסור לשנות אותם. אם אתה רוצה לערוך אותם, תצטרך להחזיר עם פונקציה אובייקט חדש עם הערכים החדשים. לחידוד, להעביר כקלט את האובייקט לפונקציה ולערוך את האובייקט בתוך הפונקציה
עצמה לא מתקבל בחשבון.&lt;/p>
&lt;p>וכמובן, שאין יותר forloop, במיוחד fori (בגלל שהוא מבצע שינוי סטייט ל-i!), ובכדי לבצע איטרציה כלשהיא, משתמשים ברקורסיה (בכל זאת, אני ראיתי מספיק מתכנתיי FP שעדיין משתמשים בforeach, ולא נראה שהעולם קרס להם).&lt;/p>
&lt;p>לסיום, ל-FP יש מה לומר גם על error handling &amp;amp; null. מכיוון שפונקציות ב-FP הן כמו אלגברה, אין לך בדיוק ערך של NULL. השיטה המקובלת היא לעטוף את הערך המוחזר באובייקט כלשהוא, ולבדוק אם יש בו ערך (או לקרוא לפונקציה מתאימה). בשפות שמשרישות פילוסופיה FPית (כמו קוטלין וסקאלה) זה קצת יותר מחומם מזה.&lt;/p>
&lt;p>כדי למנוע אקספשיינס, ב-Go הפכו כל שגיאה לערך בפני עצמו. אתה כבר לא מקריס את האפליקציה כשנוצרת לך השגיאה, אלא מחזיר אותה בפונקציה כערך בפני עצמו (בדר&amp;quot;כ כסוג של Tupel) ונותן לקורא הפונקציה להסתבך עם עצמו. האם זה יעיל? אולי, אבל דורש המון שכפול קוד.&lt;/p>
&lt;p>בתמונה: קטע מאימון פונקציונאלי שרשורי, וקצת קריא יותר. החדי קרן מבינינו יבחינו שאפשר לקצרר את השורה עוד יותר.&lt;/p></content><category scheme="https://neocode.blog/tags/" term="Tags" label="Tags"/></entry></feed>