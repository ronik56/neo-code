[{"categories":["כללי","תקשורת"],"content":"פרוטוקול ה-TCP הוא אחת השכבות בפרוטוקול האינטרנט (IP) וכולנו משתמשים בו על בסיס יומי. הפרוטוקול מאפשר לנו ליצור ולתחזק תקשורת בין מחשבים שונים באינטרנט, או במילים אחרות אחראי על התעבורה.\nיש שלושה שלבים לפרוטוקול ה-TCP:\n  הקמת הקשר (session starting).\n  תעבורת מידע (data transmission).\n  סגירת הקשר (session ending).\n  נניח שאנחנו רוצים להתחבר לשרת כלשהו. בשביל להתחיל את התקשורת, קודם כל יש צורך להקים את הקשר. את זה המחשב עושה באמצעות לחיצת יד משולשת (Three-way handshake). בשלב הראשון אנחנו (ה-client) שולחים לשרת פקטה (packet) יחידה לשרת שנקראת SYN עבור synchronize (סנכרן) ובה אנו אומרים לשרת: ”היי, אתה יכול לפתוח קשר עבורנו?”. בשלב הבא השרת מגיב עם פקטה שנקראת SYN-ACK עבור synchronize-acknowledge (סנכרן-הכר). כאן השרת עונה לנו:”כן. האם גם אתם יכולים לפתוח קשר בשבילי?”. בשלב השלישי והאחרון אנחנו שולחים לו פקטת ACK ובעצם עונים לו “כן.” ונוצר קשר דו כיווני ביננו לשרת.\n  אבל איך זה נראה בפועל? כאשר אנו שולחים לשרת הודעת SYN אנחנו שולחים פקטה שמורכבת ממספר חלקים- SEQ, ACK, SYN. ה-SEQ הוא למעשה Sequence Number שכולל איזשהו מספר אקראי, נניח 1001. המספר הזה הוא המספור ההתחלתי של חתיכות המידע שישלחו. לאחר מכן יש את ה-SYN ו-ACK שהם דגלים שנושאים את הערך 1 או 0. אז בשלב הזה ה-SYN יהיה 1, שמסמל שאנחנו שולחים הודעת SYN, וה-ACK יהיה 0. כלומר ההודעה תראה כך: 1001-0-1 כאשר 1001 הוא המספר האקראי, ה-0 מסמל שזו לא הודעה ACK וה-1 מסמל שזו כן הודעת SYN. בשלב הבא השרת עונה לנו עם הודעת SYN-ACK, אבל היא נראית קצת אחרת. אם ניקח את הדוגמה הקודמת, ההודעה תראה כך: 2001-1002-1 תחילה נסתכל על האמצע, או ה-ACK. השרת לוקח את ה-SEQ ששלחנו לו, מוסיף לו 1 ומחזיר לנו אותו בתור ה-ACK. כך השרת מכיר בהודעה הקודמת שלנו שבה ביקשנו שיפתח עבורנו קשר. ה-1 מסמל את ה-SYN וה-2001 בתחילת ההודעה הוא ה-SEQ של השרת, שמביא לנו מספר SEQ משלנו. בשלב האחרון אנחנו מחזירים לשרת את ההודעה: 1002-2002-0 ה-0 בסוף מסמל את ה-SYN. מאחר שזו הודעת ACK ואין לנו SYN, אז הוא 0. באמצע יש לנו את ה-ACK. בדומה לשלב השני, אנחנו לקחנו את ה-SEQ שהשרת שלח לנו, 2001, והוספנו לו 1 כדי להכיר בבקשה שלנו.\nלאחר שסיימנו את ה-handshake אנחנו עוברים לשלב השני, וכאן מתחילה העברת הנתונים בין שני הצדדים. היתרון הגדול של ה-TCP על פני ה-UDP (עליו בפעם אחרת) הוא אמינות החיבור- אין דבר כזה packet loss ואנחנו מקבלים בוודאות את כל המידע שנשלח אלינו לפי הסדר. ה-SEQ מסמל את המספר הסידורי של הפקטות, מה שמאפשר לנו לדעת לפי איזה סדר אנחנו אמורים לקבל את המידע. זה מאפשר לנו גם לקבל את כל המידע בסדר הנכון ולא לערבב אותו וגם לקבל את כל המידע. על כל פקטה שקיבלנו אנחנו מחזירים הודעת ACK שמאשרת לשרת שקיבלנו. אם קרה ולא קיבלנו את המידע, השרת לא יקבל הודעת ACK וימשיך לשלוח לנו את המידע עד שנאשר שקיבלנו אותו. ככה אנחנו יכולים להיות בטוחים שהכל הגיע ולא פספסנו שום דבר. בפקטת TCP יש עוד חלקים שלא ציינו עד עכשיו, אחד מהם הוא גודל חלון השליחה (Window size). החלק הזה מציין כמה יחידות מידע אנחנו יכולים לקבל בכל פעם מהשרת והוא משתנה בהתאם לרוב הפס. כך נמנע מצב שהשרת שולח 100 יחידות בזמן שאנחנו יכולים לקבל רק 10 יחידות ונוצר צוואר בקבוק.  כמובן שלכל הפרוצדורה הזו יש מחיר- מהירות. במידה ואנחנו לא צריכים את הסדר המדויק ו-100% מהמידע או במקרים שמהירות ההורדה היא הכי חשובה, פרוטקול ה-UDP יהיה עדיף מאחר והוא חוסך את כל האימותים ומאפשר מהירות מרבית.\nלאחרי שהשרת סיים להעביר נתונים, מגיעים לשלב האחרון והוא סגירת הקשר. קודם כל, השרת שולח לנו פקטת FIN-ACK שבה הוא מעדכן אותנו שהוא סיים להעביר את המידע ומעוניין לסגור את הקשר. אנחנו עונים לו עם פקטת ACK שבה אנו מאשרים שקיבלנו את ההודעה שלו. לאחר שסיימנו להוריד את הנתונים (השרת מסיים לשלוח לפני שהלקוח מסיים לקבל שהרי יש דרך לעבור בינם, ככה שסיום הורדת הנתונים מצד הלקוח וסיום העברת הנתונים מצד השרת הם לא אותו הדבר) אנו שולחים לשרת הודעת FIN-ACK שבה מעדכנים אותו שסיימנו להוריד ושואלים אותו אם הוא שמע אותנו. בשלב הזה השרת שולח לנו הודעת ACK שמאשרת שהוא קיבל את ההודעה ואפשר לסגור את הקשר.  ","description":"","tags":["כללי","רשת","תקשורת","איך זה עובד?"],"title":"איך TCP עובד?","uri":"/posts/tcp/"},{"categories":null,"content":"השפה שהמכונה אליה אנחנו מדברים מדברת בבינארי כמובן, כלומר אם למכונה היה ילדון שהיא רצתה ללמד לספור עד עשר, היא לא תוכל להשתמש ב10 ספרות (אצבעות) כמונו. היא תיאלץ להשתמש בשתי ספרות: 0 ו-1. אנחנו בני האדם סופרים בבסיס של 10 ספרות, ואילו מחשבים בבסיס של 2 ספרות. הקסדצימל אומר אחרת: נספור ב16 ספרות! ומאיפה נביא את האקסטרה 6 ספרות? מהאותיות בשפה האנגלית A-F.\nהסיבה למה נבחרו האותיות F-A מרגיש אינטואיטיבי- כי הוא אכן אינטואיטיבי. אנחנו מכירים את הסדר של האותיות מה-‘קטן’ ל’גדול’, וזאת בדיוק הסיבה שאינטואיטיבי לבחור באותיות. וזאת גם אחת הסיבות לכך שאנחנו אינטואיטיבית נהיה מוגבלים בכמות הספרות שאיתן נוכל לספור- לאחר ה Z-A האנגלית, נוכל להמשיך להוסיף רק ספרות כמו $,%,# וכל’. מי יודע מי הספרה הכי קטנה?\nהסיבה למה לבחור בבסיס 16 באה מתוך הרצון לכווץ את האורך של רפרזנטציה של מידע כלשהוא בתצורה של בינארי. רפרזנטציה של טקסט בבינארי הופך לגוש ענק של 0 ו-1ים, כשייצוג בסיסי של אות (כמו אותיות) יהיה בארוך של 8 ספרות של 0 ו-1. N אותיות יתורגמו ל-N בחזקת 8 תווים של 0 ו-1ים.\nמכיוון שייצוג טריוויאלי של אות הינה byte אחד או 8 ביטים, אנחנו יכולים לייצג אות בעזרת 2 ספרות בלבד בהקס ע\"י כך שכל ספרה בהקס מיוצגת ע\"י 4 תאים עם שתי אפשרויות, 0 או 1. מכיוון שלכל תא יש שתי אפשרויות, אז סכום האפשרויות הוא 4^2, שזה בדיוק 16 הספרות שיש לנו בהקס. 0000 יהיה 0, 1111 יהיה F.\nהתרגום מבינארי להקס וההפך הוא מאוד נוח. מחלקים רפרזנטציה בבינארי לקבוצות של 4. (הקונבנציה היא להתחיל מימין לשמאל. אם יש מספר אי זוגי קטן מ-4, משלימים אפסים לימין) ומתרגמים כל קבוצה של 4 לרפרזנטציה שלה ב-hex. בשביל לתרגם ההפך, פשוט לוקחים ספרה ספרה בהקס, וממירים למקבץ של 4 הספרות בבינארי. למשל: 0001-0001 מתורגם ל-11. החלוקה ל-4 דומה לחלוקה שאנחנו עושים עם ספירה רגילה, כשאנחנו מחלקים מספרים ל-3 (100,000,000). באופן כללי כל בסיס שמתחלק ב-2 יהיה לנו נוח לספירה בגלל שבינארי הוא מטבעו 2 אפשרויות. 16 נלקח כבסיס הפופולארי בעיקר מתאמי נוחות והקלילות שלו לייחס מידע מביטים\\בייטים.\nאחרי שכיווצנו את המידע שמועבר (בין מכונות למשל) להקסדצימל- אפשר לשאול את עצמינו, איך נבדיל אם המכונה שלחה לנו מידע בתצורה של הקס? המספר ‘11’ אומר שני דברים שונים בבינארי והקס. הפתרון לכך הוא להצמיד בהתחלה סימן שמצהיר שמה שנשלח הוא מידע בתצורה של הקס. דוגמאות לכך הן ‘0x’ שמופיעה הרבה במערכות מבוססות unix, וכמובן בצבעים- כאשר מתחילים עם האשטאג ‘#’ ואחריו 3 זוגות של תווים כשל כל זוג מסמל 0-255 אפשרויות לאדום, כחול וירוק. בתמונה: איך להעביר ‘מספר רגיל’ מהקסדצימל לדצימל.\n","description":"","tags":null,"title":"למה משתמשים בהקסדצימל?","uri":"/posts/hex/"},{"categories":null,"content":"פונקציה אנונימית טיפוסית נראית בסגנון של x+1 \u003c= (x) ומציינת פונקציה שמקבלת ערך כלשהוא, מוסיפה לו 1, ומחזירה אותו. בסינטקס הזה אין לה שם, ואנחנו מוותרים על המילים return, function וברוב השפות גם על הטייפים של המשתנים. אנחנו בעצם מפשיטים פונקציה עד שמגיעים אל לוגיקה זריזה וקטנה, שאפשר לכתוב מהר עם מינימום חזרה על קוד וסינטקס ככל הניתן (מי יודע, אולי נוותר בעתיד גם על הסוגריים).\nפונקציות אנונימיות צריכות לקבל הרבה יותר קרדיט על השינוי שהן “אפשרו” בעולם התכנות הפרגמטי. הרבה שפות החלו להביע תמיכה בפונקציות first class citizen, שמשמעותן: לקבל את אותן זכויות של תכונות ואובייקטים אחרים. הכוונה היא שפונקציות יכולות להישלח כפרמטרים, לשמור אותן במבני נתונים, ולשמור אותם כמשתנים- ממש כמו כל תכונה של אובייקט. ופונקציות אנונימיות הפכו את זה לכל כך הרבה יותר קל.\nהרעיון של פונקציות כאזרח לכל דבר היה הרבה פחות נפוץ, לפחות גישתי, אצל רוב המפתחים בשפות הסטטיות. בד\"כ פונקציות היו נתפסות כpublic void doThis() , ואפשר לשחק עם לקרוא להן עם כל מיני encapsulation מגניבים ולרווח בין השורות כשקוראים להן.\nבמקרה הזה, החתימות של הפונקציות (השם שלהן, מה הן מחזירות וכל’) הן גם בדר\"כ ארוכות וחוזרות על עצמן. קוד של פונקציה פופולארית למציאה או סינון איבר, יכולה להגיע ל-2-5 שורות בכיף רב ולחזור על הפעולה חלילה עשרות ומאות פעמים.\nהיום הגישה קצת שונה: פונקציות הן לא אזרח סוג ב’, אלא מרכיב הכרחי ושווה ערך (first citizen) בחופש שלנו להנדס קוד מדויק ויעיל. הן החלק הכי קריטי בקוד, וצריך את היכולת לנוע איתן בחופשיות כמו אובייקטים. כל העסק התחיל לתפוס תאוצה, כשפונקציות אנונימיות החלו להתפשט בקוד.\nבשפות תכנות שתומכות בfirst citizen function, אנחנו יכולים לשחק עם פונקציות כמו עם לגו. אנחנו יכולים לשמור אותם בדיוק כמו שאנחנו שומרים אובייקטים- כמשתנה, או ברשימה או מילון. עם פונקציות אנונימיות קל ונוח להעביר אותם כפרמטרים בפונקציות, בדיוק כמו הפונקציות הפופולאריות כיום, map \u0026 filterהמקבלות פונקציה ורשימה כפרמטרים, ומפעילות את הפונקציה על כל אחד מהאיברים ברשימה (ובסוף מחזירים את הרשימה החדשה). כך, אנחנו יכולים לכתוב שרשור של פונקציות בשורה או שתיים, ולחסוך 10 שורות. הפונקציות הנ\"ל נקראות גם high order functions, כלומר פונקציות המקבלות פונקציה כפרמטר או מחזירות פונקציה. במקרה שלנו, הן מקבלות פונקציה המופעלת על כל איבר ברשימה.\nהגישה שהתכנות, לפחות כרגע, מנסה לסחוף אחריה היא להעדיף לשחק עם פונקציות מאשר לערוך ולהעביר אובייקטים. להעדיף להשתמש במקבצי לוגיקה קטנים, על פני ניסוח של פונקציות. ככה הרבה פחות שורות נכתבות, והרבה פחות חזרה על סינטקס מוכר. אפשר לומר שפשוט הרבה יותר קל ומהר לכתוב קוד ולתכנן לוגיקה.\n","description":"","tags":null,"title":"מה הן פונקציות אנונימיות ואיך הן השתלטו לנו על החיים?","uri":"/posts/annonymous-functions/"},{"categories":null,"content":"בעולם אוטופי, כל פונקציה שנקרא לה תניב לנו את המידע שאנחנו צריכים, ולא תעצור את הflow של הקוד. אבל אנחנו לא בעולם אוטופי, וכל פונקציה שנקרא לה טומנת בתוכה את הפוטנציאל להשתבש ולחשב לנו את המסלול מחדש. והאמת היא, שלהקריס תוכנה זה כנראה יותר קל מלקחת סוכריה מתינוק, אז מן הראוי שerror \u0026 exception handling תהיה המומחיות הכי קריטית בלשמור על התוכנה…עובדת. או במילים אחרות: רובוסטית, אנטי-שבירה, כזאת שבנויה להתמודד עם הלא רצוי ולא מצופה. איך כדאי לנו להתמודד עם תקלות בלתי צפויות בקוד? הדמיון הוא כמובן אינסופי, אבל יש מספר טכניקות פופולאריות שמשתמשים בהן: לזרוק שגיאה, להחזיר null, להחזיר אובייקט ריק או monad.\nלזרוק שגיאה ירגיש מאוד טבעי עם פונקציות IO שיכולות להתפוצץ, כמו שגיאה בחיבור למסד נתונים או באי מציאת קובץ. אנחנו נוכל גם לזרוק שגיאות תפורות אישית לבעיות מסוימות, וככה נוכל לאבחן את התקלות בקלות רבה ולהכין backup plans לכל שגיאה (כלומר, לרשת מה- Exception, לממש ולהחזיר שגיאות משלנו). לזרוק שגיאה מתאים למקרים בהם אנחנו רוצים ללכת בגישה של easier to ask forgiveness than permission, כלומר אנחנו נקרא לפעולה ונתפלל שהיא תעבוד. אם לא, אוקיי סליחה, ננסה משהוא אחר. שוב, פעולה של IO היא הדוגמה הכי אלגנטית למקרה כזה כי היא יכולה להיות בקלות פצצה מתקתקת. בג’אווה יש לנו checked exception שמכריח אותנו להתמודד עם כל פונקציה שעלולה לזרוק שגיאה. בזמן שזה נחמד בתיאוריה, הכפייה להתמודד תמיד עם שגיאה היא לא בהכרח הכרחית או רצויה, שכן יש מקרים בהם פשוט לא נרצה להתמודד עם השגיאה.\nבנוסף ללזרוק שגיאה, אנחנו יכולים להחזיר null, שמתאים לגישה של look before you leap, דהיינו תמיד לבדוק את מה שאנחנו מקבלים. הגישה מתאימה למקרים בהם null הוא פלט לגיטימי, כמו למשל כשאובייקט (שורה) לא נמצא בדטאבייס. אין הכרח לפוצץ את הפעולה, מכיוון שהפעולה הסתיימה בהצלחה ולא כשלה בגלל עצמה, אלא מכוח חיצוני לה (למרות שכן ניתן להטיל ספק במקרים בהם אי מציאה של אובייקט נחשב לכשל לוגי). להחזיר null עוזר לנו לצמצם קוד שמכיל הרבה trycatch, אבל בתמורה נצטרך לתחזק קוד עמוס ב != null, והכלל מספר אחד בקוד הוא: כל תחזוקה שוטפת עלולה להוביל לטעויות. מתכנת עלול לשכוח, או כמובן לא לדעת- שהפונקציה עלולה להחזיר null, ומלאך המוות יקפוץ לביקור.\nמקרים בהם לא מתאים לזרוק null, הם מקרים בהם אנחנו נרצה להחזיר אובייקט ריק. הדוגמה המושלמת לכך היא בהחזרת רשימה. רשימה ריקה היא ערך לגיטימי לחלוטין, ובמקרים נדירים בלבד נרצה להתמודד או לבדוק אם הרשימה היא null. יכול להיות שזה המקרה היחידי שמצדיק להחזיר אובייקט ריק, מכיוון שלהחזיר אובייקט ריק עלול להוביל לבאגים מסתוריים של מחסור בערכים באובייקטים מסוימים (זה יכול להתחיל שרשרת), ואנחנו נצטרך לחפש בדיוק איזו פונקציה מסתורית גרמה לכל הבלגן הזה.\nאופציה פופולארית נוספת, היא שימוש ברעיון של monad, שברמה הבסיסית שלו הוא מעטפת אבסטרקטית וגנרית המכילה בתוכה את האובייקט שאנחנו רוצים להחזיר, ויחד עם זה עוד מידע כמו השגיאה עצמה, הודעת שגיאה וכדומה. היתרון מספר אחד של מונאד הינו שהוא מגדיר סינטקס אחיד וברור, והוא שכל פונקציה מחזירה את המונאד, ובתוכה את האובייקט הרצוי כמו חבילה מאלי אקספרס. וכמובן, הוא עוזר למנוע nullpointexceptions לא מתוכננים כי המונאד אף פעם לא צריך להיות null. דוגמאות לכך הן ה-Maybe שקיים בתכנות פונקציונאלי וכמובן ב-reactive programming, וה- IO Monad שבהאסקל, שהם מתפקדים כ-קצת יותר ממעטפת אבסטרקטית.\nאנלוגיה נחמדה למתי נרצה להשתמש במונאד על פני לזרוק שגיאה, היא אם נרצה לחפש פריט בתוך קופסא מסוימת. אם לא נמצא את הפריט בקופסא- נרצה להשתמש במונאד (או נחזיר null). אם לא נמצא בכלל את הקופסא- נרצה לזרוק שגיאה. במקרה הראשון אנו ‘מצפים’ במידה מסוימת שיהיה פריט או לא, אבל במקרה השני אנחנו לא מצפים שלא נמצא את הקופסא.\nיכול להיות שכל הדרכים לגיטימיות בדרכים שלהן, עם קצת יתרונות אחד על פני השני. אפשר לטעון שאין צורך להחזיר null כל עוד משתמשים במונאד, אבל גם אפשר להשתמש תמיד ב-trycatch בלבד. בסופו של יום אנחנו רואים שלכל אחד אכן יש חוזקות משלו בהתאם לסיטואציה. לא כדאי להגדיר חוק אחיד של איך להתמודד עם שגיאות שקורות, אלא לתפור לכל בעיה את הדרך שלה להתמודד עם שגיאות. ככה נוכל להנות (כמעט) מכל העולמות ולהתמודד עם מינימום השלכות וחסרונות. but exceptions… exceptions never changes.\n","description":"","tags":null,"title":"דרכים לנהל שגיאות ואקספשנס","uri":"/posts/exceptions/"},{"categories":["חומרה"],"content":"מהדיסק הקשיח הראשון שפותח אי שם ב-1956 על ידי IBM והחזיק בשטח אחסון של 5MB ועד הקשיחים המודרניים שמחזיקים עשרות טרהבייטים (Terabytes) של מידע עברנו דרך ארוכה. אבל איך בדיוק אנחנו מאחסנים כל כך הרבה מידע על חתיכת מתכת בגודל של 3.5 אינץ’ (קצת פחות מ-9 ס\"מ)?\nכולנו יודעים מה זה מגנט, ובערך איך הוא עובד. קובץ קטן מאיתנו אולי גם גילה שאם נשפשף קצת את המגנט על מתכת כלשהי, כמו מסמר, אנחנו “הופכים” את המסמר למגנט, מה שנקרא מגנוט (Magnetization). באותה המידה שאפשר למגנט את המסמר, אפשר גם לבטל את התכונות המגנטיות שלו, כלומר להחזיר אותו למצב בו הוא לא מגנט (Demagnetization). מגנטיות זו תכונה שאפשר לתת למסמר, תכונה בעלת שני ערכים בלבד- ממוגנט, לא ממוגנט. כן, לא- 1, 0.\nבאותה הצורה בדיוק עובד דיסק קשיח, על ידי מגנוט (או ביטול שדה מגנטי) של מתכת. בדיסק הקשיח שלנו אין מסמרים כמובן, במקום זה יש לדיסק קשיח דיסקה שטוחה (platter), לרוב מאלומיניום או זכוכית או חומר קרמי דומה מצופה שכבה מתכתית משני הצדדים. הדיסקה מחולקת כיום למיליארדי איזורים קטנטנים שאפשר למגנט או לבטל את המגנוט שלהם. התכונה המגנטית נשמרת עד שמשנים אותה ידנית ולכן הקשיח שומר את המידע גם כאשר המחשב מכובה. דיסקים קשיחים יכולים לכלול בין 1 ל-5 דיסקות. מספר הדיסקות תלוי במחיר (קשיחים זולים יותר יחסכו עלויות עם דיסקה אחת) ובנפח הדרוש.\nלכל דיסקה יש 2 ראשי קריאה/כתיבה שמחוברים לבקר אלקטרוני והם זזים פנימה והחוצה (כלומר לכיוון מרכז הדיסקה או לכיוון הקצה שלה) בזמן שהדיסקה מסתובבת. רוב הקשיחים מסתובבים בקצב של 5400 או 7200 סל\"ד. כדי למנוע שחיקה יש שכבה של אוויר או נוזל כך שהראשים לא נוגעים בדיסקה.\nכמו שאמרנו, הקשיח שומר מידע ביחידות של 0 ו-1, כלומר ביטים (bit), בהתאם למגנטיות של הנקודה. בקשיח סטנדרטי של 1TB זה אומר שיהיו לנו 8,000,000,000,000 נקודות (8x10^12) עם הערך 0 ו-1 שיוצרות המון קבצים שונים. אם לשנות אפילו ביט אחד אנחנו יכול להרוס קובץ ולהפוך אותו לבלתי שמיש. אז איך המחשב יכול למצוא ביט אקראי אחד מתוך מיליארדים?\nהקשיח שומר את המידע באופן נורא מסודר. כל המידע מסודר במסלולים מעגליים (tracks). כל מסלול מחולק למקטעים (sectors) שכל אחד מהם מכיל מספר בייטים (bytes) שנע בין 512 ל-4096 . איזור יעודי בקשיח שומר מעיין מפה של איזה סקטורים תפוסים ואיזה לא וככה מערכת ההפעלה יודעת לאן להפנות את ראש הקריאה/כתיבה כדי לכתוב את הקובץ. קריאת מידע עובדת באותו האופן בכיוון ההפוך. המחשב שולט על הראש באמצעות בקר (controller) שנמצא על הקשיח.\nהיתרונות הכי בולטים של דיסקים קשיחים הם אמינות- הם מחזיקים המון זמן ויכולים לעמוד בכמויות עצומות של קריאה וכתיבה, מחיר זול ויכולת לאחסן כמויות גדולות של מידע.\nהחסרונות שלהם הם מהירות, רעש וצריכת חשמל. בזמן שקשיחים מגיעים למקסימום של 150-200MB/s בקריאה וכתיבה לדגמים היוקרתיים (ולרוב בין 100 ל-150), דגמי ה-SSD (האלטרנטיבה לקשיחים, פוסט עליהם יגיע בקרוב) הכי פשוטים נמצאים באיזור ה-300-400MB/s ומגיעים עד מהירויות של 3000-3500MB/s (ואפילו 5000MB/s עם ההשקה של כונני PCIe 4.0) לצרכן הביתי. ההבדל בשימוש השוטף הוא משמעותי- המחשב עולה תוך מספר שניות במקום 3-4 דקות ואפשר להשתמש בו באופן מיידי ולא לחכות כמה דקות עד שאפשר יהיה להפעיל את הדפדפן בלי שהכל יהיה תקוע ואיטי. מעבר לזה קשיחים רועשים יותר מאחר ויש פעולות מכניות של סיבוב, צורכים יותר חשמל (5-6 וואט לעומת 2-3 וואט, מתבטא בכמה שקלים בשנה לכל היותר) וגם כבדים בהרבה בגלל הדיסקות.\n","description":"","tags":["דיסק קשיח","חומרה","HDD"],"title":"איך דיסקים קשיחים עובדים?","uri":"/posts/hdd/"},{"categories":["כללי"],"content":"פרוטקול ה-BitTorrent הוא אחד הפרוטוקולים הכי מוצלחים ונפוצים בכל מה שקשור לשיתוף קבצים. הוא מאפשר הורדות מהירות באופן מבוזר (decenteralized) וגם נוטל חלק בלא מעט סקנדלים סביב זכויות יוצרים. אבל איך הוא עובד?\nהחלק הכי משמעותי ב-BitTorrent הוא שמדובר ברשת מחשבים מבוזרת, כלומר בלי שרת מרכזי. בהורדה “רגילה” מהאינטרנט אנחנו ניגשים לשרת מרכזי כשלהו ששומר את הקובץ אליו והוא שולח לנו אותו בשלמותו. לנו, ולכל אדם אחר שרוצה להוריד אותו. מעבר לצורך בתחזוקת שרת, דבר לא זול, עומס פתאומי יכול להוביל לקריסה והרבה יותר קשה להתמודד איתו. טורנטים לעומת זאת מבוססים על P2P- Peer-to-Peer. רשת של מחשבים שמתקשרים ישירות אחד עם השני בלי שרת מרכזי. כל מחשב ברשת נקרא עמית (peer).\nתחילה מישהו יוצר את הטורנט, לדוגמה עבור קובץ וידיאו. כל הפרטים הנחוצים נכנסים לקובץ torrent, קובץ קטן, לרוב באיזור כמה עשרות קילובייטים. הקובץ אותו הוא משתף (הוידיאו) מתחלק למספר חלקים שווים שנעים בין 32KB ל-16MB. לכל חלק ניתן hash שנוצר עם אלגוריתם SHA-1, מעיין קוד אימות, שנועד לוודא שהקובץ תקין ואין מידע פגום. המידע הזה נשמר במקור בקובץ ה-torrent. לכן ככל שהחלקים גדולים יותר כך גודל קובץ הטורנט קטן יותר, מאחר ויהיו פחות hash. כאשר מישהו מוריד חלק, ה-hash שלן מושווה ל-hash שנמצא בקובץ הטורנט לוודא שהוא אכן תקין. כאשר מישהו סיים את ההורדה במלואה ועכשיו רק משתף, הוא נקרא סידר – Seeder.\nכל מחשב שמעוניין להוריד את הקובץ מתקשר עם כל שאר המחשבים שרוצים להוריד את הקובץ וכולם מורידים אחד מהשני את הקובץ. בהתחלה, כאשר יש רק בן אדם אחד עם הקובץ שמעלה אותו, כולם יאלצו להתחבר אליו. כשהם הורידו את הקובץ במלואו, הם יהפכו לסידרים ויתחילו לשתף (לרוב עמיתים ברשת משתפים חלקים שהם כבר הורידו ברגע שהם הורידו אותם ולא מחכים לסיום ההורדה). ככל שיותר אנשים יורידו את הקובץ, יהיו יותר אנשים שמעלים את הקובץ והרשת תגדל. למעשה, ככל שיותר אנשים מורידים את הקובץ ככה הוא יותר עמיד בפני עומסים כבדים. כל אחד מוריד חלקים שונים מסידרים שונים וכך מאפשר לשפר את מהירות ההורדה.\nכשכל החלקים סיימו לרדת הקליינט (התוכנה שאנו משתמשים בה) מחבר אותם לקובץ אחד וסיימנו את ההורדה.\nלמעשה כאשר הטורנט “תופס תאוצה” ויש מספיק משתמשים נוצרת רשת סבוכה עם המון קשרים שנקראת swarm (נחיל). כל עמית מוריד מהמון עמיתים אחרים, במקביל. עמית אחד יכול להוריד מאות חלקים שונים של אותו הקובץ ממאות עמיתים, שכל אחד מהם גם מוריד מאות חלקים שונים ממאות עמיתים שונים.\nבתחילת הפרוטוקול לא היה מנוס מלהשתמש בקובץ ה-torrent. הקובץ כלל, מעבר ל-hash של החתיכות, רשימת טראקרים. טראקר היה שרת שכלל בתוכו טבלה של כל החברים ברשת ה-P2P, כלומר כל מי שמוריד/מעלה את הטורנט. את הרשימה הזו העביר לקליינט שלנו וכך הקליינט ידע למי אפשר להתחבר בכדי להוריד את הטורנט. הבעיה היא שעדיין מדובר ברשת שהיא תלויה בשרת מרכזי כלשהו ולא מבוזרת לחלוטין, גם אם מדובר רק בהורדה של רשימת טקסט.\nלכן פותח פרוטוקול ה-DHT (או Distributed Hash Table) שמאפשר לנו להוריד טורנטים בלי טראקרים והופך את הרשת למבוזרת כמעט לחלוטין. DHT הופך למעשה כל קליינט לטראקר בפני עצמו. באמצעות הפרוטוקול אפשר לפתוח לינקים מיוחדים, שנקראים magnet וכך אנחנו הופכים לצומת DHT (או DHT node)*. אנחנו מחפשים את הצמתים הקרובות ומהן משיגים מידע נוסף- צמתים נוספות. ככה אנחנו עוברים על רשת ענקית של צמתים שמספקות לנו כתובות hash נחוצות לפרוטקול, בנוסף לרשימת כתובות להורדה בלי צורך בטראקר, דהיינו שרת מרכזי. *אם המונח צומת לא מובן לכם, אז אפשר להסתכל על ה-magnet כקישור שנותן לנו מספר כתובות שמהן אפשר להוריד עוד כתובות וכן הלאה, כשכל כתובת היא שותף שאפשר להוריד ממנו את הקובץ.\nאת הטורנטים מוצאים לרוב באתרים שנקראים אינדקסים שכוללים רשימה של טורנטים ואת הקובץ או ה-magnet המתאים.\nבגלל המבנה של הטורנטים יש להם יתרונות יחודיים ועוצמתיים. קודם כל, מאחר וכל קובץ נשמר בכמות עצומה של עותקים, יש לנו redundancy עצום. בשפה פשוטה יש המון גיבויים והסיכוי של הקובץ להיאבד עקב תקלה בשרת (לדוגמה דיסק קשיח תקול) נמחק. מעבר לזה, מאחר וההורדה כוללת המון חלקים קטנים שלא תלויים באחרים, אפשר לעצור בכל שלב את ההורדה ולהמשיך אחר כך, בלי לאבד מידע, משהו שלא כל כך אפשרי בהורדה רגילה.\nלטורנטים יש גם חסרונות. הראשון הוא הפרטיות/אנונימיות. למרות שמדובר בכלי מאוד שימושי ופופולרי בהורדות פיראטיות (בין היתר בגלל כמות העותקים העצומה של הטורנטים שמפוזרת על פני יבשות), כל כתובות ה-IP חשופות לכולם. בכל קליינט אפשר לראות את רשימת השותפים שלנו עם כתובות IP מדויקות. זה גם מאפשר לגופי זכויות יוצרים לאסוף רשימה של כתובות IP ולשלוח אותן לספקיות בדרישה להורדת התוכן. במקומות מסוימים הם גם יכולים לתבוע את המשתמשים (אל תדאגו, זה בעיקר בארה\"ב, לא בישראל). הפתרונות יכולים להיות קליינטים דוגמת Tribler שמספק רשת דמוית Tor ואנונימיות או פרטוקול I2P. גם VPN (שדיברנו עליו בפוסט הזה: https://neocode.blog/posts/vpn/) מאפשר לספק אנונימיות בהורדת טורנטים. פתרון נוסף יהיה טראקרים פרטיים, אבל בהם ניגע עוד רגע.\nהחסרון השני של טורנטים הוא מה שנקרא leechers, או עלוקות. משתמשים שמורידים את הקובץ וברגע שהם סיימו להוריד הם מכבים את הטורנט במקום להיות סידרים ולמעשה לא תורמים בחזרה לרשת, מה שפוגע במהירות ההורדה של כולם וגם מעלה את הסיכוי שהטורנט ימות כי אין מספיק אנשים שמעלים אותו.\nאת הבעיה הזו וגם את הבעיה של האנונימיות פותרים טראקרים פרטיים. טראקר פרטי הוא טראקר וגם אינדקס שדורש הזמנה ו/או הרשמה. הם לא פתוחים לציבור ושולטים ברשימת המשתמשים שלהם ובכך נוצרת קהילה מבוקרת יותר ונשלטת. היתרון של רשימה כזו הוא מן הסתם היכולת להרחיק רשויות חוק, אבל מעבר לכך הוא מאפשר לעשות בקרת איכות למשתמשים. בטראקרים פרטיים משתמשים מחויבים לשמור על ratio, יחס העלאה הורדה מסוים כדי לוודא שאין leechers ושכולם תורמים ומחזירים. משתמשים רבים גם רוכשים seedbox, שרת יעודי עם רוחב פס גבוה (לרוב 1 גיגהביט העלאה) ושטח אחסון גבוה שיוכל לעשות סידינג לטורנטים 24/7 במהירויות גבוהות ולאפשר להם לבנות ratio טוב שיאפשר להם להוריד קבצים נוספים בלי להיחסם, ובכך הם מאפשרים להוריד כל טורנט מהטראקרים הפרטיים במהירות שיא, גם שנים אחרי שהועלה.\nלקבל הזמנה לטראקר פרטי זה לא הכי קל וצריכים למצוא מישהו שיכול לתת (רוב המשתמשים מקבלים מספר מסוימת של הזמנות, בעיקר כצ’ופר על סידינג ורטיו טוב) או להירשם בחלונות שבהם ההרשמה נפתחת לציבור הרחב.\n","description":"","tags":["כללי"],"title":"איך טורנטים עובדים?","uri":"/posts/torrents/"},{"categories":["כללי"],"content":"מי שחובב תכנות פונקציונאלי (Functional Programming), מכיר את המושג pure function, שמשמעותו פונקציה המספקת את התנאים הבאים: א) תמיד להחזיר את אותו הפלט ביחס לקלטת שהיא מקבלת, ו- ב) לא להכיל שום side effect בתוך הפונקציה עצמה, כמו: שינוי משתנה מחוץ לסקופ שלה, Input/Output, או כל דבר אחר שלא קשור לפלט של הפונקציה.\nכלומר, הפונקציה צריכה להיות תלויה בקלט שהיא מקבלת בלבד, ולא להתערב בשום דבר שאינו בתוך הסקופ שלה, או שאינו חלק מה\"עולם” שלה. זה אומר שאפילו לשנות אובייקט בתוך הסקופ שלה גורע ממנה את התואר.\nפונקציה PF היא אבן יסוד בפרדיגמה של תכנות פונקציונאלי, אשר שם דגש על כמה שפחות לשנות ולהשפיע על הערכים של אובייקטים קיימים (טכנית, הוא קשוח ומעודד שלא יהיה אפשר לשנות ערכים של אובייקטים לאחר שהם נוצרים, כלומר immutable). הדוגמאות הכי קלאסיות לתיאור פונקציות PF הן פונקציות מתמטיות, המסמנות וי בקלילות על שתי הדרישות. הן תלויות בקלט שהן מקבלות, וביחס אליו מחזירות את הפלט. לא קורה שום דבר אחר בין לבין.\nלפונקציה PF יש מספר יתרונות מאוד נעימים, וחסרון אחד מתסכל במיוחד. היתרון הראשון הוא שקל לבדוק פונקציה שכזאת. מכיוון שהפונקציה תמיד מחזירה את אותו הפלט ביחס לקלט, וגם היא אינה תלויה במידע שנמצא בערוצים אחרים כמו דטאבייס, יהיה קל יותר לבדוק אותה ולוודא שהיא מחזירה את התוצאה הנכונה.\nיתרון נוסף, הוא האפשרות לשרשר pure functions אחת עם השנייה. מכיוון שהלוגיקה והערכים שהן מחזירות הם ‘צפויים’ (predictable), אפשר להרכיב פונקציות ללא חשש מהשלכות לא צפויות של פונקציה אחת על השנייה (כאן הסדר שלהן יכול להיות משנה).\nפונקציות PF גם נוחות יותר לתכנות מקבילי (parallel), מכיוון שאסור לפונקציות הללו לקרוא מכל מקור אחר או לכתוב לכל מקור אחר מלבד הקלט שלהן. הן לא ישפיעו על מידע שלעוד טרדים (Threads) אחרים יש גישה אליהם, מה שבעצם מונע race condition.\nאבל לפונקציה PF יש חסרון מאוד קריטי: היא לא יכולה לבצע IO! אחרת התואר נשלל ממנה. אם היא מקבלת אינפוט ממקור אחר (read), היא תלויה גם בערך שהיא קראה אותו, ועלולה להחזיר ערך שאינו תלוי בקלט. אם היא משנה משהוא בדטאבייס (write), היא משפיעה על מידע במקור אחר.\nמבלי כל ביצוע של IO, אנחנו לא נוכל לקרוא מידע מהדיסק, מהרשת, או לקבל קלט מהאינטראקציה של המשתמש. איך פותרים את זה? ע\"י…לא, כרגע סוג של אי אפשר לפתור את זה.\nשפות תכנות פונקציונאליות כמו Haskell \u0026 Scala משתמשות ב- IO Monad, מעטפת אבסטרקטית ש’מאפשרת’ לפונקציות שלהן גם להיות IO ע\"י בוילר פלייט קוד שנכתב מאחורי הקלעים בשבילנו המתכנתים, אבל זה לא באמת פתרון.\nכך או כך, פונקציות PF ו- IO לא בדיוק יכולות להתקיים אחת לצד השניה. הפתרון האולי אלגנטי ביותר יהיה לכתוב את ה IO הרלוונטי עם הכלים שיש לנו, ואת שאר הקוד להמשיך לפי קווי היסוד של תכנות פונקציונאלי (למי שמעוניין כמובן).\n","description":"","tags":["כללי"],"title":"מה זה pure function, ומה ה’חסרון’ הכי גדול של זה?","uri":"/posts/pure-function/"},{"categories":null,"content":"קצת אחרי בועת הדוט קום, החלה מלחמת אופל בין SOAP ל- REST, שמטרתן הייתה לקבוע סטנדרט לבנייה ותקשורת בין “Web Services”, כלומר לקבוע איך בונים מערכות המתקשרות ביניהן דרך האינטרנט הגדול. בקרב הזה REST ניצח, לפחות לעת עתה.\nאת המושג REST, שנקרא Representational State Transfer טבע לראשונה רוי פילדינג, כמה שנים אחרי שמייקרוסופט שיחררה את הפרוטוקול שלה: SOAP. עם השנים REST הפכה לגישה הדומיננטית ביותר לבניית Web Services, בעיקר בגלל ש REST הייתה פשוטה יותר, נוחה, והרבה יותר גמישה וסלחנית. למשל, לפי REST אפשר להעביר מידע בתצורות שונות כמו ג’ייסון, XML וכד’. ב SOAP, אפשר להעביר מידע רק בתצורת XML.\nקשה להשוואת בין SOAP ל REST, מכיוון שאי אפשר. REST היא ארכיטקטורה עם סט חוקים שצריך ליישם, ו-SOAP הוא פרוטוקול. אך עדיין סרביסים התפלגו לכאלה שנבנים תוך שימוש ב SOAP כפרוטוקול תקשורת, וכאלה שעומדים בתנאים של REST.\nהגישה של REST מכריחה כל מערכת שרוצה להיחשב כ ‘RESTful’ לעמוד בתנאים הבאים:\nא) לחלק את המבנה לקליינט ושרת. הקליינט מציג את המידע, והשרת מעבד ושומר את המידע. שניהם צריכים להיות מופרדים ולא קשורים אחד לשני (או לדעת על קיום וזהותם אחד של השני).\nב) Stateless - המערכת לא צריכה לנהל שום סטייט של אף קליינט. זה אומר שהקליינט צריך לספק לשרת מספיק מידע בקריאה בשביל שהשרת יוכל לזהות את הקליינט ולבצע את הפעולות שהקליינט דורש ממנו.\nג) Caching- השרת יכול להחזיר לקליינט בקשה ולהצהיר לקליינט שהוא יכול לשמור את המידע שקיבל, ולהשתמש בו עד לפרק הזמן שהשרת ממליץ. כך הקליינט יכול לחסוך קריאה לשרת כשיש בידו את המידע העדכני. עוד דרך יכולה להיות בעזרת ETAG, כשמסמנים טוקן ייחודי לתשובה, והשרת והקליינט יכולים לוודא ביניהם אם המידע השתנה. אם המידע בשרת לא השתנה, הטוקן ETAG יהיה אותו טוקן מהתשובות הקודמות. אם הטוקן שונה- המידע השתנה ויש לבקש את המידע מחדש (עם טוקן חדש).\nד) האפשרות להרכיב שכבות בין התקשורת- הקליינט ו\\או השרת אינם חייבים לתקשר ביניהם ישירות. למשל אפשר להכניס middle man כמו פרוקסי שייתן עוד שכבת אבטחה או לוגיקה ביניהם. כל זה מבלי לשנות משהוא אצל השרת או הקליינט.\nה) ממשק אחיד (Uniform Interface) לתקשורת בין סרביסים ולקליינט-שרת. הבקשה מהקליינט צריכה לציין את צורת המידע שהוא מעוניין להעביר ולקבל, ועליו להעביר מספיק מידע בשביל שהשרת יוכל לעבד את הבקשה ולשנות את המידע בדטאבייס.\nלדוגמה, הקליינט רוצה לשלוח מידע בתצורת ג’ייסון, ולשמור את המידע בשרת. היא מזדהה בבקשה, מכניס בהודעה את המידע ומידע נוסף רלוונטי (כמו id כאלה ואחרים), ומשתמש בפרוטוקול מוגדר מראש POST שהשרת יודע שהוא נועד לשמירת מידע.\nבנוסף, כדי להקל על הניווט בין המידע שקיים בשרת, כל מידע מקבל ייחוס בדמות של לינק (resource), כך שאפשר לנווט אליו או לשנות את המידע. לדוגמה, אם יש לנו משתמשים והודעות של המשתמשים, אז הלינק המיוחס למשתמש יכול להיות /user ולהודעות /user/id/messages. השאיפה, היא ליצור שפה אחידה שתתרגם צורך מסוים, כלינק.\nהפאזל האחרון לממשק האחיד מכיל את המושג HATEOS - Hyper As The Engine Of Application Sate. הכוונה היא שהניווט באתר\\סרביס הוא דרך לינקים. השרת מחזיר בתשובתו טקסט (שכיום יהיה בדר\"כ אובייקט ג’ייסון) שמכיל בתוכו לינקים, והלינקים הללו הם ההוראות אל הקליינט (או סרביס אחר) לאיך לנווט באתר\\סרביס (אנאלוגיה למשתמש שנכנס לעמוד ראשי של אתר כלשהוא, ומשם מתחיל את הניווט שלו לאיך ליצור או לשנות מידע קיים\\חדש. השימוש בזה כיום הוא פחות נפוץ, כשרוב הקליינטים כיום מרנדרים לעצמם מראש את הלינקים בתוך הUI, ולא בדיוק מחכים להוראות מהשרת. אם הקליינט צריך לדעת איך לנווט ולגשת אל המידע, הוא פשוט משתמש בדוקומנטציה (כמו swagger).\nאם נחבר את כל הממשק, GET /users היא שפה אחידה ל\"הבאנה לי את המשתמש”. כיום בדר\"כ מציינים את תצורת המידע כג’ייסון. בתוך התשובה מהשרת, אנחנו אמורים לקבל גם לינקים המיוחסים למשתמש כמו שמירה (user/) או עריכה (user/1).\nנכון ש-REST היא הפופולארית ביותר, אבל אם אפשר לקרוא לכל סרביס שמגדיר את העצמו כ-RESTful, זה מעט שנוי במחלוקת. הרבה מאוד APIs לא באמת יכולים לסמן וי על כל החוקים (למשל, הרבה לא עובדים במדויק לפי HATEOS), אבל עדיין יכולים לתקשר אחד עם השני תחת הסטנדרט של פרוטוקול ה-HTTP. בנוסף, פרוטוקולים חדשים כמו GRPC מתחילים להתעורר ולתפוס תאוצה, כך שאולי נראה גישות חדשות ומודרניות יותר לבנות מערכות שמתקשרות דרך האינטרנט.\n","description":"","tags":null,"title":"REST מה זה?","uri":"/posts/rest/"},{"categories":null,"content":"איך שורדים עם רק 4 מיליארד כתובות IP לכל האינטרנט? NAT!\nכשאנחנו משתמשים באינטרנט אנחנו זקוקים לכתובת IP. כמו דואר רגיל, יש צורך בנמען ומוען- גם למחשב ששולח בקשה וגם לשרת שאליו היא נשלחת צריכה להיות כתובת IP כדי שידעו איך לתקשר ביניהם. בפרוטוקול ה-IP הנוכחי, IPv4, יש קצת יותר מ-4 מיליארד כתובות IP זמינות לשימוש, שזה בבירור לא מספיק לכמות המכשירים המחוברים לאינטרנט. מסיבה זו פותח פרוטוקול IPv6 שמגדיל את מספר הכתובות הזמינות לשימוש מ-4 מיליארד ל-340 undecillion, שזה 340 ואז 36 ספרות אחריו (340,282,366,920,938,463,463,374,607,431,768,211,456). אבל גם היום IPv6 לא בשימוש רחב מספיק ולא כולם תומכים בו. אז איך שרדנו עד עכשיו?\nקודם כל, חשוב להבדיל בין שני סוגי כתובות IP: ציבוריות ופרטיות. כתובות IP ציבוריות רשומות באופן פומבי וכולם יכולים לגשת אליהן. כתובת ה-IP של הראוטר שלכם ושל השרת שאתם ניגשים אליו היא כתובת ציבורית. לעומת זאת, כתובות IP פרטיות לא רשומות באופן פומבי וניתן לגשת אליהן רק בתוך הרשת, כלומר רק בתוך הבית או העסק.\nניקח לדוגמה את הרשת הביתית שלכם. הראוטר שלכם מקבל כתובת IP מהספקית שלכם. בשביל לחסוך 10-20 כתובות IP לכל מכשיר שמחובר לרשת הביתית שלכם, הראוטר משתמש בטכניקה שנקראת NAT (Network Address Translation). הראוטר מחלק לכל המכשירים שמחוברים אליו כתובות פרטיות, ששייכות לכמה טווחים שנקבעו לשימוש זה- כל הכתובות מהצורה 10.X.X.X, כל הכתובת מהצורה 172.16-31.X.X וכל הכתובות מהצורה 192.168.X.X, קצת פחות מ-18 מיליון בסך הכל. בטווח האחרון לדוגמה, המחשב יהיה עם הכתובת 192.168.0.1, הפלאפון 192.168.0.2 וכו’. כשאתם תגישו בקשה לאינטרנט, בעזרת ה-NAT הראוטר ימיר את הכתובת הפרטית לכתובת הציבורית ולכן כלפי חוץ כל המכשירים ברשת יחלקו אותה כתובת IP. ה-NAT עובד גם בכיוון השני, כשהבקשה חוזרת מהאינטרנט לכתובת הציבורית של הראוטר ואז בעזרת ה-NAT הראוטר מעביר אותה לכתובת הפרטית הנכונה, בין אם זה למחשב או לפלאפון.\nיש ארבעה סוגים או יישומים עיקריים של NAT:\n  SNAT - Static NAT: מדובר ב-NAT שמספק כתובת IP ציבורית קבועה לכל כתובת IP פנימית. אם להמשיך עם הדוגמה שלמעלה, אז נוכל לשייך את הכתובת הציבורית 91.198.174.192 לכתובת 192.168.0.1 וכך כל מי שניגש לכתובת 91.198.174.192 ייגש למחשב שלנו (או עם דוגמה יותר ריאליסטית- שרת FTP). כל מי שיגש לכתובת 91.198.174.193 יופנה לכתובת 192.168.0.2, כלומר לפלאפון (או לשרת מייל). הכתובות לא חייבות להיות עוקבות כמובן. מדובר ב-NAT מאוד בזבזני והוא משמש בעיקר לתנועה נכנסת. המטרה העיקרית שלו היא לחשוף שרת עם כתובת IP פרטית לאינטרנט הציבורי.\n  DNAT - Dynamic NAT: בדומה ל-NAT סטטי גם DNAT מספק כתובת ציבורית לכל כתובת פרטית, אבל באופן קצת שונה. כאן הראוטר מחזיק במלאי של כתובת IP ובכל בקשה כתובת IP פנימית מנותבת לכתובת IP זמינה ברשימה. לדוגמה, אם נתחבר עם המחשב, כלומר עם 192.168.0.1, נקבל את הכתובת 83.2.3.1. לאחר מכן נתחבר עם הפלאפון, ונקבל את הכתובת 83.2.3.2 וכן הלאה, כשכל מכשיר מקבל כתובת פנויה מהרשימה של הראוטר וכתובות מתפנות אחרי שהמשתמש התנתק. גם גישה זו בזבזנית והיא משמשת בעיקר לצורכי תנועה יוצאת. שיטה זו למעשה מסתירה את ה-IP של המשתמשים ומקשה על תוקפים חיצונים לזהות אותו, שכן כתובת ה-IP שלו משתנה באופן תכוף. השימוש של DNAT הוא דומו בעיקרון ל-SNAT, כלומר מתן כתובת ציבורית לכל כתובת פרטית שלנו, אבל הוא נוח במיוחד כאשר אין חשיבות לאיזה מכשיר יקבל איזו כתובת ואז, במקרה שיש לנו 250 שרתים לדוגמה, במקום ליצור 250 רשומות SNAT נוכל לספק פשוט כתובות באופן דינמי בהתאם למה שזמין.\n  PAT - Port Address Translation: הצורה הכי נפוצה של ה-NAT. כאן לכל מכשיר ברשת הפנימית (פלאפון, מחשב) יש כתובת IP פרטית (192.168.0.1, 192.168.0.2) ולראוטר יש כתובת IP ציבורית (91.198.174.192). במעבר בין הרשת הפנימית לחיצונית, כתובת ה-IP הפרטית מוחלפת לכתובת IP ציבורית עם תוספת של פורט. לדוגמה פניה מהמחשב תגיע לראוטר ותצא ממנו בצורה 91.198.174.192:8001, והפניה מהפלאפון תצא בצורה 91.198.174.192:8002. כך ה-NAT יודע לנווט בקלות את הטראפיק ויודע איזה מידע אמור להגיע לאיזה מכשיר בדיוק. יש כ-65.5 אלף פורטים זמינים לשימוש, חלקם שמורים לשימושים מסוימים (לדוגמה 22 ל-SSH, כאשר 80 שמור ל-HTTP ו-443 ל-HTTPS וכו’), אך יש עשרות אלפים שזמינים לשימוש.\n  Port Forwarding: רלוונטית בעיקר כשיש רק כתובת IP ציבורית אחת, אבל מספר שרתים ציבוריים שצריכים לחלוק אותה, ולכן גם בעיקר רלוונטית כשמדובר בתנועה נכנסת. כך לדוגמה אם נרצה לגשת לשרת ה-FTP שלנו, שכתובת ה-IP הפרטית שלו היא (192.168.0.1) וכתובת ה-IP הציבורית שלנו היא 91.198.174.192, אז עם Port Forwarding נוכל להפנות כל גישה לכתובת 91.198.174.192:21 לשרת ה-FTP שלנו. בדומה נוכל להפנות את הכתובת 91.198.174.192:25 לכתובת 192.168.0.2 שמשתמשת את שרת המייל שלנו, את הכתובת 91.198.174.192:80 לשרת ה-Web שלנו שנמצא בכתובת 192.168.0.3 וכו’.\n  ה-NAT כמובן לא חף מחסרונות. תרגום הכתובות לוקח זמן שיוצר דיליי ועלול לפגוע בביצועים (אם כי לא סביר שיורגש), תוכנות מסוימות עלולות לא לעבוד בגלל הגדרות לא נכונות, במיוחד אפליקציות שדורשות פורטים ספציפיים כמו שרתי Web או טורנטים.\nלסיכום, NAT זו טכנולוגיה שמתרגמת כתובות IP פרטיות וציבוריות ומאפשרת לנו לקבל אבטחה מוספת על ידי הסתרת כתובות IP של מכשירי קצה, להאריך את תוחלת החיים של ה-IPv4 על ידי חיסכון בכתובות ציבוריות ולהפריד את הרשת הפנימית שלנו מהרשת החיצונית. עם המעבר ל-IPv6 בעתיד הקרוב, לכל מכשיר קצה תהיה כתובת IP ציבורית משלו וה-NAT יהפוך מהר מאוד לנחלת העבר.\n","description":"","tags":null,"title":"על NAT","uri":"/posts/nat/"},{"categories":null,"content":"איך מתמודדים עם עומס על השרת(ים) כיום? אחת התשובות- Load Balancer.\nהרעיון של Load Balancer בעצם נהפך להכרח אצל הרבה חברות עקב הפריצה הענקית של המשתמשים באינטרנט. פעם עוד היה אפשר להרים את המחשב של אמא בתור שרת בסיסי בסלון כמו צוקרברג, אבל מהר מאוד זה הפסיק להיות לו כפתרון לגיטימי. בכלל, כיום אתרים ואפליקציות מתמודדות עם ריבוי בקשות עצום. הפתרון, נמצא איפשהוא בין שני סוגים של scaling לפניות.\nהראשון: vertical scaling, שהוא אומר; שדרג את המכונה(שרת). תוסיף עוד RAM, תחליף ל- AMD RYZEN ותרביץ מכונה שתצליח לעמוד בריבוי הפניות. הבעיה הגדולה ביותר של זה היא שיש גבול עליון של כוח מחשובי שאפשר להגיע אליו יחסית מהר והגבול הזה גם ככה לא מספיק (לשרתים שמתקשים לעמוד בעומס).\nהשני: horizontal scaling, שהוא אומר; שכפל את השרתים כך שיש ריבוי מכונות כדי שכולם יוכלו להתחלק עם הריבוי משתמשים\\בקשות.\nהבעיה שנוצרה מ- horizontal scaling היא; איך לחלק את העבודה בין המכונות?, כלומר איך להחליט לאיזה שרת להפנות בקשה מסוימת. איך יודעים מתי שרת א’ פנוי ושרת ב’ לא פנוי?\nאז הרעיון של Load Balancer נועד לפתור בין היתר את הבעיות הנ\"ל. Load Balancer בסיסי הוא כמו ראוטר, המפנה את הבקשות אל המכונות הרלוונטיים. בדר\"כ זה יהיה שרת שמתפקד כמו reverse proxy (או כ). הוא יושב בתקשורת באמצע של הקליינט והשרת (או חוות שרתים).\nיש שני סוגים של Load Balancers פופולריים, L4 ו- L7. אז L4 מתייחס לכך שיש לו גישה רק לפורטים וה-IPים של הבקשה, ו7L מתייחס לכך שיש לו גישה לכל המידע בבקשת http (כמו body, routes, headers).\nזה אומר ש- 4L יכול לבצע את הלוגיקה של הניתוב רק בעזרת הפורטים וה-IPים של הבקשה. ה-4L מתרגם את התקשורת TCP ומחליף את ה-IP שלו עצמו (הנמען של הבקשה מהקליינט) עם ה-IP של השרת שהוא מחליט לנתב אליו את הבקשה. זה נקרא NAT – Network Address Translation.\nל-L7 יש גישה למידע של הבקשה ולכן הוא יכול לבצע יותר לוגיקה בהתאם למידע. לדוגמה, להחזיר 401 כשה- authorization header של הבקשה ריק או לא תקין. L7 יודע גם לנתב בהתאם ל-routes, למשל ב- GET /images הוא ינתב לשרת הרלוונטי שמחזיר תמונות.\nל- L7 יש 2 תקשורות TCP, אחת של הקליינט, ואחת שהוא מייצר עם השרת המנותב. הסיבות ליצירת התקשורת השנייה היא למשל בשינוי המידע בפניה, ואז העברת המידע החדש עם התקשורת החדשה. בנוסף, הרבה פעמים L7 מיושם גם כ- SSL Termination Gateway (פיענוח של המידע המוצפן) במקום שהשרתים יצטרכו להיות up to date עם התעודות SSL שלהן. 7L הוא reverse proxy קלאסי עם יכולות ניתוב.\nיש גם כמובן Internal Load Balancers (בשפה של AWS) שהם חבויים ולא ניתנים לגישה פומבית, אלא נמצאים בתוך רשת פרטית ומנהלים שם את הinfrastructure. דוגמה לכך היא ה- Docker Swarm שמנתב ומנהל את הסרביסים\\שרתים שנמצאים בתוך השרת הפרטי.\nיש סוגים שונים של לוגיקה לכל Load Balancer שבעזרתו הוא מנתב את הבקשות לשרתים השונים, והלוגיקה תלויה בצרכים של האתר\\אפליקציה. ישנם אלגוריתמים כמו round robin, שהוא כמו לחלק קלפים לאנשים לפי הסדר; הבקשה מנותבת לשרת הראשון, אח\"כ לשני, שלישי עד אחרון השרתים- ואז חוזר חלילה לשרת הראשון.\nעוד אלגוריתם נקרא Weighted Response Time, אלגוריתם שמחשב מי השרת שמגיב הכי מהר- ואליו תנותב הבקשה. החישוב מתבצע בעזרת health checks שה- load balancer שולח בקשות מידי פעם ובודק את התקינות והמהירות תגובה של השרתים.\nאלגוריתם נוסף הוא Source IP Hash, שזה אלגוריתם בו ה-IP של הקליינט וה-IP של השרת אליה נשלחה הבקשה נתפרים יחד להאש (מפתח ייחודי), כך שיהיה אפשר לדעת בדיוק לאיזה שרת הקליינט ניגש בבקשה הקודמת, במידה והבקשה\\התקשורת נפגעה, או שיש לקליינט צורך ממשי להגיע לאותו שרת ספציפי. דוגמה לכך היא במקרים בהם הקליינט צריך גישה ל-session ספציפי, בשרת ספציפי.\nישנם מקרים בהם יש עומס של פעילות ביום וירידה חדה של פעילות בלילה. במקרים כאלה, יש צורך בלהעלות\\להוריד שרתים בהתאם לעומס הבקשות בזמן אמת. רוב העננים מאפשרים את היכולות הללו, בעזרת שכפול ה-image של השרתים כך שכל השרתים יהיו זהים ומתחילים לבצע סקיילינג אוטומטי של השרתים. ב- AWS זה נקרא Auto Scaling, ובאז’ור זה נקרא Scaling Set.\nעל פניו load balancer נראה מסובך, אבל הביצוע עצמו הוא דיי straight forward. רוב העננים מאפשרים להרים אחד כזה בכמה קליקים מבלי לעשות עמידת ידיים. גם הקונפיגורציה והלוגיקה של הניתוב לא מסובכים כשמבינים על פני השטח איך הדברים עובדים (או צריכים לעבוד).\nבאז’ור למשל, צריך לעשות את הדברים הבאים:\n-להגדיר רשת פרטית לשרתים ול- load balancer\n-להגדיר שרתים שאליהם אנחנו רוצים לנתב\n-להרים שרת load balancer (דרך אז’ור) בכמה קליקים\n-להגדיר לו הגדרות כמו health checks, ssl, routing\n-ליצור “Backend Pool” – בעצם לקשר את השרתים שלנו עם הבאלאנסר\n יש load balancer עובד!  ","description":"","tags":null,"title":"Load Balancer","uri":"/posts/load-balancer/"},{"categories":null,"content":"אם אתם רוצים ליצור איתי קשר אפשר לשלוח הודעה בדף הפייסבוק כאן או לשלוח הודעה במייל: coaviv104 at gmail dot com.\nאם אתם מעוניינים לכתוב פוסט אורח (עם קרדיט כמובן) אז אפשר למלא את הטופס שכאן או פשוט ליצור קשר במייל שלמעלה.\nדרישות לפוסט אורח: רוב הפוסטים קצרים ויהיו בין 300 ל-1000 מילים בנושאים שקשורים לתכנות או לטכנולוגיות שמסביב- בין אם רשתות או codecs. גם פוסטים טכנולוגיים שהם off-topic יכולים להתקבל, אבל פחות ודאי מאשר הנושאים האחרים. פוסטים מפורטים וארוכים מעל 1000 מילים יכולים להתקבל אבל סביר שיפוצלו למספר חלקים. הסגנון צריך להיות פחות או יותר דומה לשאר הפוסטים באתר. ידע מקצועי בשפה קולחת. כל עוד הפוסט מעביר את התוכן באופן ברור, זה בסדר.\nכשאתם ממלאים את הטופס, כדאי להציג את הנושא, כמה נקודות שעליהן הפוסט ידבר ואפשר גם פסקה או שתיים לדוגמה. חבל לכתוב פוסט שלם במידה ולא יאושר, אבל אם אתם מתעקשים זה בסדר.\n","description":"","tags":null,"title":"צור קשר/פוסט אורח","uri":"/contact/"},{"categories":null,"content":"כולנו נתקלנו בפרסומות ואינסוף חסויות לשירותי VPN מכל מיני סיבות- אבטחה, פרטיות או סתם בשביל לצפות בנטפליקס אמריקה. אבל איך בדיוק VPN עובד?\nבעבר, VPN (או Virtual Private Network – רשת פרטית וירטואלית) היה בשימוש בעיקר בקרב עסקים, בדגש על חברות גדולות, בכדי לאפשר לעובדים לגשת לרשת המאובטחת במשרד מהבית באמצעות חיבור מאובטח. בשביל להבין למה היה צורך ב-VPN, כדאי להבין איך אנחנו מתחברים לאינטרנט.\nנניח שאנחנו רוצים להיכנס ליוטיוב מהמחשב, פלאפון או כל ציוד קצה אחר. קודם כל המידע נשלח מהמחשב שלנו לראוטר/מודם. לראוטר/מודם יש כתובת IP שמהווה מזהה, מעיין תעודת זהות. משם הבקשה עוברת לספקית האינטרנט שלנו, לאחת מחוות השרתים שלה, סביר להניח שבפתח תקווה או בתל אביב.\nמשם המידע יוצא דרך כבל תת ימי לאיטליה, ומשם מדלג ברשת ענק של “כבישים” בדמות סיבים אופטיים על אדמת אירופה משרת לשרת עד שמגיע לשרת המיועד של גוגל. הבקשה מגיעה ליוטיוב, הוא בתגובה שולח את התגובה ומחזיר אותה כל הדרך חזרה.\nאז איפה הבעיה? קודם כל, בכל נקודה בדרך המידע שלנו חשוף ללא מעט עיניים. מידע שעובר באופן לא מוצפן יהיה נגיש לכל בעל גישה לנקודות האלו. זו הסיבה שלהשתמש באינטרנט ציבורי, בין אם בבית החולים או בבית הקפה, כדי להתחבר לבנק הוא לא צעד מומלץ. כל אדם עם קצת ידע טכני יוכל לקרוא את כל המידע שעובר ברשת- כל הודעה, כל סיסמה. אבל גם אם המידע מוצפן, המידע שלנו נגיש להרבה גורמים אחרים. הספקית והרבה מהנקודות בדרך יכולות לראות לאן אנחנו רוצים לגשת ולקבל את היסטורית הגלישה שלנו ומידע שאולי היינו מעדיפים לשמור לעצמנו. גם האתר יוכל לראות מי אנחנו. כל הגורמים כמעט בוודאות שומרים לוגים מפורטים עם המידע שלנו.\nוכאן נכנס ה-VPN לתמונה. בכדי לייצר חיבור המאובטח ה-VPN יצר מעיין תעלה (Tunnel Protocol) שמהווה מעטפת מאובטחת לחיבור. ברגע שמזוהה חדירה כלשהי לתעלה, ה-VPN מנתק באופן מיידי את החיבור ומחבר את הלקוח באמצעות נתיב אחר. כלומר אם באיזשהו שלב בסדרת הדילוגים אחד השרתים שנחתנו עליהם “חשוף”, ה-VPN יעבור לנתיב אחר. במקום לעבור מבארי איטליה לציריך ומשם לפרנקפורט, ה-VPN אולי יזהה שהחיבור דרך ציריך חשוף, ינתק אותנו ויחבר מחדש בנתיב שעובר מבארי לרומא, משם לבאזל ולבסוף יגיע לפרנקפורט.\nבתוך התעלה הזו עובר המידע כשהוא מוצפן. כך גם אם למישהו יש גישה לתחנה כלשהי בדרך, הוא לא יוכל לקרוא את המידע ששלחנו- לא ברשת פרטית ולא ברשת ציבורית.\nואם כל זה לא מספיק, המידע עובר בתחנת ביניים- שרת ה-VPN. כשאנחנו מחוברים ל-VPN אנחנו שולחים את הבקשה מוצפנת לשרת ה-VPN. השרת מפענח את הבקשה ומביא לנו אותה. הוא מהווה מעיין מידל מן- במקום לשלוח הודעה ליוטיוב באופן ישיר, אנחנו שולחים הודעה ל-VPN ואז הוא שולח את ההודעה ליוטיוב ובכך מסתיר את הזהות שלנו מיוטיוב, שמבחינתו מי ששלח לו הודעה זה שרת ה-VPN, לא אנחנו. בזכות ההצפנה גם כל הנקודות בדרך לשרת ה-VPN לא יודעות מה ביקשנו, כי המידע מוצפן. הן רק יודעות ששלחנו בקשה כלשהי לשרת כלשהו.\nזו גם הסיבה ש-VPN מאפשר לנו לצפות בנטפליקס במדינות זרות- אם נניח שאנחנו מחוברים לשרת VPN בניו יורק וגולשים בנטפליקס, מבחינת נטפליקס התקבלה בקשה ממחשב מתל אביב אלא מקבל בקשה ממחשב בניו יורק ולכן הוא יציג לו תוכן שמתאים לתיוג הגיאוגרפי של ניו יורק. כך גם לגבי כל חסימת תוכן על בסיס גיאוגרפי אחר- בין אם ב-BBC או ביוטיוב.\nגם כשמדובר בצנזורה במדינות כמו סין או איראן ה-VPN פותר את הבעיה בדרך דומה- במקום לגשת לשרת ויקיפדיה, ניגשים לשרת ה-VPN. המדינה לא יכולה לראות מה שלחתי ל-VPN ולכן הבקשה עוברת, משם ה-VPN מבקש בעצמו מויקיפדיה את האתר ושולח לנו אותו בחזרה מוצפן. ככה ניגשנו לויקיפדיה בלי שהאח הגדול ידע- מבחינתו ביקשנו משהו משרת כלשהו ולכן זה בסדר.\nאז מה הקאטץ’? יש כמה. דבר ראשון, חולשה די בולטת היא שרת ה-VPN עצמו. הוא יודע מי שלח את הבקשה והוא יודע מה היא (הרי הוא הוריד את ההצפנה כדי לקרוא). אנחנו למעשה צריכים לסמוך על חברות ה-VPN שהן מוחקות את הלוגים שלהן.\nבעיה נוספת היא המהירות- ההצפנה והנקודה הנוספת, במיוחד אם היא רחוקה, יכולה להאט דרסטית את הגלישה. במקרה שאנחנו מתחברים מישראל דרך ארהב לאתר אירופאי לדוגמה, אנחנו נתחבר מהבית, לספקית, לאיטליה, לפרנקפורט, משם לונדון/אמסטרדם, לניו יורק, לשרת ה-VPN, שאחר כך ישלח את הבקשה לניו יורק, לונדון, נקודה כלשהי באירופה, חזרה ללונדון, ניו יורק, שרת VPN ושוב לניו יורק, לונדון, פרנקפורט, איטליה, ישראל, אלינו. אם אנחנו ניגשים לשרת אמריקאי אנחנו חוסכים 2 כיוונים לאירופה, אבל עדיין מדובר בדרך שחוצה יבשות ואוקיינוס ואנחנו נחווה ניחות (גם אם לא אחד שיורגש יותר מדי).\nעם זאת כדאי לציין שבשעות עומס לפעמים דווקא ה-VPN יכול להיות יותר מהיר, בגלל שהוא עובר ב\"סמטאות” אינטרנט מאובטחות יותר ולכן ניגש לשרת בדרך פחות עמוסה, בניגוד לרוב האנשים שיעברו דרך כביש סואן.\n","description":"","tags":null,"title":"על VPN","uri":"/posts/vpn/"},{"categories":["."],"content":"אם נשאל את דוד בוב, זה כנראה יהיה עד 100…\nקשה באמת להגדיר כמה ארוכה פונקציה צריכה להיות, וכנראה שאי אפשר לנקב במספר ממשי (כל מספר שננקב כנראה יהיה שרירותיׂ), אבל אפשר להתווכח שלפונקציות קצרות יש מספר יתרונות בולטים שקשה להתעלם מהם.\nכשאני מתייחס לפונקציות קצרות, הכוונה היא לפירוק הקוד בפונקציה אחת לתתי פונקציות. או כמו שחובבי פילוסופיית היוניקס אוהבים לומר: כל פונקציה צריכה לעשות משהוא אחד, ולעשות אותו טוב. הקוד לא צריך להיות מושפע מאורך הפונקציה. הקוד הוא חלק נפרד, שנכתב בהתאם ליעילות הרלוונטית ועד כמה הוא קריא.\nאם ניקח פונקציה ארוכה מאוד ונתחיל לפרק אותה לתתי פונקציות, הדבר הראשון שיבלוט בעין זה שקל יותר להבין מה הפונקציה עושה (אם זה לא ברור לפי השם), ובערך איך היא עושה זאת. זה משמעותית תופס את העין מאשר קטע קוד ארוך שצריך להתחיל לקרוא שורה שורה ולתפוס את התמונה כמו פאזל לא מורכב (לא משנה עד כמה הקוד ‘קריא’).\nבנוסף, עטיפת קטעי קוד בפונקציות נותנת לנו עוד שכבת הפשטה. שכבת ההפשטה הזאת מעודדת אותנו להשתמש יותר בפונקציות הקיימות, מצמצמת חזרה על קוד קיים, ומאפשרת לנו יותר גמישות פונקציונאלית בתוך הפונקציות.\nמבחינת דיבוג גם יש יתרון- יהיה קל יותר לדבאג פונקציות מפורקות מבלי שנצטרך לדעת איזה חלק בקוד לתפוס כנקודת עצירה.\nטסטים גם עשויים לקבל יתרון כשאפשר לבנות יוניט טסטים על פונקציות בודדות במקום על אחת (למרות שעל עקרון כזה יש וויכוח, האם צריך לבדוק את התוצאה של הפונקציה דרך תתי הפונקציות שלה, הוא דרך הפונקציה כמכלול?).\nאני אף פעם לא בעד פתרונות שחור או לבן- כי כנראה פתרונות כאלה לא קיימים, לפחות לא בתוכנה. אבל לפונקציות קצרות, המפורקות לתתי פונקציות, כן יש יתרונות מאוד בולטים שקשה להתווכח איתם. לגבי חסרונות? אולי שיש יותר מידי לגו לשחק איתם, והשאלה היא אם זה חסרון מספיק גדול.\n","description":"","tags":[""],"title":"כמה ארוכה פונקציה צריכה להיות?","uri":"/posts/function-length/"},{"categories":["."],"content":"מה זה כל האסקים, UTFים וכל קידודים האלה?\nנתחיל מהאב הקדמון- קוד מורס האגדי. קוד מורס הומצא כשיטה להעביר הודעה דרך אמצעים אלקטרונים ולתרגם את הצלילים המועברים לאותיות. את ההודעה בונים בעזרת תקשורת בינארית(בתוספת של רווח בין הצלילים)- נקודה או קו. כך למשל את ההודעה “SOS” שכולנו מכירים, אפשר לקרוא בקוד מורס כ- “… - - - …”, ואם נשמע את הצליל של ההודעה הזאת, הוא יהיה מאוד מוכר לכולנו מאיפשהוא (כי טחנו את הצליל בכל מקום בסרטים הישנים).\nקוד מורס שירת את האנושות עד עליית המחשבים והתקשורת בין המחשבים, המשתמשת בתקשורת בינארית של 0 ו-1, דאז האנושות הייתה צריכה להתקדם קצת ולמצוא דרך חדשה לתרגם את המידע שנשמר או נשלח ברשת בצורה של 0 או 1’ים- לתווים ומספרים ממשיים.\nאז שיטות להפיכת מספרים רגילים לבינאריים וההפך- היה לנו. 1 זה 1, 2 זה 10, 3 זה 11 וכל’. אבל לתווים- לא היה לנו.\nואז נולדה לה טבלת ה- ASCII, שהיא מכילה את כל התווים של המקלדת שלכם, כש-33 התווים הראשונים מיוחסים ל\"פקודות” כמו SPACE, TAB, ESC , ו-65 עד 127 לשאר התווים כמו אותיות קטנות וגדולות (באנגלית בלבד- זה חשוב), + - = וכל’. הטבלת ASCII הראשונית הייתה מוגדרת ל- 7 ביטים לייצוג תו, כך שיש 128 אפשרויות סה\"כ. עכשיו אפשר לחזור אחריי: 1000001 זה A, ו- 1000010 זה B. הוריי אפשר לתרגם תווים מבינארית לאנגלית!\nעל אף ההתקדמות המטאורית, שאפילו בעזרת טבלת ASCII הטיסו חללית לירח, היה נחוץ בעוד פריצת דרך: אנחנו רוצים להעביר תווים בינלאומיים בכל העולם, ולא רק באנגלית. מה עם קצת אותיות בסינית, רוסית ועברית? ומה עם קצת אימוג’יז?\nשוב נכנסנו להריון והפעם הולדנו את ה- Unicode, שהיא טבלה שאפתנית המאכלסת את כל התווים בעולם- עברית, רוסית, יפנית, אימוג’י, ועוד (לכל תו יש “code point” שהוא המזהה הייחודי שלו בטבלה). עכשיו יש לנו טבלה משודרגת, וכל שנותר לנו הוא לייחס כל תוו לייצוג הבינארי שלו. לשם כך נוצרו להם קידודים שונים עם חוקים משלהם.\nכאן נכנס UTF-8 לתמונה. UTF-8 בהגדרתו הוא שימוש ב-8 ביטים לפחות לייצוג של תוו כלשהוא, הכולל את השימוש הרגיל של ה- ASCII שלנו. זה אומר, שהייצוג של A ב-UTF8 יהיה 01000001. גם ב- ASCII אגב הורחבו התווים מ-128 אפשרויות ל- 256 אפשרויות, כיאה לקומבינציות של byte אחד.\nמחיפוש בגוגל נתון שיש כ- 143,859 תווים ל-unicode, אבל התשובה כנראה מורכבת יותר. בכל מקרה, זה הרבה מעל ל-256 האפשרויות שיש בבייט אחד. אז מה עושים? ממשיכים לעוד בייט, ועוד בייט עד 6 בייטים (כלומר הקפיצות יהיו של bytes).\nומה עם UTF 16, 32? אותו רעיון- הייצוג של כל תו יהיה לפי 16 או 32 ביטים בהתאמה. לפי ההיגיון UTF-8 נשמע יעיל יותר, מכיוון שכל תוו מיוצג במינימום של 8 ביטים, בזמן שהאחרים ע\"י 16 ו-32, אבל זה לא מדויק. ישנם מקרים בהם דווקא להשתמש ב 16-UTF יעיל יותר (כמו בשפות אסיאתיות מסוימות), שכן פרזנטציות של אותיות בשפות מסויימות ב- 8UTF יהיו בגודל 4 בייטים, וב-16 יהיו בגודל 2 בייטים. בנוסף, מכיוון שטבלת ASCII תומכת בייצוג של 8 ביטים לתו, אז קידודים כמו 16,32 UTF לא ייתמכו במערכות המתבססות על ASCII.\nלקינוח, מה זה בדיוק codec? זה פשוט הסוג של הקידוד שאנחנו משתמשים בו. UTF-8 למשל, הוא סוג של codec.\n","description":"","tags":[""],"title":"UTF-8, ASCII \u0026 Unicode","uri":"/posts/utf-ascii-unicode/"},{"categories":["."],"content":"Asymmetric encryption \u0026 public/private puke\nבעידן של היום, כשהפרטיות והאבטחה שלנו ברשת רק הולכות ונשחקות, כדאי להיזכר בחשיבות של ההצפנה- מהיסודות של אינטרנט פתוח, חופשי ומאובטח. ובגזרה הזו הצפנה אסימטרית היא השיטה הכי נפוצה וכנראה שהכי חשובה, אבל עד כמה אתם יודעים איך היא עובדת?\nבשביל להבין את הצורך בהצפנה א-סימטרית כדאי להכיר את ההצפנה הסימטרית הפשוטה יותר. בהצפנה סימטרית אנחנו משתמשים במפתח סודי אחד גם לפיענוח וגם להצפנה. כלומר אם א’ וב’ רוצים להעביר ביניהם קובץ מוצפן סימטרית, א’ יצור מפתח סודי (סיסמה) שישמש להצפנת הקובץ, ישלח את הקובץ המוצפן לב’ ואז ב’ יצטרך להשתמש באותו המפתח של א’ בכדי לפענח את ההצפנה ולקבל את המידע הנחוץ.\nהבעיה היא שגם השולח וגם המקבל צריכים להיות עם אותו המפתח הסודי, מה שאומר שהם יאלצו לשתף אותו ביניהם בדרך כזו או אחרת, כך שבשלב כלשהו בדרך הם יאלצו לשתף את המפתח באופן לא מוצפן- וזה רע.\nאת הבעיה הזו פותרת הצפנה א-סימטרית. בהצפנה א-סימטרית משתמשים בשני מפתחות- מפתח ציבורי ומפתח פרטי. המפתח הציבורי חשוף לכולם, והוא המפתח שיוצר את ההצפנה. השולח נעזר במפתח הציבורי של המקבל בכדי לייצר קובץ מוצפן.\nעל מנת לפענח את ההצפנה יש להיעזר במפתח הפרטי, שנמצא רק אצל המקבל. גם השולח לא יכול לפענח את הקורס שהוא עצמו הצפין מאחר ואין לו את המפתח הפרטי.\nדוגמה: א’ וב’ שולחים אחד לשני הודעות עם הצפנה א-סימטרית. לכל אחד מהם יש 3 מפתחות- לא’ יש את המפתח הציבורי שלו, את המפתח הפרטי שלו ואת המפתח הציבורי של ב’. לב’ יש את המפתח הפרטי והציבורי שלו ואת המפתח הציבורי של א’. כשא’ שולח הודעה לב’, הוא מצפין אותה עם המפתח הציבורי של ב’. לאחר שההודעה הוצפנה הדרך היחידה לקרוא אותה היא באמצעות המפתח הפרטי של ב’ ולכן לא’ אין יכולת לקרוא את מה שהוא עצמו כתב. ההודעה נשלחת לב’ שבאמצעות המפתח הפרטי שלו קורא אותה.\nהמפתחות הפרטיים קשורים למפתחות הציבוריים ויכולים לפענח את ההצפנה שהם יצרו, אבל אי אפשר למצוא אותם באמצעות מפתח ציבורי.\nכל עוד הנמען שומר על המפתח הפרטי שלו, אי אפשר לפצח את ההצפנה ולראות את המידע שהועבר. גם במידה והמפתח הסודי של אחד הצדדים נגנב, אפשר לקרוא רק את ההודעות שנשלחו אליו. כלומר, אם המפתח הפרטי של א’ נגנב, אז כל ההודעות שנשלחו לא’, הודעות שהוצפנו על ידי המפתח הציבורי של א’ ומפוענחות על ידי המפתח הפרטי של א’, יהיו חשופות למי שמחזיק במפתח, אבל לא ההודעות שא’ שלח לב’. ההודעות שא’ שלח לב’ מוצפנות עם המפתח הציבורי של ב’ ועל מנת לפענח אותן יש צורך במפתח הפרטי של ב’.\nתכונה חשובה נוספת של הצפנה א-סימטרית היא היכולת להצפין את ההודעה עם המפתח הפרטי ואז לפענח אותה עם המפתח הציבורי. אמנם כל אחד יכול לקרוא את המידע שהרי לכל אחד יש את הגישה למפתח הציבורי, אבל מאחר והמידע הוצפן עם המפתח הפרטי שנמצא רק אצל אדם אחד אנחנו יכולים לאמת שמי ששלח את המידע הזה הוא אכן מי שהוא מתיימר להיות.\nההבדלים בין השיטות מתבטאים בין היתר באורך המפתחות. מאחר ובהצפנה א-סימטרית חייב להיות קשר מתמטי בין המפתח הציבורי למפתח הפרטי, פורצים יכולים באופן תיאורטי “להסיק” את המפתח הפרטי מהציבורי. כתוצאה מכך המפתחות בהצפנה א-סימטרית הם ארוכים באופן משמעותי- מפתח של 2048 ביט בהצפנה א-סימטרית מספק פחות או יותר את אותה רמת האבטחה של מפתח 128 ביט בהצפנה סימטרית.\nהיתרונות של השיטה הם אבטחה מוגברת ופתרון בעיית שיתוף המפתח הסודי, כמו גם אימות זהות השולח על ידי חתימה דיגטלית בדמות המפתח הפרטי. החסרונות הם האיטיות של השיטה ביחס להצפנה סימטרית והכוח העצום של המפתח הפרטי- אם המפתח הפרטי אבד או נגנב כל המידע אבד או נגנב.\n","description":"","tags":[""],"title":"הצפנה א-סימטרית","uri":"/posts/asymmetric-encryption/"},{"categories":["."],"content":"בשביל ללמוד רקורסיה, צריך ללמוד רקורסיה! או איך ללמוד רקורסיה the intuitive way 🙂.\nפונקציה רקורסיבית היא פונקציה שקוראת לעצמה בתוך עצמה (ושכולם כבר הפנימו כנראה). אבל עדיין יש אלמנטים עמומים שמבלבלים אנשים ברקורסיה (ובצדק).\nהדבר הראשון שמבלבל אנשים הוא איך קוראים לפונקציה בתוך עצמה, כשלא סיימנו עדיין את הפונקציה. הדבר השני, הוא איך ההיגיון מאחורי הקלעים עובד, שפולט את התשובה הנכונה כמו קסם.\nהסיבה שלקרוא לפונקציה בתוך עצמה “עובד”, הוא בגלל שכל קריאה לפונקציה נשמרת בזיכרון ב-stack (מחסנית), אשר עובדת לפי אחרון נכנס, ראשון יוצא. לדוגמה, אם נריץ את האלגוריתם הבא:\nfunc(n = 4): if n == 0 return func(n-1) print(n)\nקודם כל יודפס 1, אח\"כ 2, 3 ואז 4. זה בגלל שהקריאות נשמרות במחסנית לפי הסדר הבא: קודם נכנס למחסנית func(4), אחריו func(3)…עד 0, הקריאה העליונה במחסנית. כשמגיעים לתנאי העצירה (0), מפסיקים לשמור קריאות במחסנית ומתחילים לעבור לשורת ההדפסה print בכל אחת מהקריאות מהסוף להתחלה במחסנית: מדפיסים 1, ואז 2 וכן הלאה.\nקטע מעניין, הוא שעדיין אפשר להגיע ל-stackoverflow גם מבלי להשתמש במשפט הקסם “בלי תנאי עצירה”, שכן אם נציב מספר גדול כמו 10000, האלגוריתם עדיין יקרוס מ-stackoverflow בגלל השימוש הכבד במחסנית (צריך לשמור n קריאות במחסנית).\nלעומת זאת, אם נחליף את הסדר של ה- print:\nfunc(n = 4): if n == 0 return print(n) func(n-1)\nההדפסה תהיה הפוכה: התוצאה שנקבל היא 4, אחריו 3, 2, ואז 1. הפונקציה מדפיסה את המספר n, וקוראת לעצמה שוב עם n-1. ברגע שהגענו לתנאי העצירה n=0, אין עוד מה לעשות והקריאות חוזרות אחת אחרי השניה מהסוף להתחלה ללא קריאה לפעולות נוספות. אלגוריתם כזה נקרא tail recursion.\nההגדרה המילולית ל-tail recursion היא “הפעולה האחרונה של הפונקציה היא הקריאה לפונקציה עצמה”, כלומר אין עוד שורות או חישובים נוספים שעליה לבצע והיא מחזירה את התוצאה הסופית (אם יש מה להחזיר, לא במקרה שלנו). אלגוריתם שמשתמש ב-tail recursion יכול להיות לפעמים יעיל יותר מרקורסיה רגילה, שכן יש קומפיילרים המסוגלים לייעל את השימוש במחסנית (כלומר מתנהג כמו מימוש איטרטיבי).\nבאלגוריתמים בהם צריך להחזיר תוצאה, כמו למשל בפונקציה רקורסיבית לחישוב עצרת (כאשר n = 4), הרעיון עובד בצורה דומה: fact(n = 4) if n == 1 return 1 return n*fact(n-1)\nהקריאה הראשונה שנכנסת למחסנית הוא fact4, והיא אומרת “תן לי את התוצאה של fact3 ואני אתן לך את התוצאה של 4!. אותו דבר ל-fact3 עד שמגיעים ל n = 1, שבמקרה מחזיר 1 כתנאי עצירה. ואז מלמעלה למטה:\nfact(1) = 1 fact (2) = 2 * fact(1) = 21 fact(3) = 3 * fact(2) = 32 fact(4) = 4 * fact(3) = 4*6 = 24\nאלגוריתם של tail recursion ייראה כך:\nfacTail(n = 4, results = 1): if(n == 1) return results return facTail(n-1, results * n)\nהפעולה האחרונה היא קריאה רקורסיבית, והפונקציה מעדכנת את הפרמטר results עד התנאי עצירה, מחזירה את הערך הסופי ומעיפה את כל הקריאות מהמחסנית אחד אחד.\nבגלל השימוש הנדיב שלה במחסנית, רקורסיה (לפחות רגילה) תהיה איטית יותר מאלגוריתם איטרטיבי, ולכן ברוב המקרים התירוץ להשתמש באלגוריתם רקורסיבי יהיה בהתאם לאינטואיטיביות של המימוש.\nבדר\"כ האלגוריתמים האינטואיטיביים למימוש רקורסיבי הם במעבר על עצים, או מימושים של בעיות divide and conquer או במילים ישראליות- לפוצץ את הבעיה לחתיכות קטנות ולפתור. האלגוריתם לפתרון של tower of hanoi היא דוגמה ממש נפלאה לאיך אלגוריתם איטרטיבי ומסובך נחתך למס’ שורות מצומצם במימוש רקורסיבי.\nהרעיון המרכזי שצריך להפנים בפונקציה רקורסיבית רגילה, היא איך נשמרות הקריאות במחסנית, ולעבוד מלמעלה למטה- ואז הרבה יותר קל להבין את ההגיון מאחורי האלגוריתם. ב- tail recursion צריך להפנים שבסה\"כ מעדכנים כל פעם פרמטר(ים) ועובדים איתו מהגדול לקטן עד שבסוף מחזירים אותו.\n","description":"","tags":[""],"title":"איך ללמוד רקורסיה באופן אינטואיטיבי","uri":"/posts/intuitive-recursion/"},{"categories":["."],"content":"פרוטוקול ה-DNS, או בשמו המלא Domain Name System, הוא פרוטקול שכולנו משתמשים בו כל הזמן והופך את האינטרט לנגיש לכולם. למרות זאת, הוא לא זוכה למספיק יחס.\nה-DNS הוא למעשה ספר הטלפונים של האינטרנט. כשאנחנו מנסים להיכנס לויקיפדיה לדוגמה, אנחנו מזינים לשורת הכתובת בדפדפן כתובת שנוחה לבני אדם- wikipedia.org. הבעיה היא שמחשבים לא עובדים בצורה כזו, הכתובות של מחשבים הן כתובות IP מספריות. למעשה הכתובת של ויקיפדיה עבור המחשב היא 91.198.174.192 בפרוטקול IPv4 או 2620:0:862:ed1a::1 בפרוטקול Ipv6, ואף אחת מהן לא ידידותית למשתמש.\nוכאן ה-DNS נכנס לתמונה. ה-DNS מקשר בין הכתובת ה\"אנושית” wikipedia.org לכתובת האמיתית- 91.198.174.192.\nאיך ה-DNS יודע לקשר כתובות?\nכשאנחנו מזינים את הכתובת ולוחצים אינטר, נשלחת בקשה לשרת ה-DNS שלנו. איזה שרת בדיוק? זה תלוי. בהנחה שלא שיניתם את הגדרות ה-DNS אצלכם (בראוטר/מחשב/פלאפון וכו’), אתם משתשמשים בשרתי ברירת המחדל שהם השרתים של ספקית האינטרנט שלכם (שזה צעד ממש לא חכם, אבל זה לפוסט אחר).\nהשרת הזה נקרא DNS recursive resolver ואפשר להסתכל עליו כמעיין ספרנית שמקבלת שאילתא (query) ואז הולכת לחפש את הספר שמתאים לה (כתובת דומיין) על ידי סדרה של בקשות בשביל למצוא את המיקום המדויק.\nהתחנה הראשונה היא שרת Root Nameserver. השרת הזה למעשה מפנה את הספרנית למדור הנכון בספריה, שהוא ה-TLD (Top Level Domain) Nameserver המתאים או במילים אחרות- לשרת המתאים לסיומת הדומיין. בדוגמה שלwikipedia.org, ה-Root יפנה אותנו (כלומר את ה-DNS resolver) ל-TLD Nameserver שמתאים לסיומת org.\nמהרוט אנחנו מגיעים ל-TLD Nameserver המתאים. ה-TLD NS הוא למעשה המדף המתאים בספריה שמכיל את כל הספרים בקטג’ שביקשנו, או במקרה שלנו את כל הדומיינים עם סיומת org. ה-TLD NS מוצא את הרשומה של wikipedia.org ומפנה אותנו עם המידע הזה ל-Authoritative Nameserver, או לספר הספציפי.\nהשלב האחרון במסע שלנו מגיע כשה-resolver שולח בקשה ל-Authoritative Nameserver. ה-Autoritative NS מספק לו את המידע שהוא בדמות רקורד DNS מלא שכולל את כתובת ה-IP המתאימה וכל תת כתובת אחרת שנחוצה וההפניות שלה (לדוגמה תת דומיין שמפנה למקום אחר).\nמכאן ה-DNS resolver חוזר למחשב שלנו, מצויד בכתובת ה-IP של האתר שביקשנו. הדפדפן שולח בקשת HTTP לשרת ומקבל בחזרה את העמוד המבוקש. בנוסף לכך, גם ה-resolver וגם המחשב שלנו ישמרו את הבקשה הזו ב-cache כדי לחסוך את הטיול הזה בפעם הבאה שאנחנו צריכים את כתובת ה-IP של האתר.\n","description":"","tags":[""],"title":"מה זה DNS, ומה הוא עושה?","uri":"/posts/dns/"},{"categories":["."],"content":"אוטנטיקציה דרך קוקיז עובדת לא רע בכלל לאתרים, וקשה להצביע על יתרונות אבסולוטים למעבר אל אוטנטיקציה דרך JWT. אבל זה, כמובן, כשהאתר הוא אתר, ושהוא נתמך ע\"י דפדפנים שתומכים בקוקיז. מה עם אפליקציות נייטיב, שאין להן תמיכה של קוקיז? כאן JWT זורח.\nלמען הסר ספק, ההבדלים בין Authentication, Authorization הן ש-authentication הוא הזדהות (מי אתה?), ו- authorization הוא “אם אתה רוצה לקנות ערק תראה לי שאתה 21+” (הרשאה).\nאז הביטוי JWT נקרא Json Web Token, והמימוש שלו חמוד לאללה. JWT זה טוקן הנראה כגוש האש גדול, המופרד ל-3 חלקים בעזרת נקודה חמודה.\nהסטרינג הראשון, הוא בד\"כ json בעצמו שמכיל מידע על האלגוריתם האש שהשתמשו בטוקן כדי לחתום אותו. הסטרינג השני, שהוא גם בד\"כ Json, הוא המידע עצמו שרוצים לשמור כדי שהמשתמש יוכל להזדהות (כמו ID של המשתמש, תאריך תפוגה ועוד’).\nשני ה- jsonים מקודדים לסטנדרט של base64url, ואינם מוצפנים, כמובן. כל אחד יכול לפענח את שני הסטרינגים הללו ולקרוא את המידע. מכאן, מגיע הבטיחות בחלק השלישי של הטוקן: החתימה.\nהרעיון של הטוקן הוא לא להעביר מידע מוצפן (לפחות לא JWT סימטרי), אלא לוודא שאף אחד לא משנה את המידע. בשביל לוודא זאת, לוקחים את החלק הראשון (שנקרא גם header), החלק השני (שנקרא גם payload), מחברים אותם לסטרינג אחד, מוסיפים לו מפתח שקיים אצל השרת בלבד, ומהאהשים בהתאם להגדרות האלגוריתם של החלק הראשון (ה-header). התוצאה: סטרינג, או ‘חתימה’ שהיא החלק האחרון בטוקן. וזה, מוודא לנו שאף אחד לא נגע בטוקן. מי שיצר אותו יקבל את אותו הטוקן ללא שינויים זדוניים.\nמכיוון שרק לשרת יש את המפתח שאנחנו מוסיפים לחתימה, אף אחד אחר לא יכול לייצר את החתימה, ולכן אף אחד לא יוכל לעבוד על השרת. כשהשרת מקבל את הטוקן, הוא פועל שוב ע\"פ ההוראות למעלה, ומוודא שהחתימה שיוצאת לו, היא אותה חתימה המתקבלת בטוקן. לא- מחזיר 401, כן- יאללה ערק.\nהמקרה בו יש רק מפתח אחד, נקרא JWT סימטרי. כלומר, קיים רק מפתח אחד (‘פרטי’) שיכול לאשר את החתימה, ובשביל שעוד שרתים יוכלו לאשר את הטוקן, צריך לפזר את המפתח ביניהם. זה בד\"כ מתכון לפירצות אבטחה, כשאם שרת אחד נפרץ, כל השרתים שמחזיקים את המפתח נמצאים בסכנה.\n","description":"","tags":[""],"title":"למה JWT הוא ערק ערק ככה חזק?","uri":"/posts/jwt/"},{"categories":["."],"content":"כדי למדוד מהירות (פוטנציאל) אלגוריתמי כלשהיא, אנחנו נאלצים לבודד את המשתנים אשר מפריעים לנו למדוד את הפוטנציאל הטהור של האלגוריתם, כמו לבודד את המכונה מהמשוואה. איננו רוצים שאלגוריתם יהיה מהיר יותר כי יש לך את ה- AMD Ryzen החדש. בשביל זה יש לנו את הסיבוכיות- המודדת את כמות האופרציות שאלגוריתם מבצע, וכך נוכל להעריך גם את הפוטנציאל.\nחיפוש בינארי הוא עוד אלגוריתם שנולד מתוך הרצון לחתוך כמה שיותר את כמות האופרציות בזמן חיפוש, והקונספט שלו דומה לחיפוש בספרי דפי זהב שפעם היה לכולנו. במקום לחפש איבר אחד אחרי השני, אנחנו חותכים את החיפוש ספציפית לאות שבה מתחיל השם שאנחנו מחפשים. זה כל כך אפקטיבי, שאנחנו יכולים למצוא שם של אדם תוך כמה שניות, מאשר אפילו כמה שעות.\nיש לציין, שאי אפשר לבצע חיפוש בינארי עם הרשימה לא מסודרת. לא נוכל לחפש לפי אות אם האותיות לא מסודרת לפי ה- א’ ב’.\nהמשמעות של בינארי, אגב, פירושו יחס בין 2 פרטים. 0 או 1. זה או זה. פה או שם. ומכאן השם של חיפוש בינארי-אם לא פה אז אולי שם.\nאז הקונספט של חיפוש בינארי הוא דיי קליל. ניקח מערך מספרים ממויין, ונחפש ספרה כלשהיא. נתחיל מהאמצע- אם הספרה לא שווה, האם היא גדולה מן הספרה האמצעית? אם כן, נחתוך את הרשימה בחצי ונתחיל שוב, וכך הלאה. המעבר של “לחתוך בחצי” את המערך נותן לנו סיבוכיות של logn, במקום סיבוכיות של n, בה נצטרך לעבור איבר איבר במערך (דמיינו מעבר לפי שם שם בדפי זהב לפי הסדר של הא’ ב’).\nהפונקציה ‘log’ היא שיטה נעימה (או פחות?) יותר לשאלה: הבסיס בחזקת מה, ייתן לי את המספר x? בדר\"כ כשרואים ‘רק’ את המילה log, מתכוונים לבסיס 2. כלומר, כמות הפעמים שנחתוך את המערך עד למציאת האיבר שלנו, היא במקרה הכי גרוע פשוט החזקה. אם המערך שלנו הוא באורך 8, ייקח לנו במקסימום 3 פעמים שנצטרך לחתוך ולמצוא את האיבר שלנו.\nזה נהיה קריטי כשהמערך גדל מעריכית, אבל כמות האופרציות נשארת כפונקציה לוגריתמית.\nומכאן אפשר לשאול, יש לנו חיפוש בינארי- למה צריך עץ בינארי? עץ בינארי גם מאפשר לנו חיפוש בlogn, אבל כמובן רק אם הוא עץ מאוזן (כדוגמת עצי AVL, אדום שחור). אם העץ אינו מאוזן, הוא יכול לתת לנו חיפוש ב- logn, אבל החיפוש יכול להיות לינארי (בהתאם לכמות האיברים, n). לעומת זאת אם הוא מאוזן, הוא מבטיח לנו תמיד חיפוש בlogn.\nהיתרון שיש לעצים בינארים מאוזנים על פני חיפוש בינארי, הוא דווקא בהכנסה וההוצאה (insert, remove). בעצים בינארים מאוזנים גם ההכנסות וההוצאות נשארים logn (על אף שהם צריכים לאזן את עצמם), בזמן שבמערכים ההכנסה וההוצאה היא לינארית, בהתאם ל- n ולמיקום במערך שיש להוסיפה.\nלכן, המימוש של עצים בינארים יהיה מהיר יותר למקרים בהם לא רק יש צורך לחפש, אלא לבצע מניפולאציה כבדה על האיברים במערך.\n","description":"","tags":[""],"title":"למה חיפוש בינארי קיים או עדיף, למה בעצם להסתבך עם עצים בינארים?","uri":"/posts/binary-search-and-binary-trees/"},{"categories":["."],"content":"למעשה, מיקרוסרביסים כבר תפס חלק נכבד (אבל לא אבסולוטי) מארכיטקטורת הצד שרת של היום, אז השאלה הנכונה יותר לשאול היא ‘האם היא כאן להישאר’.\nההפך הגמור ממיקרוסרביסים היא ה’מונולית’ הידועה (כלומר monolith), שהיא “הכל במקום אחד”. גם ה- UI, גם הלוגיקה של השרת, הכל- מודבקים עם סלוטייפ ביחד תחת unit אחד הפונה לדטאבייס אחד.\nמיקרוסרביסים נולד מתוך האנליות של ‘single responsibility’ שמתעקשת(ובצדק) לבודד את כל הלוגיקה למודולים נפרדים, שאינם תלויים באופן מוחלט, ואינם דבוקים אחד בשני.\nבמיקרוסרביסים, כל לוגיקה או מודול מחולקים ל’סרביסים’ שונים, שכל אחד פונה לדטאבייס משלו. כל סרביס יכול להיות כתוב בשפה אחרת, תחת כל רציונל שהוא רוצה (כל עוד אפשר לתקשר איתו). כל סרביס יכול להיות שרת שרץ על מכונה נפרדת או להשתתף תחת אותה מכונה תוך שימוש בפורטים שונים כד לגשת אליהם.\nהיתרון הבולט של מיקרוסרביסים הוא היכולת לפזר מפתחים לסרביסים שונים, מבלי להתחיל לקבל מרק של קונפליקטים, כשבמונולית המפתחים היו נוגעים בצלחת האחד של השני. הדילוור (delivery) של פיצ’רים חדשים הופך למשמעותית קל ומהיר יותר.\nהיתרון העצום השני, הוא היכולת לבצע scaling רק לסרביסים החמים שמשתמשים בהם הכי הרבה. בניגוד למונולית, שם אתה צריך להיגרר להרחבת השרת ו\\או הזיכרון של כל השרת רק בגלל לוגיקה ספציפית אחת, למשל.\nהיתרון האחרון(בערך) נובע מה-single responsibility, שמפרידה את המודולים אחד מהשני ומצמצמת קשירות בקוד.\nאבל בפיתוח (לפחות), לכל פתרון יש מחיר. והמחיר של מיקרוסרביסים הוא לא כל כך זול.\nראשית, מיקרוסרביסים כמעט תמיד תהיה איטית יותר מכל ארכיטקטורה מונוליתית. אם במונולית המודולים תקשרו אחד עם השני דרך הזיכרון, התקשור עכשיו עובר לתקשורת דרך הרשת. אם אתה צריך לוגיקה, מידע או כל שירות אחר- אתה צריך לבצע קריאת HTTP לסרביס האחר, או לכמה סרביסים. פיתוחים כגון HTTP2 או מימושים מתוחכמים של parallelism קיימים ואולי עשויים להפוך את הבדלי המהירות לredundant, אבל עדיין מיקרוסרביסים איטית יותר.\nהמחיר השני הוא הקושי לפתח. זה לא פשוט בכלל לתכנן סרביסים השונים אחד מהשני, כשכל אחד תלוי במידע מסרביס אחר. איך לגשת למידע? איך לקבל את המידע? הרבה סרביסים יהיו תלויים במידע מסרביסים שונים, ומימוש לא נכון יכול להפוך לסיוט מהלך על 10.\nיש לציין, המונח ‘מיקרוסרביסים’ הוא מונח כללי שאינו מתאר רק ארכיטקטורת צד שרת. יש hype גם בתחומים אחרים כמו למשל micro frontend.\nעכשיו נותר רק לשאול, אצלכם עובדים עם מיקרוסרביסים או מונולית?\n","description":"","tags":[""],"title":"האם מיקרוסרביסים היא ארכיטקטורת העתיד?","uri":"/posts/microservices/"},{"categories":["."],"content":"הכוונה בלכידות היא עד כמה הרכיבים קשורים אחד לשני, בתוך מודול ספציפי. ככל שהלכידות ‘גבוהה’ יותר, ככה ‘יותר טוב’.\nבמחלקה למשל, לכידות נמדדת ע\"פ כמה כל הפונקציות משתמשות בכמה שיותר משתנים הקיימים בה. ככל שכל הפונקציות משתמשות בכמה שיותר משתנים בתוך המחלקה, כך הסממן ברור: הקשר בין המשתנים לפונקציונאליות של המחלקה חזקים יותר ולהיפך.\nעוד מדד ללכידות, היא עד כמה הפונקציות במודול משרתות מטרה ברורה ומוגדרת. ככל שהמחלקה(למשל) שואפת להיות יותר פונקציונאלית ולצאת מתחום האחריות הברורה שלה, היא מאבדת מהשופטים נקודות (דוגמא קונקרטית: מתכנת, שאחראי לכתוב קוד, ועכשיו גם צריך לנקות את השירותים- זוהי הפרה ברורה של הגדרת המטרה שלו!).\nולמה זה כל כך משנה? אז לכידות מתקשרת באופן עקיף ל’צמידות”, או בשפה העממית tight coupling. נגיד שאתם פותחים מגירת סכו\"ם במטבח ומגלים שכל המגירה מבולגנת מהיסוד- מזלגות מעל הכפות וסכינים מעל הצלחות. לא רק שיהיה קשה לסדר את המגירה, היא לא ברורה בעליל. עכשיו תתארו שהמגירה מסודרת להפליא. מזלגות איפה שהמזלגות, וסכינים איפה שהסכינים. הכל מסודר, אפשר להכניס בקלות סכו\"ם חדש למגירה.\nלכידות היא עוד מדד מרכזי ב- oo (הלוא object oriented) המאפשר לנו להוריד את הסמתוכה ש-oo מעודד אותנו לייצר, ולשמור על מודולים (ו\\או מחלקות במקרה שלנו) מלהיות צמודים ותלויים אחד בשני. ככל שתחום האחריות מופרד אחד מהשני, קל יותר להבין את המערכת, לדבאג אותה ולשנות\\להוסיף. או במילים פשוטות יותר: המתכנתים יזדקנו לאט יותר.\n","description":"","tags":[""],"title":"לכידות(cohesion) או; איך לסדר מגירה כמו שצריך.","uri":"/posts/cohesion/"},{"categories":["."],"content":"פעם, המנטרה הייתה ברורה- קוד עם דוקומנטציה ברורה ומסודרת לכל דבר. היום משום מה, הגישה הזאת התעדנה קצת.\nהגישה היום הולכת ככה: הערות זה רע. התוצאה: רואים הרבה מאוד מערכות שלפעמים לא נמצא שורת comment אחת.\nהאם זה תקין? אולי. האם commenting הפך לילד רע? לא בדיוק.\nנתחיל ממקרה קלאסי של נגד הערה: מפתח כתב פונקציה, תיעד כמה שורות יפות ומתובלנות את הביצוע של הקוד, והמשיך לדרכו. כמה ימים אח\"כ, תיקן באג, שינה שורה או שתיים, והמשיך לדרכו. אבל רגע, מה עם הדוקומנטציה? אופסי.\nברגע שמתכנת צריך לתעד ולכתוב דוקומנטציה מלאה לכל קוד\\פונקציה, הוא ממש מבצע חתונה קתולית בינו לבין הקוד וההערות. יד ביד, כמו זוג אוהבים, הוא ייצטרך לתחזק גם את הקוד וגם את ההערות. זה יוצר עומס, בלבול, שגיאות וכמובן עצבים. וזה לא אמור להיות ככה.\nבעיה נוספת שהערות מייצרות לנו היא…זמן. לכתוב הערות לכל דבר לא יתרום אף פעם ליכולת של הקוד, או לביצוע של הקוד. אם זמן הוא מרכיב קריטי בפיתוח, צריך ממש לשקול לדלג על שלב כתיבת ההערות.\nהגישה שהתפתחה לה כיום כנגד כתיבת הערות נקראת ROC, כלומר: Really Obvious Code. שהקוד ידבר בפני עצמו, יהיה ברור ומסודר. מי שיירצה להבין איך הקוד עובד, צריך להסתכל על הקוד ולא על הסיפור שמעליו.\nאז האם לכתוב הערות הפך לboogyman של המפתחים היום? אז לא, לא בדיוק.\nיש מקומות בהם דווקא כן צריך דוקומנטציה ברורה, למשל ב- public API, librarys, שם אתה זקוק שהמשתמש יבין את המימושים השונים ולא יילך לאיבוד. אבל גם שם אפשר ללכת בגישה קצת אחרת מאשר משל של ארנב וצב מעל כל פונקציה. הגישה אומרת כך: כתוב מה הפונקציה צריכה לעשות, ולא מה היא עושה. את הפונקציונאליות של הקוד משאירים לקוד עצמו, ואת הפילוסופיה מאחוריה- להערות.\n","description":"","tags":[""],"title":"הממ…To comment or not to comment?","uri":"/posts/to-comment-or-not-to-comment/"},{"categories":["."],"content":"בפעם הראשונה שבניתי פרוייקט (ובמקרה הוא היה בג’אווה), הוא ככל הנראה היה הפרוייקט הכי שאפתני שלי; ניסיתי למפות את גוף האדם. ההשראה נבעה מהיכולת של Inheritance, שאיפשרה לי ליצור קשרים ויחסים בין אובייקטים.\nמיותר לציין שהפרוייקט נגנז לאלתר, בעיקר בגלל קש קטן שהפך את כל הקשרים והיחסים שבניתי. הירושה דפקה את הכל.\nלירושה יש הרבה יתרונות, אבל יש לה מספר חסרונות מצומצם, והרסניות. מביניהן, והפופולארית- אנחנו לא תמיד יכולים (או צריכים) ליצור קשר של אב-בן בצורה נכונה, כזאת שתואמת לעולם האמיתי. ברגע שנוצר צורך שאינו תואם ליחס שבנינו, הכל מתחיל להתפורר לנו ומתחיל שלב ה refactorrrr.\nמאז השרשתי את המושג הרכבה מעל ירושה- במקום ליצור קשר בין אובייקטים בעזרת ירושה, אפשר בעזרת הרכבה (לשתול רפרנס של “היחס” בתור אובייקט כפרופרטי במחלקה). זה מאפשר גמישות כשאתה רוצה לשנות את היחס, ופלוס קטן הוא שאפשר להחביא את הגישה לאובייקט, כלומר encapsulate, יתרון שאין לנו בירושה (לא תוכל להחביא את הגישה ל-human בירושה כשאתה משתמש באובייקט של person).\nפגשתי מתכנתים שנשבעים לא להשתמש בירושה בכלל- ולא בטוח שזאת גישה נכונה. לירושה יש את היתרונות שלה, במיוחד במניעת חזרה על הקוד.\nאני בד\"כ לא מאמין בשחור ולבן- יש הרבה צבעים מסביב כשזה קשור לכתיבת קוד, ו\"לשלב” זאת לא בהכרח מילה גסה בפיתוח.\n","description":"","tags":[""],"title":"Composition Over Inheritance?","uri":"/posts/composition-over-inheritance/"},{"categories":["."],"content":"אולי Functional Programming נשמע כמו שיעור סטודיו בחדר כושר, אבל למרות שהשם שלו נשמע מיינסטרימי, יש פילוסופיה שלמה ומעניינת מאחוריה.\nהמוטיב המרכזי שחוזר: פונקציות. לפשט את הכל לפונצקיות, ולהתייחס אל פונקציות בעדינות וחוכמה. כל קטע קוד שקיים במערכת, צריך להיות עטוף כפונקציה המבצעת פעולה אחת פשוטה, תוך קבלת קלט, ופליטת פלט כלשהו.\nהרעיון מאחורי המוטיב לקוח מהגישה המתמטית: הפונקציה מבצעת פעולה אחת, אתה יודע מה היא, ומה תהיה התוצאה בהתאם לקלט. ובקוד, זה מתבטא בכך שאתה לא צריך “לדבאג” את הפונקציה ולהבין מה לא בסדר איתה, אלא אמור לקחת בחשבון שהיא עובדת כמו שצריך (אם נכתב כמו שצריך), וגם ברורה בדיוק מה היא עושה, כך שאתה בכלל לא צריך להתחיל להיכנס לכל פונקציה בקוד. כל הבעיות שיכולות “לצוץ” צריכות להיות קשורות בשרשור והלוגיה של הפונקציות, ולא בפונקציות עצמן.\nבנוסף, בתכנות פונקציונאלי (שאתייחס כ-FP) כל האובייקטים הם immutable, כלומר ברגע שמייצרים אותם, אסור לשנות אותם. אם אתה רוצה לערוך אותם, תצטרך להחזיר עם פונקציה אובייקט חדש עם הערכים החדשים. לחידוד, להעביר כקלט את האובייקט לפונקציה ולערוך את האובייקט בתוך הפונקציה עצמה לא מתקבל בחשבון.\nוכמובן, שאין יותר forloop, במיוחד fori (בגלל שהוא מבצע שינוי סטייט ל-i!), ובכדי לבצע איטרציה כלשהיא, משתמשים ברקורסיה (בכל זאת, אני ראיתי מספיק מתכנתיי FP שעדיין משתמשים בforeach, ולא נראה שהעולם קרס להם).\nלסיום, ל-FP יש מה לומר גם על error handling \u0026 null. מכיוון שפונקציות ב-FP הן כמו אלגברה, אין לך בדיוק ערך של NULL. השיטה המקובלת היא לעטוף את הערך המוחזר באובייקט כלשהוא, ולבדוק אם יש בו ערך (או לקרוא לפונקציה מתאימה). בשפות שמשרישות פילוסופיה FPית (כמו קוטלין וסקאלה) זה קצת יותר מחומם מזה.\nכדי למנוע אקספשיינס, ב-Go הפכו כל שגיאה לערך בפני עצמו. אתה כבר לא מקריס את האפליקציה כשנוצרת לך השגיאה, אלא מחזיר אותה בפונקציה כערך בפני עצמו (בדר\"כ כסוג של Tupel) ונותן לקורא הפונקציה להסתבך עם עצמו. האם זה יעיל? אולי, אבל דורש המון שכפול קוד.\nבתמונה: קטע מאימון פונקציונאלי שרשורי, וקצת קריא יותר. החדי קרן מבינינו יבחינו שאפשר לקצרר את השורה עוד יותר.\n","description":"","tags":[""],"title":"Functional Programming","uri":"/posts/functional-programming/"}]