[{"categories":["."],"content":"למעשה, מיקרוסרביסים כבר תפס חלק נכבד (אבל לא אבסולוטי) מארכיטקטורת הצד שרת של היום, אז השאלה הנכונה יותר לשאול היא ‘האם היא כאן להישאר’.\nההפך הגמור ממיקרוסרביסים היא ה’מונולית’ הידועה (כלומר monolith), שהיא “הכל במקום אחד”. גם ה- UI, גם הלוגיקה של השרת, הכל- מודבקים עם סלוטייפ ביחד תחת unit אחד הפונה לדטאבייס אחד.\nמיקרוסרביסים נולד מתוך האנליות של ‘single responsibility’ שמתעקשת(ובצדק) לבודד את כל הלוגיקה למודולים נפרדים, שאינם תלויים באופן מוחלט, ואינם דבוקים אחד בשני.\nבמיקרוסרביסים, כל לוגיקה או מודול מחולקים ל’סרביסים’ שונים, שכל אחד פונה לדטאבייס משלו. כל סרביס יכול להיות כתוב בשפה אחרת, תחת כל רציונל שהוא רוצה (כל עוד אפשר לתקשר איתו). כל סרביס יכול להיות שרת שרץ על מכונה נפרדת או להשתתף תחת אותה מכונה תוך שימוש בפורטים שונים כד לגשת אליהם.\nהיתרון הבולט של מיקרוסרביסים הוא היכולת לפזר מפתחים לסרביסים שונים, מבלי להתחיל לקבל מרק של קונפליקטים, כשבמונולית המפתחים היו נוגעים בצלחת האחד של השני. הדילוור (delivery) של פיצ’רים חדשים הופך למשמעותית קל ומהיר יותר.\nהיתרון העצום השני, הוא היכולת לבצע scaling רק לסרביסים החמים שמשתמשים בהם הכי הרבה. בניגוד למונולית, שם אתה צריך להיגרר להרחבת השרת ו\\או הזיכרון של כל השרת רק בגלל לוגיקה ספציפית אחת, למשל.\nהיתרון האחרון(בערך) נובע מה-single responsibility, שמפרידה את המודולים אחד מהשני ומצמצמת קשירות בקוד.\nאבל בפיתוח (לפחות), לכל פתרון יש מחיר. והמחיר של מיקרוסרביסים הוא לא כל כך זול.\nראשית, מיקרוסרביסים כמעט תמיד תהיה איטית יותר מכל ארכיטקטורה מונוליתית. אם במונולית המודולים תקשרו אחד עם השני דרך הזיכרון, התקשור עכשיו עובר לתקשורת דרך הרשת. אם אתה צריך לוגיקה, מידע או כל שירות אחר- אתה צריך לבצע קריאת HTTP לסרביס האחר, או לכמה סרביסים. פיתוחים כגון HTTP2 או מימושים מתוחכמים של parallelism קיימים ואולי עשויים להפוך את הבדלי המהירות לredundant, אבל עדיין מיקרוסרביסים איטית יותר.\nהמחיר השני הוא הקושי לפתח. זה לא פשוט בכלל לתכנן סרביסים השונים אחד מהשני, כשכל אחד תלוי במידע מסרביס אחר. איך לגשת למידע? איך לקבל את המידע? הרבה סרביסים יהיו תלויים במידע מסרביסים שונים, ומימוש לא נכון יכול להפוך לסיוט מהלך על 10.\nיש לציין, המונח ‘מיקרוסרביסים’ הוא מונח כללי שאינו מתאר רק ארכיטקטורת צד שרת. יש hype גם בתחומים אחרים כמו למשל micro frontend.\nעכשיו נותר רק לשאול, אצלכם עובדים עם מיקרוסרביסים או מונולית?\n","description":"","tags":[""],"title":"האם מיקרוסרביסים היא ארכיטקטורת העתיד?","uri":"/posts/microservices/"},{"categories":null,"content":"איך מתמודדים עם עומס על השרת(ים) כיום? אחת התשובות- Load Balancer.\nהרעיון של Load Balancer בעצם נהפך להכרח אצל הרבה חברות עקב הפריצה הענקית של המשתמשים באינטרנט. פעם עוד היה אפשר להרים את המחשב של אמא בתור שרת בסיסי בסלון כמו צוקרברג, אבל מהר מאוד זה הפסיק להיות לו כפתרון לגיטימי. בכלל, כיום אתרים ואפליקציות מתמודדות עם ריבוי בקשות עצום. הפתרון, נמצא איפשהוא בין שני סוגים של scaling לפניות.\nהראשון: vertical scaling, שהוא אומר; שדרג את המכונה(שרת). תוסיף עוד RAM, תחליף ל- AMD RYZEN ותרביץ מכונה שתצליח לעמוד בריבוי הפניות. הבעיה הגדולה ביותר של זה היא שיש גבול עליון של כוח מחשובי שאפשר להגיע אליו יחסית מהר והגבול הזה גם ככה לא מספיק (לשרתים שמתקשים לעמוד בעומס).\nהשני: horizontal scaling, שהוא אומר; שכפל את השרתים כך שיש ריבוי מכונות כדי שכולם יוכלו להתחלק עם הריבוי משתמשים\\בקשות.\nהבעיה שנוצרה מ- horizontal scaling היא; איך לחלק את העבודה בין המכונות?, כלומר איך להחליט לאיזה שרת להפנות בקשה מסוימת. איך יודעים מתי שרת א’ פנוי ושרת ב’ לא פנוי?\nאז הרעיון של Load Balancer נועד לפתור בין היתר את הבעיות הנ\"ל. Load Balancer בסיסי הוא כמו ראוטר, המפנה את הבקשות אל המכונות הרלוונטיים. בדר\"כ זה יהיה שרת שמתפקד כמו reverse proxy (או כ). הוא יושב בתקשורת באמצע של הקליינט והשרת (או חוות שרתים).\nיש שני סוגים של Load Balancers פופולריים, L4 ו- L7. אז L4 מתייחס לכך שיש לו גישה רק לפורטים וה-IPים של הבקשה, ו7L מתייחס לכך שיש לו גישה לכל המידע בבקשת http (כמו body, routes, headers).\nזה אומר ש- 4L יכול לבצע את הלוגיקה של הניתוב רק בעזרת הפורטים וה-IPים של הבקשה. ה-4L מתרגם את התקשורת TCP ומחליף את ה-IP שלו עצמו (הנמען של הבקשה מהקליינט) עם ה-IP של השרת שהוא מחליט לנתב אליו את הבקשה. זה נקרא NAT – Network Address Translation.\nל-L7 יש גישה למידע של הבקשה ולכן הוא יכול לבצע יותר לוגיקה בהתאם למידע. לדוגמה, להחזיר 401 כשה- authorization header של הבקשה ריק או לא תקין. L7 יודע גם לנתב בהתאם ל-routes, למשל ב- GET /images הוא ינתב לשרת הרלוונטי שמחזיר תמונות.\nל- L7 יש 2 תקשורות TCP, אחת של הקליינט, ואחת שהוא מייצר עם השרת המנותב. הסיבות ליצירת התקשורת השנייה היא למשל בשינוי המידע בפניה, ואז העברת המידע החדש עם התקשורת החדשה. בנוסף, הרבה פעמים L7 מיושם גם כ- SSL Termination Gateway (פיענוח של המידע המוצפן) במקום שהשרתים יצטרכו להיות up to date עם התעודות SSL שלהן. 7L הוא reverse proxy קלאסי עם יכולות ניתוב.\nיש גם כמובן Internal Load Balancers (בשפה של AWS) שהם חבויים ולא ניתנים לגישה פומבית, אלא נמצאים בתוך רשת פרטית ומנהלים שם את הinfrastructure. דוגמה לכך היא ה- Docker Swarm שמנתב ומנהל את הסרביסים\\שרתים שנמצאים בתוך השרת הפרטי.\nיש סוגים שונים של לוגיקה לכל Load Balancer שבעזרתו הוא מנתב את הבקשות לשרתים השונים, והלוגיקה תלויה בצרכים של האתר\\אפליקציה. ישנם אלגוריתמים כמו round robin, שהוא כמו לחלק קלפים לאנשים לפי הסדר; הבקשה מנותבת לשרת הראשון, אח\"כ לשני, שלישי עד אחרון השרתים- ואז חוזר חלילה לשרת הראשון.\nעוד אלגוריתם נקרא Weighted Response Time, אלגוריתם שמחשב מי השרת שמגיב הכי מהר- ואליו תנותב הבקשה. החישוב מתבצע בעזרת health checks שה- load balancer שולח בקשות מידי פעם ובודק את התקינות והמהירות תגובה של השרתים.\nאלגוריתם נוסף הוא Source IP Hash, שזה אלגוריתם בו ה-IP של הקליינט וה-IP של השרת אליה נשלחה הבקשה נתפרים יחד להאש (מפתח ייחודי), כך שיהיה אפשר לדעת בדיוק לאיזה שרת הקליינט ניגש בבקשה הקודמת, במידה והבקשה\\התקשורת נפגעה, או שיש לקליינט צורך ממשי להגיע לאותו שרת ספציפי. דוגמה לכך היא במקרים בהם הקליינט צריך גישה ל-session ספציפי, בשרת ספציפי.\nישנם מקרים בהם יש עומס של פעילות ביום וירידה חדה של פעילות בלילה. במקרים כאלה, יש צורך בלהעלות\\להוריד שרתים בהתאם לעומס הבקשות בזמן אמת. רוב העננים מאפשרים את היכולות הללו, בעזרת שכפול ה-image של השרתים כך שכל השרתים יהיו זהים ומתחילים לבצע סקיילינג אוטומטי של השרתים. ב- AWS זה נקרא Auto Scaling, ובאז’ור זה נקרא Scaling Set.\nעל פניו load balancer נראה מסובך, אבל הביצוע עצמו הוא דיי straight forward. רוב העננים מאפשרים להרים אחד כזה בכמה קליקים מבלי לעשות עמידת ידיים. גם הקונפיגורציה והלוגיקה של הניתוב לא מסובכים כשמבינים על פני השטח איך הדברים עובדים (או צריכים לעבוד).\nבאז’ור למשל, צריך לעשות את הדברים הבאים:\n-להגדיר רשת פרטית לשרתים ול- load balancer\n-להגדיר שרתים שאליהם אנחנו רוצים לנתב\n-להרים שרת load balancer (דרך אז’ור) בכמה קליקים\n-להגדיר לו הגדרות כמו health checks, ssl, routing\n-ליצור “Backend Pool” – בעצם לקשר את השרתים שלנו עם הבאלאנסר\n יש load balancer עובד!  ","description":"","tags":null,"title":"Load Balancer","uri":"/posts/load-balancer/"},{"categories":null,"content":"אם אתם רוצים ליצור איתי קשר אפשר לשלוח הודעה בדף הפייסבוק כאן או לשלוח הודעה במייל: coaviv104 at gmail dot com.\nאם אתם מעוניינים לכתוב פוסט אורח (עם קרדיט כמובן) אז אפשר למלא את הטופס שכאן או פשוט ליצור קשר במייל שלמעלה.\nדרישות לפוסט אורח: רוב הפוסטים קצרים ויהיו בין 300 ל-1000 מילים בנושאים שקשורים לתכנות או לטכנולוגיות שמסביב- בין אם רשתות או codecs. גם פוסטים טכנולוגיים שהם off-topic יכולים להתקבל, אבל פחות ודאי מאשר הנושאים האחרים. פוסטים מפורטים וארוכים מעל 1000 מילים יכולים להתקבל אבל סביר שיפוצלו למספר חלקים. הסגנון צריך להיות פחות או יותר דומה לשאר הפוסטים באתר. ידע מקצועי בשפה קולחת. כל עוד הפוסט מעביר את התוכן באופן ברור, זה בסדר.\nכשאתם ממלאים את הטופס, כדאי להציג את הנושא, כמה נקודות שעליהן הפוסט ידבר ואפשר גם פסקה או שתיים לדוגמה. חבל לכתוב פוסט שלם במידה ולא יאושר, אבל אם אתם מתעקשים זה בסדר.\n","description":"","tags":null,"title":"צור קשר/פוסט אורח","uri":"/contact/"},{"categories":null,"content":"כולנו נתקלנו בפרסומות ואינסוף חסויות לשירותי VPN מכל מיני סיבות- אבטחה, פרטיות או סתם בשביל לצפות בנטפליקס אמריקה. אבל איך בדיוק VPN עובד?\nבעבר, VPN (או Virtual Private Network – רשת פרטית וירטואלית) היה בשימוש בעיקר בקרב עסקים, בדגש על חברות גדולות, בכדי לאפשר לעובדים לגשת לרשת המאובטחת במשרד מהבית באמצעות חיבור מאובטח. בשביל להבין למה היה צורך ב-VPN, כדאי להבין איך אנחנו מתחברים לאינטרנט.\nנניח שאנחנו רוצים להיכנס ליוטיוב מהמחשב, פלאפון או כל ציוד קצה אחר. קודם כל המידע נשלח מהמחשב שלנו לראוטר/מודם. לראוטר/מודם יש כתובת IP שמהווה מזהה, מעיין תעודת זהות. משם הבקשה עוברת לספקית האינטרנט שלנו, לאחת מחוות השרתים שלה, סביר להניח שבפתח תקווה או בתל אביב.\nמשם המידע יוצא דרך כבל תת ימי לאיטליה, ומשם מדלג ברשת ענק של “כבישים” בדמות סיבים אופטיים על אדמת אירופה משרת לשרת עד שמגיע לשרת המיועד של גוגל. הבקשה מגיעה ליוטיוב, הוא בתגובה שולח את התגובה ומחזיר אותה כל הדרך חזרה.\nאז איפה הבעיה? קודם כל, בכל נקודה בדרך המידע שלנו חשוף ללא מעט עיניים. מידע שעובר באופן לא מוצפן יהיה נגיש לכל בעל גישה לנקודות האלו. זו הסיבה שלהשתמש באינטרנט ציבורי, בין אם בבית החולים או בבית הקפה, כדי להתחבר לבנק הוא לא צעד מומלץ. כל אדם עם קצת ידע טכני יוכל לקרוא את כל המידע שעובר ברשת- כל הודעה, כל סיסמה. אבל גם אם המידע מוצפן, המידע שלנו נגיש להרבה גורמים אחרים. הספקית והרבה מהנקודות בדרך יכולות לראות לאן אנחנו רוצים לגשת ולקבל את היסטורית הגלישה שלנו ומידע שאולי היינו מעדיפים לשמור לעצמנו. גם האתר יוכל לראות מי אנחנו. כל הגורמים כמעט בוודאות שומרים לוגים מפורטים עם המידע שלנו.\nוכאן נכנס ה-VPN לתמונה. בכדי לייצר חיבור המאובטח ה-VPN יצר מעיין תעלה (Tunnel Protocol) שמהווה מעטפת מאובטחת לחיבור. ברגע שמזוהה חדירה כלשהי לתעלה, ה-VPN מנתק באופן מיידי את החיבור ומחבר את הלקוח באמצעות נתיב אחר. כלומר אם באיזשהו שלב בסדרת הדילוגים אחד השרתים שנחתנו עליהם “חשוף”, ה-VPN יעבור לנתיב אחר. במקום לעבור מבארי איטליה לציריך ומשם לפרנקפורט, ה-VPN אולי יזהה שהחיבור דרך ציריך חשוף, ינתק אותנו ויחבר מחדש בנתיב שעובר מבארי לרומא, משם לבאזל ולבסוף יגיע לפרנקפורט.\nבתוך התעלה הזו עובר המידע כשהוא מוצפן. כך גם אם למישהו יש גישה לתחנה כלשהי בדרך, הוא לא יוכל לקרוא את המידע ששלחנו- לא ברשת פרטית ולא ברשת ציבורית.\nואם כל זה לא מספיק, המידע עובר בתחנת ביניים- שרת ה-VPN. כשאנחנו מחוברים ל-VPN אנחנו שולחים את הבקשה מוצפנת לשרת ה-VPN. השרת מפענח את הבקשה ומביא לנו אותה. הוא מהווה מעיין מידל מן- במקום לשלוח הודעה ליוטיוב באופן ישיר, אנחנו שולחים הודעה ל-VPN ואז הוא שולח את ההודעה ליוטיוב ובכך מסתיר את הזהות שלנו מיוטיוב, שמבחינתו מי ששלח לו הודעה זה שרת ה-VPN, לא אנחנו. בזכות ההצפנה גם כל הנקודות בדרך לשרת ה-VPN לא יודעות מה ביקשנו, כי המידע מוצפן. הן רק יודעות ששלחנו בקשה כלשהי לשרת כלשהו.\nזו גם הסיבה ש-VPN מאפשר לנו לצפות בנטפליקס במדינות זרות- אם נניח שאנחנו מחוברים לשרת VPN בניו יורק וגולשים בנטפליקס, מבחינת נטפליקס התקבלה בקשה ממחשב מתל אביב אלא מקבל בקשה ממחשב בניו יורק ולכן הוא יציג לו תוכן שמתאים לתיוג הגיאוגרפי של ניו יורק. כך גם לגבי כל חסימת תוכן על בסיס גיאוגרפי אחר- בין אם ב-BBC או ביוטיוב.\nגם כשמדובר בצנזורה במדינות כמו סין או איראן ה-VPN פותר את הבעיה בדרך דומה- במקום לגשת לשרת ויקיפדיה, ניגשים לשרת ה-VPN. המדינה לא יכולה לראות מה שלחתי ל-VPN ולכן הבקשה עוברת, משם ה-VPN מבקש בעצמו מויקיפדיה את האתר ושולח לנו אותו בחזרה מוצפן. ככה ניגשנו לויקיפדיה בלי שהאח הגדול ידע- מבחינתו ביקשנו משהו משרת כלשהו ולכן זה בסדר.\nאז מה הקאטץ’? יש כמה. דבר ראשון, חולשה די בולטת היא שרת ה-VPN עצמו. הוא יודע מי שלח את הבקשה והוא יודע מה היא (הרי הוא הוריד את ההצפנה כדי לקרוא). אנחנו למעשה צריכים לסמוך על חברות ה-VPN שהן מוחקות את הלוגים שלהן.\nבעיה נוספת היא המהירות- ההצפנה והנקודה הנוספת, במיוחד אם היא רחוקה, יכולה להאט דרסטית את הגלישה. במקרה שאנחנו מתחברים מישראל דרך ארהב לאתר אירופאי לדוגמה, אנחנו נתחבר מהבית, לספקית, לאיטליה, לפרנקפורט, משם לונדון/אמסטרדם, לניו יורק, לשרת ה-VPN, שאחר כך ישלח את הבקשה לניו יורק, לונדון, נקודה כלשהי באירופה, חזרה ללונדון, ניו יורק, שרת VPN ושוב לניו יורק, לונדון, פרנקפורט, איטליה, ישראל, אלינו. אם אנחנו ניגשים לשרת אמריקאי אנחנו חוסכים 2 כיוונים לאירופה, אבל עדיין מדובר בדרך שחוצה יבשות ואוקיינוס ואנחנו נחווה ניחות (גם אם לא אחד שיורגש יותר מדי).\nעם זאת כדאי לציין שבשעות עומס לפעמים דווקא ה-VPN יכול להיות יותר מהיר, בגלל שהוא עובר ב\"סמטאות” אינטרנט מאובטחות יותר ולכן ניגש לשרת בדרך פחות עמוסה, בניגוד לרוב האנשים שיעברו דרך כביש סואן.\n","description":"","tags":null,"title":"על VPN","uri":"/posts/vpn/"},{"categories":["."],"content":"אם נשאל את דוד בוב, זה כנראה יהיה עד 100…\nקשה באמת להגדיר כמה ארוכה פונקציה צריכה להיות, וכנראה שאי אפשר לנקב במספר ממשי (כל מספר שננקב כנראה יהיה שרירותיׂ), אבל אפשר להתווכח שלפונקציות קצרות יש מספר יתרונות בולטים שקשה להתעלם מהם.\nכשאני מתייחס לפונקציות קצרות, הכוונה היא לפירוק הקוד בפונקציה אחת לתתי פונקציות. או כמו שחובבי פילוסופיית היוניקס אוהבים לומר: כל פונקציה צריכה לעשות משהוא אחד, ולעשות אותו טוב. הקוד לא צריך להיות מושפע מאורך הפונקציה. הקוד הוא חלק נפרד, שנכתב בהתאם ליעילות הרלוונטית ועד כמה הוא קריא.\nאם ניקח פונקציה ארוכה מאוד ונתחיל לפרק אותה לתתי פונקציות, הדבר הראשון שיבלוט בעין זה שקל יותר להבין מה הפונקציה עושה (אם זה לא ברור לפי השם), ובערך איך היא עושה זאת. זה משמעותית תופס את העין מאשר קטע קוד ארוך שצריך להתחיל לקרוא שורה שורה ולתפוס את התמונה כמו פאזל לא מורכב (לא משנה עד כמה הקוד ‘קריא’).\nבנוסף, עטיפת קטעי קוד בפונקציות נותנת לנו עוד שכבת הפשטה. שכבת ההפשטה הזאת מעודדת אותנו להשתמש יותר בפונקציות הקיימות, מצמצמת חזרה על קוד קיים, ומאפשרת לנו יותר גמישות פונקציונאלית בתוך הפונקציות.\nמבחינת דיבוג גם יש יתרון- יהיה קל יותר לדבאג פונקציות מפורקות מבלי שנצטרך לדעת איזה חלק בקוד לתפוס כנקודת עצירה.\nטסטים גם עשויים לקבל יתרון כשאפשר לבנות יוניט טסטים על פונקציות בודדות במקום על אחת (למרות שעל עקרון כזה יש וויכוח, האם צריך לבדוק את התוצאה של הפונקציה דרך תתי הפונקציות שלה, הוא דרך הפונקציה כמכלול?).\nאני אף פעם לא בעד פתרונות שחור או לבן- כי כנראה פתרונות כאלה לא קיימים, לפחות לא בתוכנה. אבל לפונקציות קצרות, המפורקות לתתי פונקציות, כן יש יתרונות מאוד בולטים שקשה להתווכח איתם. לגבי חסרונות? אולי שיש יותר מידי לגו לשחק איתם, והשאלה היא אם זה חסרון מספיק גדול.\n","description":"","tags":[""],"title":"כמה ארוכה פונקציה צריכה להיות?","uri":"/posts/function-length/"},{"categories":["."],"content":"מה זה כל האסקים, UTFים וכל קידודים האלה?\nנתחיל מהאב הקדמון- קוד מורס האגדי. קוד מורס הומצא כשיטה להעביר הודעה דרך אמצעים אלקטרונים ולתרגם את הצלילים המועברים לאותיות. את ההודעה בונים בעזרת תקשורת בינארית(בתוספת של רווח בין הצלילים)- נקודה או קו. כך למשל את ההודעה “SOS” שכולנו מכירים, אפשר לקרוא בקוד מורס כ- “… - - - …”, ואם נשמע את הצליל של ההודעה הזאת, הוא יהיה מאוד מוכר לכולנו מאיפשהוא (כי טחנו את הצליל בכל מקום בסרטים הישנים).\nקוד מורס שירת את האנושות עד עליית המחשבים והתקשורת בין המחשבים, המשתמשת בתקשורת בינארית של 0 ו-1, דאז האנושות הייתה צריכה להתקדם קצת ולמצוא דרך חדשה לתרגם את המידע שנשמר או נשלח ברשת בצורה של 0 או 1’ים- לתווים ומספרים ממשיים.\nאז שיטות להפיכת מספרים רגילים לבינאריים וההפך- היה לנו. 1 זה 1, 2 זה 10, 3 זה 11 וכל’. אבל לתווים- לא היה לנו.\nואז נולדה לה טבלת ה- ASCII, שהיא מכילה את כל התווים של המקלדת שלכם, כש-33 התווים הראשונים מיוחסים ל\"פקודות” כמו SPACE, TAB, ESC , ו-65 עד 127 לשאר התווים כמו אותיות קטנות וגדולות (באנגלית בלבד- זה חשוב), + - = וכל’. הטבלת ASCII הראשונית הייתה מוגדרת ל- 7 ביטים לייצוג תו, כך שיש 128 אפשרויות סה\"כ. עכשיו אפשר לחזור אחריי: 1000001 זה A, ו- 1000010 זה B. הוריי אפשר לתרגם תווים מבינארית לאנגלית!\nעל אף ההתקדמות המטאורית, שאפילו בעזרת טבלת ASCII הטיסו חללית לירח, היה נחוץ בעוד פריצת דרך: אנחנו רוצים להעביר תווים בינלאומיים בכל העולם, ולא רק באנגלית. מה עם קצת אותיות בסינית, רוסית ועברית? ומה עם קצת אימוג’יז?\nשוב נכנסנו להריון והפעם הולדנו את ה- Unicode, שהיא טבלה שאפתנית המאכלסת את כל התווים בעולם- עברית, רוסית, יפנית, אימוג’י, ועוד (לכל תו יש “code point” שהוא המזהה הייחודי שלו בטבלה). עכשיו יש לנו טבלה משודרגת, וכל שנותר לנו הוא לייחס כל תוו לייצוג הבינארי שלו. לשם כך נוצרו להם קידודים שונים עם חוקים משלהם.\nכאן נכנס UTF-8 לתמונה. UTF-8 בהגדרתו הוא שימוש ב-8 ביטים לפחות לייצוג של תוו כלשהוא, הכולל את השימוש הרגיל של ה- ASCII שלנו. זה אומר, שהייצוג של A ב-UTF8 יהיה 01000001. גם ב- ASCII אגב הורחבו התווים מ-128 אפשרויות ל- 256 אפשרויות, כיאה לקומבינציות של byte אחד.\nמחיפוש בגוגל נתון שיש כ- 143,859 תווים ל-unicode, אבל התשובה כנראה מורכבת יותר. בכל מקרה, זה הרבה מעל ל-256 האפשרויות שיש בבייט אחד. אז מה עושים? ממשיכים לעוד בייט, ועוד בייט עד 6 בייטים (כלומר הקפיצות יהיו של bytes).\nומה עם UTF 16, 32? אותו רעיון- הייצוג של כל תו יהיה לפי 16 או 32 ביטים בהתאמה. לפי ההיגיון UTF-8 נשמע יעיל יותר, מכיוון שכל תוו מיוצג במינימום של 8 ביטים, בזמן שהאחרים ע\"י 16 ו-32, אבל זה לא מדויק. ישנם מקרים בהם דווקא להשתמש ב 16-UTF יעיל יותר (כמו בשפות אסיאתיות מסוימות), שכן פרזנטציות של אותיות בשפות מסויימות ב- 8UTF יהיו בגודל 4 בייטים, וב-16 יהיו בגודל 2 בייטים. בנוסף, מכיוון שטבלת ASCII תומכת בייצוג של 8 ביטים לתו, אז קידודים כמו 16,32 UTF לא ייתמכו במערכות המתבססות על ASCII.\nלקינוח, מה זה בדיוק codec? זה פשוט הסוג של הקידוד שאנחנו משתמשים בו. UTF-8 למשל, הוא סוג של codec.\n","description":"","tags":[""],"title":"UTF-8, ASCII \u0026 Unicode","uri":"/posts/utf-ascii-unicode/"},{"categories":["."],"content":"Asymmetric encryption \u0026 public/private puke\nבעידן של היום, כשהפרטיות והאבטחה שלנו ברשת רק הולכות ונשחקות, כדאי להיזכר בחשיבות של ההצפנה- מהיסודות של אינטרנט פתוח, חופשי ומאובטח. ובגזרה הזו הצפנה אסימטרית היא השיטה הכי נפוצה וכנראה שהכי חשובה, אבל עד כמה אתם יודעים איך היא עובדת?\nבשביל להבין את הצורך בהצפנה א-סימטרית כדאי להכיר את ההצפנה הסימטרית הפשוטה יותר. בהצפנה סימטרית אנחנו משתמשים במפתח סודי אחד גם לפיענוח וגם להצפנה. כלומר אם א’ וב’ רוצים להעביר ביניהם קובץ מוצפן סימטרית, א’ יצור מפתח סודי (סיסמה) שישמש להצפנת הקובץ, ישלח את הקובץ המוצפן לב’ ואז ב’ יצטרך להשתמש באותו המפתח של א’ בכדי לפענח את ההצפנה ולקבל את המידע הנחוץ.\nהבעיה היא שגם השולח וגם המקבל צריכים להיות עם אותו המפתח הסודי, מה שאומר שהם יאלצו לשתף אותו ביניהם בדרך כזו או אחרת, כך שבשלב כלשהו בדרך הם יאלצו לשתף את המפתח באופן לא מוצפן- וזה רע.\nאת הבעיה הזו פותרת הצפנה א-סימטרית. בהצפנה א-סימטרית משתמשים בשני מפתחות- מפתח ציבורי ומפתח פרטי. המפתח הציבורי חשוף לכולם, והוא המפתח שיוצר את ההצפנה. השולח נעזר במפתח הציבורי של המקבל בכדי לייצר קובץ מוצפן.\nעל מנת לפענח את ההצפנה יש להיעזר במפתח הפרטי, שנמצא רק אצל המקבל. גם השולח לא יכול לפענח את הקורס שהוא עצמו הצפין מאחר ואין לו את המפתח הפרטי.\nדוגמה: א’ וב’ שולחים אחד לשני הודעות עם הצפנה א-סימטרית. לכל אחד מהם יש 3 מפתחות- לא’ יש את המפתח הציבורי שלו, את המפתח הפרטי שלו ואת המפתח הציבורי של ב’. לב’ יש את המפתח הפרטי והציבורי שלו ואת המפתח הציבורי של א’. כשא’ שולח הודעה לב’, הוא מצפין אותה עם המפתח הציבורי של ב’. לאחר שההודעה הוצפנה הדרך היחידה לקרוא אותה היא באמצעות המפתח הפרטי של ב’ ולכן לא’ אין יכולת לקרוא את מה שהוא עצמו כתב. ההודעה נשלחת לב’ שבאמצעות המפתח הפרטי שלו קורא אותה.\nהמפתחות הפרטיים קשורים למפתחות הציבוריים ויכולים לפענח את ההצפנה שהם יצרו, אבל אי אפשר למצוא אותם באמצעות מפתח ציבורי.\nכל עוד הנמען שומר על המפתח הפרטי שלו, אי אפשר לפצח את ההצפנה ולראות את המידע שהועבר. גם במידה והמפתח הסודי של אחד הצדדים נגנב, אפשר לקרוא רק את ההודעות שנשלחו אליו. כלומר, אם המפתח הפרטי של א’ נגנב, אז כל ההודעות שנשלחו לא’, הודעות שהוצפנו על ידי המפתח הציבורי של א’ ומפוענחות על ידי המפתח הפרטי של א’, יהיו חשופות למי שמחזיק במפתח, אבל לא ההודעות שא’ שלח לב’. ההודעות שא’ שלח לב’ מוצפנות עם המפתח הציבורי של ב’ ועל מנת לפענח אותן יש צורך במפתח הפרטי של ב’.\nתכונה חשובה נוספת של הצפנה א-סימטרית היא היכולת להצפין את ההודעה עם המפתח הפרטי ואז לפענח אותה עם המפתח הציבורי. אמנם כל אחד יכול לקרוא את המידע שהרי לכל אחד יש את הגישה למפתח הציבורי, אבל מאחר והמידע הוצפן עם המפתח הפרטי שנמצא רק אצל אדם אחד אנחנו יכולים לאמת שמי ששלח את המידע הזה הוא אכן מי שהוא מתיימר להיות.\nההבדלים בין השיטות מתבטאים בין היתר באורך המפתחות. מאחר ובהצפנה א-סימטרית חייב להיות קשר מתמטי בין המפתח הציבורי למפתח הפרטי, פורצים יכולים באופן תיאורטי “להסיק” את המפתח הפרטי מהציבורי. כתוצאה מכך המפתחות בהצפנה א-סימטרית הם ארוכים באופן משמעותי- מפתח של 2048 ביט בהצפנה א-סימטרית מספק פחות או יותר את אותה רמת האבטחה של מפתח 128 ביט בהצפנה סימטרית.\nהיתרונות של השיטה הם אבטחה מוגברת ופתרון בעיית שיתוף המפתח הסודי, כמו גם אימות זהות השולח על ידי חתימה דיגטלית בדמות המפתח הפרטי. החסרונות הם האיטיות של השיטה ביחס להצפנה סימטרית והכוח העצום של המפתח הפרטי- אם המפתח הפרטי אבד או נגנב כל המידע אבד או נגנב.\n","description":"","tags":[""],"title":"הצפנה א-סימטרית","uri":"/posts/asymmetric-encryption/"},{"categories":["."],"content":"בשביל ללמוד רקורסיה, צריך ללמוד רקורסיה! או איך ללמוד רקורסיה the intuitive way 🙂.\nפונקציה רקורסיבית היא פונקציה שקוראת לעצמה בתוך עצמה (ושכולם כבר הפנימו כנראה). אבל עדיין יש אלמנטים עמומים שמבלבלים אנשים ברקורסיה (ובצדק).\nהדבר הראשון שמבלבל אנשים הוא איך קוראים לפונקציה בתוך עצמה, כשלא סיימנו עדיין את הפונקציה. הדבר השני, הוא איך ההיגיון מאחורי הקלעים עובד, שפולט את התשובה הנכונה כמו קסם.\nהסיבה שלקרוא לפונקציה בתוך עצמה “עובד”, הוא בגלל שכל קריאה לפונקציה נשמרת בזיכרון ב-stack (מחסנית), אשר עובדת לפי אחרון נכנס, ראשון יוצא. לדוגמה, אם נריץ את האלגוריתם הבא:\nfunc(n = 4): if n == 0 return func(n-1) print(n)\nקודם כל יודפס 1, אח\"כ 2, 3 ואז 4. זה בגלל שהקריאות נשמרות במחסנית לפי הסדר הבא: קודם נכנס למחסנית func(4), אחריו func(3)…עד 0, הקריאה העליונה במחסנית. כשמגיעים לתנאי העצירה (0), מפסיקים לשמור קריאות במחסנית ומתחילים לעבור לשורת ההדפסה print בכל אחת מהקריאות מהסוף להתחלה במחסנית: מדפיסים 1, ואז 2 וכן הלאה.\nקטע מעניין, הוא שעדיין אפשר להגיע ל-stackoverflow גם מבלי להשתמש במשפט הקסם “בלי תנאי עצירה”, שכן אם נציב מספר גדול כמו 10000, האלגוריתם עדיין יקרוס מ-stackoverflow בגלל השימוש הכבד במחסנית (צריך לשמור n קריאות במחסנית).\nלעומת זאת, אם נחליף את הסדר של ה- print:\nfunc(n = 4): if n == 0 return print(n) func(n-1)\nההדפסה תהיה הפוכה: התוצאה שנקבל היא 4, אחריו 3, 2, ואז 1. הפונקציה מדפיסה את המספר n, וקוראת לעצמה שוב עם n-1. ברגע שהגענו לתנאי העצירה n=0, אין עוד מה לעשות והקריאות חוזרות אחת אחרי השניה מהסוף להתחלה ללא קריאה לפעולות נוספות. אלגוריתם כזה נקרא tail recursion.\nההגדרה המילולית ל-tail recursion היא “הפעולה האחרונה של הפונקציה היא הקריאה לפונקציה עצמה”, כלומר אין עוד שורות או חישובים נוספים שעליה לבצע והיא מחזירה את התוצאה הסופית (אם יש מה להחזיר, לא במקרה שלנו). אלגוריתם שמשתמש ב-tail recursion יכול להיות לפעמים יעיל יותר מרקורסיה רגילה, שכן יש קומפיילרים המסוגלים לייעל את השימוש במחסנית (כלומר מתנהג כמו מימוש איטרטיבי).\nבאלגוריתמים בהם צריך להחזיר תוצאה, כמו למשל בפונקציה רקורסיבית לחישוב עצרת (כאשר n = 4), הרעיון עובד בצורה דומה: fact(n = 4) if n == 1 return 1 return n*fact(n-1)\nהקריאה הראשונה שנכנסת למחסנית הוא fact4, והיא אומרת “תן לי את התוצאה של fact3 ואני אתן לך את התוצאה של 4!. אותו דבר ל-fact3 עד שמגיעים ל n = 1, שבמקרה מחזיר 1 כתנאי עצירה. ואז מלמעלה למטה:\nfact(1) = 1 fact (2) = 2 * fact(1) = 21 fact(3) = 3 * fact(2) = 32 fact(4) = 4 * fact(3) = 4*6 = 24\nאלגוריתם של tail recursion ייראה כך:\nfacTail(n = 4, results = 1): if(n == 1) return results return facTail(n-1, results * n)\nהפעולה האחרונה היא קריאה רקורסיבית, והפונקציה מעדכנת את הפרמטר results עד התנאי עצירה, מחזירה את הערך הסופי ומעיפה את כל הקריאות מהמחסנית אחד אחד.\nבגלל השימוש הנדיב שלה במחסנית, רקורסיה (לפחות רגילה) תהיה איטית יותר מאלגוריתם איטרטיבי, ולכן ברוב המקרים התירוץ להשתמש באלגוריתם רקורסיבי יהיה בהתאם לאינטואיטיביות של המימוש.\nבדר\"כ האלגוריתמים האינטואיטיביים למימוש רקורסיבי הם במעבר על עצים, או מימושים של בעיות divide and conquer או במילים ישראליות- לפוצץ את הבעיה לחתיכות קטנות ולפתור. האלגוריתם לפתרון של tower of hanoi היא דוגמה ממש נפלאה לאיך אלגוריתם איטרטיבי ומסובך נחתך למס’ שורות מצומצם במימוש רקורסיבי.\nהרעיון המרכזי שצריך להפנים בפונקציה רקורסיבית רגילה, היא איך נשמרות הקריאות במחסנית, ולעבוד מלמעלה למטה- ואז הרבה יותר קל להבין את ההגיון מאחורי האלגוריתם. ב- tail recursion צריך להפנים שבסה\"כ מעדכנים כל פעם פרמטר(ים) ועובדים איתו מהגדול לקטן עד שבסוף מחזירים אותו.\n","description":"","tags":[""],"title":"איך ללמוד רקורסיה באופן אינטואיטיבי","uri":"/posts/intuitive-recursion/"},{"categories":["."],"content":"פרוטוקול ה-DNS, או בשמו המלא Domain Name System, הוא פרוטקול שכולנו משתמשים בו כל הזמן והופך את האינטרט לנגיש לכולם. למרות זאת, הוא לא זוכה למספיק יחס.\nה-DNS הוא למעשה ספר הטלפונים של האינטרנט. כשאנחנו מנסים להיכנס לויקיפדיה לדוגמה, אנחנו מזינים לשורת הכתובת בדפדפן כתובת שנוחה לבני אדם- wikipedia.org. הבעיה היא שמחשבים לא עובדים בצורה כזו, הכתובות של מחשבים הן כתובות IP מספריות. למעשה הכתובת של ויקיפדיה עבור המחשב היא 91.198.174.192 בפרוטקול IPv4 או 2620:0:862:ed1a::1 בפרוטקול Ipv6, ואף אחת מהן לא ידידותית למשתמש.\nוכאן ה-DNS נכנס לתמונה. ה-DNS מקשר בין הכתובת ה\"אנושית” wikipedia.org לכתובת האמיתית- 91.198.174.192.\nאיך ה-DNS יודע לקשר כתובות?\nכשאנחנו מזינים את הכתובת ולוחצים אינטר, נשלחת בקשה לשרת ה-DNS שלנו. איזה שרת בדיוק? זה תלוי. בהנחה שלא שיניתם את הגדרות ה-DNS אצלכם (בראוטר/מחשב/פלאפון וכו’), אתם משתשמשים בשרתי ברירת המחדל שהם השרתים של ספקית האינטרנט שלכם (שזה צעד ממש לא חכם, אבל זה לפוסט אחר).\nהשרת הזה נקרא DNS recursive resolver ואפשר להסתכל עליו כמעיין ספרנית שמקבלת שאילתא (query) ואז הולכת לחפש את הספר שמתאים לה (כתובת דומיין) על ידי סדרה של בקשות בשביל למצוא את המיקום המדויק.\nהתחנה הראשונה היא שרת Root Nameserver. השרת הזה למעשה מפנה את הספרנית למדור הנכון בספריה, שהוא ה-TLD (Top Level Domain) Nameserver המתאים או במילים אחרות- לשרת המתאים לסיומת הדומיין. בדוגמה שלwikipedia.org, ה-Root יפנה אותנו (כלומר את ה-DNS resolver) ל-TLD Nameserver שמתאים לסיומת org.\nמהרוט אנחנו מגיעים ל-TLD Nameserver המתאים. ה-TLD NS הוא למעשה המדף המתאים בספריה שמכיל את כל הספרים בקטג’ שביקשנו, או במקרה שלנו את כל הדומיינים עם סיומת org. ה-TLD NS מוצא את הרשומה של wikipedia.org ומפנה אותנו עם המידע הזה ל-Authoritative Nameserver, או לספר הספציפי.\nהשלב האחרון במסע שלנו מגיע כשה-resolver שולח בקשה ל-Authoritative Nameserver. ה-Autoritative NS מספק לו את המידע שהוא בדמות רקורד DNS מלא שכולל את כתובת ה-IP המתאימה וכל תת כתובת אחרת שנחוצה וההפניות שלה (לדוגמה תת דומיין שמפנה למקום אחר).\nמכאן ה-DNS resolver חוזר למחשב שלנו, מצויד בכתובת ה-IP של האתר שביקשנו. הדפדפן שולח בקשת HTTP לשרת ומקבל בחזרה את העמוד המבוקש. בנוסף לכך, גם ה-resolver וגם המחשב שלנו ישמרו את הבקשה הזו ב-cache כדי לחסוך את הטיול הזה בפעם הבאה שאנחנו צריכים את כתובת ה-IP של האתר.\n","description":"","tags":[""],"title":"מה זה DNS, ומה הוא עושה?","uri":"/posts/dns/"},{"categories":["."],"content":"אוטנטיקציה דרך קוקיז עובדת לא רע בכלל לאתרים, וקשה להצביע על יתרונות אבסולוטים למעבר אל אוטנטיקציה דרך JWT. אבל זה, כמובן, כשהאתר הוא אתר, ושהוא נתמך ע\"י דפדפנים שתומכים בקוקיז. מה עם אפליקציות נייטיב, שאין להן תמיכה של קוקיז? כאן JWT זורח.\nלמען הסר ספק, ההבדלים בין Authentication, Authorization הן ש-authentication הוא הזדהות (מי אתה?), ו- authorization הוא “אם אתה רוצה לקנות ערק תראה לי שאתה 21+” (הרשאה).\nאז הביטוי JWT נקרא Json Web Token, והמימוש שלו חמוד לאללה. JWT זה טוקן הנראה כגוש האש גדול, המופרד ל-3 חלקים בעזרת נקודה חמודה.\nהסטרינג הראשון, הוא בד\"כ json בעצמו שמכיל מידע על האלגוריתם האש שהשתמשו בטוקן כדי לחתום אותו. הסטרינג השני, שהוא גם בד\"כ Json, הוא המידע עצמו שרוצים לשמור כדי שהמשתמש יוכל להזדהות (כמו ID של המשתמש, תאריך תפוגה ועוד’).\nשני ה- jsonים מקודדים לסטנדרט של base64url, ואינם מוצפנים, כמובן. כל אחד יכול לפענח את שני הסטרינגים הללו ולקרוא את המידע. מכאן, מגיע הבטיחות בחלק השלישי של הטוקן: החתימה.\nהרעיון של הטוקן הוא לא להעביר מידע מוצפן (לפחות לא JWT סימטרי), אלא לוודא שאף אחד לא משנה את המידע. בשביל לוודא זאת, לוקחים את החלק הראשון (שנקרא גם header), החלק השני (שנקרא גם payload), מחברים אותם לסטרינג אחד, מוסיפים לו מפתח שקיים אצל השרת בלבד, ומהאהשים בהתאם להגדרות האלגוריתם של החלק הראשון (ה-header). התוצאה: סטרינג, או ‘חתימה’ שהיא החלק האחרון בטוקן. וזה, מוודא לנו שאף אחד לא נגע בטוקן. מי שיצר אותו יקבל את אותו הטוקן ללא שינויים זדוניים.\nמכיוון שרק לשרת יש את המפתח שאנחנו מוסיפים לחתימה, אף אחד אחר לא יכול לייצר את החתימה, ולכן אף אחד לא יוכל לעבוד על השרת. כשהשרת מקבל את הטוקן, הוא פועל שוב ע\"פ ההוראות למעלה, ומוודא שהחתימה שיוצאת לו, היא אותה חתימה המתקבלת בטוקן. לא- מחזיר 401, כן- יאללה ערק.\nהמקרה בו יש רק מפתח אחד, נקרא JWT סימטרי. כלומר, קיים רק מפתח אחד (‘פרטי’) שיכול לאשר את החתימה, ובשביל שעוד שרתים יוכלו לאשר את הטוקן, צריך לפזר את המפתח ביניהם. זה בד\"כ מתכון לפירצות אבטחה, כשאם שרת אחד נפרץ, כל השרתים שמחזיקים את המפתח נמצאים בסכנה.\n","description":"","tags":[""],"title":"למה JWT הוא ערק ערק ככה חזק?","uri":"/posts/jwt/"},{"categories":["."],"content":"כדי למדוד מהירות (פוטנציאל) אלגוריתמי כלשהיא, אנחנו נאלצים לבודד את המשתנים אשר מפריעים לנו למדוד את הפוטנציאל הטהור של האלגוריתם, כמו לבודד את המכונה מהמשוואה. איננו רוצים שאלגוריתם יהיה מהיר יותר כי יש לך את ה- AMD Ryzen החדש. בשביל זה יש לנו את הסיבוכיות- המודדת את כמות האופרציות שאלגוריתם מבצע, וכך נוכל להעריך גם את הפוטנציאל.\nחיפוש בינארי הוא עוד אלגוריתם שנולד מתוך הרצון לחתוך כמה שיותר את כמות האופרציות בזמן חיפוש, והקונספט שלו דומה לחיפוש בספרי דפי זהב שפעם היה לכולנו. במקום לחפש איבר אחד אחרי השני, אנחנו חותכים את החיפוש ספציפית לאות שבה מתחיל השם שאנחנו מחפשים. זה כל כך אפקטיבי, שאנחנו יכולים למצוא שם של אדם תוך כמה שניות, מאשר אפילו כמה שעות.\nיש לציין, שאי אפשר לבצע חיפוש בינארי עם הרשימה לא מסודרת. לא נוכל לחפש לפי אות אם האותיות לא מסודרת לפי ה- א’ ב’.\nהמשמעות של בינארי, אגב, פירושו יחס בין 2 פרטים. 0 או 1. זה או זה. פה או שם. ומכאן השם של חיפוש בינארי-אם לא פה אז אולי שם.\nאז הקונספט של חיפוש בינארי הוא דיי קליל. ניקח מערך מספרים ממויין, ונחפש ספרה כלשהיא. נתחיל מהאמצע- אם הספרה לא שווה, האם היא גדולה מן הספרה האמצעית? אם כן, נחתוך את הרשימה בחצי ונתחיל שוב, וכך הלאה. המעבר של “לחתוך בחצי” את המערך נותן לנו סיבוכיות של logn, במקום סיבוכיות של n, בה נצטרך לעבור איבר איבר במערך (דמיינו מעבר לפי שם שם בדפי זהב לפי הסדר של הא’ ב’).\nהפונקציה ‘log’ היא שיטה נעימה (או פחות?) יותר לשאלה: הבסיס בחזקת מה, ייתן לי את המספר x? בדר\"כ כשרואים ‘רק’ את המילה log, מתכוונים לבסיס 2. כלומר, כמות הפעמים שנחתוך את המערך עד למציאת האיבר שלנו, היא במקרה הכי גרוע פשוט החזקה. אם המערך שלנו הוא באורך 8, ייקח לנו במקסימום 3 פעמים שנצטרך לחתוך ולמצוא את האיבר שלנו.\nזה נהיה קריטי כשהמערך גדל מעריכית, אבל כמות האופרציות נשארת כפונקציה לוגריתמית.\nומכאן אפשר לשאול, יש לנו חיפוש בינארי- למה צריך עץ בינארי? עץ בינארי גם מאפשר לנו חיפוש בlogn, אבל כמובן רק אם הוא עץ מאוזן (כדוגמת עצי AVL, אדום שחור). אם העץ אינו מאוזן, הוא יכול לתת לנו חיפוש ב- logn, אבל החיפוש יכול להיות לינארי (בהתאם לכמות האיברים, n). לעומת זאת אם הוא מאוזן, הוא מבטיח לנו תמיד חיפוש בlogn.\nהיתרון שיש לעצים בינארים מאוזנים על פני חיפוש בינארי, הוא דווקא בהכנסה וההוצאה (insert, remove). בעצים בינארים מאוזנים גם ההכנסות וההוצאות נשארים logn (על אף שהם צריכים לאזן את עצמם), בזמן שבמערכים ההכנסה וההוצאה היא לינארית, בהתאם ל- n ולמיקום במערך שיש להוסיפה.\nלכן, המימוש של עצים בינארים יהיה מהיר יותר למקרים בהם לא רק יש צורך לחפש, אלא לבצע מניפולאציה כבדה על האיברים במערך.\n","description":"","tags":[""],"title":"למה חיפוש בינארי קיים או עדיף, למה בעצם להסתבך עם עצים בינארים?","uri":"/posts/binary-search-and-binary-trees/"},{"categories":["."],"content":"הכוונה בלכידות היא עד כמה הרכיבים קשורים אחד לשני, בתוך מודול ספציפי. ככל שהלכידות ‘גבוהה’ יותר, ככה ‘יותר טוב’.\nבמחלקה למשל, לכידות נמדדת ע\"פ כמה כל הפונקציות משתמשות בכמה שיותר משתנים הקיימים בה. ככל שכל הפונקציות משתמשות בכמה שיותר משתנים בתוך המחלקה, כך הסממן ברור: הקשר בין המשתנים לפונקציונאליות של המחלקה חזקים יותר ולהיפך.\nעוד מדד ללכידות, היא עד כמה הפונקציות במודול משרתות מטרה ברורה ומוגדרת. ככל שהמחלקה(למשל) שואפת להיות יותר פונקציונאלית ולצאת מתחום האחריות הברורה שלה, היא מאבדת מהשופטים נקודות (דוגמא קונקרטית: מתכנת, שאחראי לכתוב קוד, ועכשיו גם צריך לנקות את השירותים- זוהי הפרה ברורה של הגדרת המטרה שלו!).\nולמה זה כל כך משנה? אז לכידות מתקשרת באופן עקיף ל’צמידות”, או בשפה העממית tight coupling. נגיד שאתם פותחים מגירת סכו\"ם במטבח ומגלים שכל המגירה מבולגנת מהיסוד- מזלגות מעל הכפות וסכינים מעל הצלחות. לא רק שיהיה קשה לסדר את המגירה, היא לא ברורה בעליל. עכשיו תתארו שהמגירה מסודרת להפליא. מזלגות איפה שהמזלגות, וסכינים איפה שהסכינים. הכל מסודר, אפשר להכניס בקלות סכו\"ם חדש למגירה.\nלכידות היא עוד מדד מרכזי ב- oo (הלוא object oriented) המאפשר לנו להוריד את הסמתוכה ש-oo מעודד אותנו לייצר, ולשמור על מודולים (ו\\או מחלקות במקרה שלנו) מלהיות צמודים ותלויים אחד בשני. ככל שתחום האחריות מופרד אחד מהשני, קל יותר להבין את המערכת, לדבאג אותה ולשנות\\להוסיף. או במילים פשוטות יותר: המתכנתים יזדקנו לאט יותר.\n","description":"","tags":[""],"title":"לכידות(cohesion) או; איך לסדר מגירה כמו שצריך.","uri":"/posts/cohesion/"},{"categories":["."],"content":"פעם, המנטרה הייתה ברורה- קוד עם דוקומנטציה ברורה ומסודרת לכל דבר. היום משום מה, הגישה הזאת התעדנה קצת.\nהגישה היום הולכת ככה: הערות זה רע. התוצאה: רואים הרבה מאוד מערכות שלפעמים לא נמצא שורת comment אחת.\nהאם זה תקין? אולי. האם commenting הפך לילד רע? לא בדיוק.\nנתחיל ממקרה קלאסי של נגד הערה: מפתח כתב פונקציה, תיעד כמה שורות יפות ומתובלנות את הביצוע של הקוד, והמשיך לדרכו. כמה ימים אח\"כ, תיקן באג, שינה שורה או שתיים, והמשיך לדרכו. אבל רגע, מה עם הדוקומנטציה? אופסי.\nברגע שמתכנת צריך לתעד ולכתוב דוקומנטציה מלאה לכל קוד\\פונקציה, הוא ממש מבצע חתונה קתולית בינו לבין הקוד וההערות. יד ביד, כמו זוג אוהבים, הוא ייצטרך לתחזק גם את הקוד וגם את ההערות. זה יוצר עומס, בלבול, שגיאות וכמובן עצבים. וזה לא אמור להיות ככה.\nבעיה נוספת שהערות מייצרות לנו היא…זמן. לכתוב הערות לכל דבר לא יתרום אף פעם ליכולת של הקוד, או לביצוע של הקוד. אם זמן הוא מרכיב קריטי בפיתוח, צריך ממש לשקול לדלג על שלב כתיבת ההערות.\nהגישה שהתפתחה לה כיום כנגד כתיבת הערות נקראת ROC, כלומר: Really Obvious Code. שהקוד ידבר בפני עצמו, יהיה ברור ומסודר. מי שיירצה להבין איך הקוד עובד, צריך להסתכל על הקוד ולא על הסיפור שמעליו.\nאז האם לכתוב הערות הפך לboogyman של המפתחים היום? אז לא, לא בדיוק.\nיש מקומות בהם דווקא כן צריך דוקומנטציה ברורה, למשל ב- public API, librarys, שם אתה זקוק שהמשתמש יבין את המימושים השונים ולא יילך לאיבוד. אבל גם שם אפשר ללכת בגישה קצת אחרת מאשר משל של ארנב וצב מעל כל פונקציה. הגישה אומרת כך: כתוב מה הפונקציה צריכה לעשות, ולא מה היא עושה. את הפונקציונאליות של הקוד משאירים לקוד עצמו, ואת הפילוסופיה מאחוריה- להערות.\n","description":"","tags":[""],"title":"הממ…To comment or not to comment?","uri":"/posts/to-comment-or-not-to-comment/"},{"categories":["."],"content":"בפעם הראשונה שבניתי פרוייקט (ובמקרה הוא היה בג’אווה), הוא ככל הנראה היה הפרוייקט הכי שאפתני שלי; ניסיתי למפות את גוף האדם. ההשראה נבעה מהיכולת של Inheritance, שאיפשרה לי ליצור קשרים ויחסים בין אובייקטים.\nמיותר לציין שהפרוייקט נגנז לאלתר, בעיקר בגלל קש קטן שהפך את כל הקשרים והיחסים שבניתי. הירושה דפקה את הכל.\nלירושה יש הרבה יתרונות, אבל יש לה מספר חסרונות מצומצם, והרסניות. מביניהן, והפופולארית- אנחנו לא תמיד יכולים (או צריכים) ליצור קשר של אב-בן בצורה נכונה, כזאת שתואמת לעולם האמיתי. ברגע שנוצר צורך שאינו תואם ליחס שבנינו, הכל מתחיל להתפורר לנו ומתחיל שלב ה refactorrrr.\nמאז השרשתי את המושג הרכבה מעל ירושה- במקום ליצור קשר בין אובייקטים בעזרת ירושה, אפשר בעזרת הרכבה (לשתול רפרנס של “היחס” בתור אובייקט כפרופרטי במחלקה). זה מאפשר גמישות כשאתה רוצה לשנות את היחס, ופלוס קטן הוא שאפשר להחביא את הגישה לאובייקט, כלומר encapsulate, יתרון שאין לנו בירושה (לא תוכל להחביא את הגישה ל-human בירושה כשאתה משתמש באובייקט של person).\nפגשתי מתכנתים שנשבעים לא להשתמש בירושה בכלל- ולא בטוח שזאת גישה נכונה. לירושה יש את היתרונות שלה, במיוחד במניעת חזרה על הקוד.\nאני בד\"כ לא מאמין בשחור ולבן- יש הרבה צבעים מסביב כשזה קשור לכתיבת קוד, ו\"לשלב” זאת לא בהכרח מילה גסה בפיתוח.\n","description":"","tags":[""],"title":"Composition Over Inheritance?","uri":"/posts/composition-over-inheritance/"},{"categories":["."],"content":"אולי Functional Programming נשמע כמו שיעור סטודיו בחדר כושר, אבל למרות שהשם שלו נשמע מיינסטרימי, יש פילוסופיה שלמה ומעניינת מאחוריה.\nהמוטיב המרכזי שחוזר: פונקציות. לפשט את הכל לפונצקיות, ולהתייחס אל פונקציות בעדינות וחוכמה. כל קטע קוד שקיים במערכת, צריך להיות עטוף כפונקציה המבצעת פעולה אחת פשוטה, תוך קבלת קלט, ופליטת פלט כלשהו.\nהרעיון מאחורי המוטיב לקוח מהגישה המתמטית: הפונקציה מבצעת פעולה אחת, אתה יודע מה היא, ומה תהיה התוצאה בהתאם לקלט. ובקוד, זה מתבטא בכך שאתה לא צריך “לדבאג” את הפונקציה ולהבין מה לא בסדר איתה, אלא אמור לקחת בחשבון שהיא עובדת כמו שצריך (אם נכתב כמו שצריך), וגם ברורה בדיוק מה היא עושה, כך שאתה בכלל לא צריך להתחיל להיכנס לכל פונקציה בקוד. כל הבעיות שיכולות “לצוץ” צריכות להיות קשורות בשרשור והלוגיה של הפונקציות, ולא בפונקציות עצמן.\nבנוסף, בתכנות פונקציונאלי (שאתייחס כ-FP) כל האובייקטים הם immutable, כלומר ברגע שמייצרים אותם, אסור לשנות אותם. אם אתה רוצה לערוך אותם, תצטרך להחזיר עם פונקציה אובייקט חדש עם הערכים החדשים. לחידוד, להעביר כקלט את האובייקט לפונקציה ולערוך את האובייקט בתוך הפונקציה עצמה לא מתקבל בחשבון.\nוכמובן, שאין יותר forloop, במיוחד fori (בגלל שהוא מבצע שינוי סטייט ל-i!), ובכדי לבצע איטרציה כלשהיא, משתמשים ברקורסיה (בכל זאת, אני ראיתי מספיק מתכנתיי FP שעדיין משתמשים בforeach, ולא נראה שהעולם קרס להם).\nלסיום, ל-FP יש מה לומר גם על error handling \u0026 null. מכיוון שפונקציות ב-FP הן כמו אלגברה, אין לך בדיוק ערך של NULL. השיטה המקובלת היא לעטוף את הערך המוחזר באובייקט כלשהוא, ולבדוק אם יש בו ערך (או לקרוא לפונקציה מתאימה). בשפות שמשרישות פילוסופיה FPית (כמו קוטלין וסקאלה) זה קצת יותר מחומם מזה.\nכדי למנוע אקספשיינס, ב-Go הפכו כל שגיאה לערך בפני עצמו. אתה כבר לא מקריס את האפליקציה כשנוצרת לך השגיאה, אלא מחזיר אותה בפונקציה כערך בפני עצמו (בדר\"כ כסוג של Tupel) ונותן לקורא הפונקציה להסתבך עם עצמו. האם זה יעיל? אולי, אבל דורש המון שכפול קוד.\nבתמונה: קטע מאימון פונקציונאלי שרשורי, וקצת קריא יותר. החדי קרן מבינינו יבחינו שאפשר לקצרר את השורה עוד יותר.\n","description":"","tags":[""],"title":"Functional Programming","uri":"/posts/functional-programming/"}]